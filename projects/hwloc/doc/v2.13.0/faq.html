<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hardware Locality (hwloc): Frequently Asked Questions (FAQ)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Hardware Locality (hwloc)<span id="projectnumber">&#160;2.13.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search',true);
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('faq.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">Frequently Asked Questions (FAQ) </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1 class="doxsection"><a class="anchor" id="faq1"></a>
Concepts</h1>
<h2 class="doxsection"><a class="anchor" id="faq_why"></a>
I only need binding, or the number of cores, why should I use hwloc ?</h2>
<p>hwloc is its portable API that works on a variety of operating systems. It supports binding of threads, processes and memory buffers (see <a class="el" href="group__hwlocality__cpubinding.html">CPU binding</a> and <a class="el" href="group__hwlocality__membinding.html">Memory binding</a>). Even if some features are not supported on some systems, using hwloc is much easier than reimplementing your own portability layer.</p>
<p>Moreover, hwloc provides knowledge of cores and hardware threads. It offers easy ways to bind tasks to individual hardware threads, or to entire multithreaded cores, etc. See <a class="el" href="#faq_smt">How may I ignore symmetric multithreading, hyper-threading, etc. in hwloc?</a>. Most alternative software for binding do not even know whether each core is single-threaded, multithreaded or hyper-threaded. They would bind to individual threads without any way to know whether multiple tasks are in the same physical core.</p>
<p>However, using hwloc comes with an overhead since a topology must be loaded before gathering information and binding tasks or memory. Fortunately this overhead may be significantly reduced by filtering non-interesting information out of the topology, see <a class="el" href="#faq_disable_faster">What may I disable to make hwloc faster?</a> below.</p>
<h2 class="doxsection"><a class="anchor" id="faq_disable_faster"></a>
What may I disable to make hwloc faster?</h2>
<p>Building a hwloc topology on a large machine may be slow because the discovery of hundreds of hardware cores or threads takes time (especially when reading thousands of sysfs files on Linux). Ignoring some objects (for instance caches) that aren't useful to the current application may improve this overhead. One should also consider using XML (see <a class="el" href="#faq_xml">I do not want hwloc to rediscover my enormous machine topology every time I rerun a process</a>) to work around such issues.</p>
<p>Contrary to lstopo which enables most features (see <a class="el" href="#faq_slow_lstopo">Why is lstopo slow?</a>), the default hwloc configuration is to keep all objects enabled except I/Os and instruction caches. This usually builds a very precise view of the CPU and memory subsystems, which may be reduced if some information is unneeded.</p>
<p><br  />
 The following code tells hwloc to build a much smaller topology that only contains Cores (explicitly filtered-in below), hardware threads (PUs, cannot be filtered-out), NUMA nodes (cannot be filtered-out), and the root object (usually a Machine; the root cannot be removed without breaking the tree):</p>
<pre class="fragment">hwloc_topology_t topology;
hwloc_topology_init(&amp;topology);
/* filter everything out */
hwloc_topology_set_all_types_filter(topology, HWLOC_TYPE_FILTER_KEEP_NONE);
/* filter Cores back in */
hwloc_topology_set_type_filter(topology, HWLOC_OBJ_CORE, HWLOC_TYPE_FILTER_KEEP_ALL);
hwloc_topology_load(topology);
</pre><p>However, one should remember that filtering such objects out removes locality information from the hwloc tree. For instance, we may not know anymore which PU is close to which NUMA node. This would be useful to applications that explicitly want to place specific memory buffers close to specific tasks. To ignore useless objects but keep those that bring locality/hierarchy information, applications may replace <a class="el" href="group__hwlocality__configuration.html#gga9a5a1f0140cd1952544477833733195ba4f835955414de92c77d99b8419d4647a" title="Ignore all objects of this type.">HWLOC_TYPE_FILTER_KEEP_NONE</a> with <a class="el" href="group__hwlocality__configuration.html#gga9a5a1f0140cd1952544477833733195ba7664716643bf1db83e631eed34f659e4" title="Only ignore objects if their entire level does not bring any structure.">HWLOC_TYPE_FILTER_KEEP_STRUCTURE</a> above.</p>
<p><br  />
 Starting with hwloc 2.8, it is also possible to ignore distances between objects, memory performance attributes, and kinds of CPU cores, by setting topology flags before load: </p><pre class="fragment">[...]
/* disable distances, memory attributes and CPU kinds */
hwloc_topology_set_flags(topology, HWLOC_TOPOLOGY_FLAG_NO_DISTANCES
                                   |HWLOC_TOPOLOGY_FLAG_NO_MEMATTRS
                                   |HWLOC_TOPOLOGY_FLAG_NO_CPUKINDS);
[...]
hwloc_topology_load(topology);
</pre><p><br  />
 Finally it is possible to prevent some hwloc components from being loaded and queried. If you are sure that the Linux (or x86) component is enough to discover everything you need, you may ask hwloc to disable all other components by setting something like <span class="tt">HWLOC_COMPONENTS=linux,stop</span> in the environment. See <a class="el" href="plugins.html">Components and plugins</a> for details.</p>
<h2 class="doxsection"><a class="anchor" id="faq_indexes"></a>
Should I use logical or physical/OS indexes? and how?</h2>
<p>One of the original reasons why hwloc was created is that <b>physical/OS indexes</b> (<span class="tt">obj-&gt;os_index</span>) are often crazy and unpredictable: processors numbers are usually non-contiguous (processors 0 and 1 are not physically close), they vary from one machine to another, and may even change after a BIOS or system update. These numbers make task placement hardly portable. Moreover some objects have no physical/OS numbers (caches), and some objects have non-unique numbers (core numbers are only unique within a socket). Physical/OS indexes are only guaranteed to exist and be unique for PU and NUMA nodes.</p>
<p>hwloc therefore introduces <b>logical indexes</b> (<span class="tt">obj-&gt;logical_index</span>) which are portable, contiguous and logically ordered (based on the resource organization in the locality tree). In general, one should only use logical indexes and just let hwloc do the internal conversion when really needed (when talking to the OS and hardware).</p>
<p>hwloc developers recommend that users do not use physical/OS indexes unless they really know what they are doing. The main reason for still using physical/OS indexes is when interacting with non-hwloc tools such as numactl or taskset, or when reading hardware information from raw sources such as /proc/cpuinfo.</p>
<p>Keep in mind is that physical indexes are internally used to fill CPU and node sets (<a class="el" href="group__hwlocality__object__sets.html#ga4bbf39b68b6f568fb92739e7c0ea7801" title="A CPU set is a bitmap whose bits are set according to CPU physical OS indexes.">hwloc_cpuset_t</a> and <a class="el" href="group__hwlocality__object__sets.html#ga37e35730fa7e775b5bb0afe893d6d508" title="A node set is a bitmap whose bits are set according to NUMA memory node physical OS indexes.">hwloc_nodeset_t</a>) because they are passed to operating systems for binding. Hence it is not recommended to display the contents of such sets (e.g. with <span class="tt"><a class="el" href="group__hwlocality__bitmap.html#ga3d06e6447edeb61e56a9ad83f31f0a37" title="Stringify a bitmap in the list format.">hwloc_bitmap_list_snprintf()</a></span>) without a clear indication that they are physical indexes. See also <a class="el" href="#faq_convert_indexes">How do I convert between logical and OS/physical indexes?</a></p>
<h2 class="doxsection"><a class="anchor" id="faq_convert_indexes"></a>
How do I convert between logical and OS/physical indexes?</h2>
<p>lstopo options <span class="tt">-l</span> and <span class="tt">-p</span> may be used to switch between logical indexes (prefixed with <span class="tt">L#</span>) and physical/OS indexes (<span class="tt">P#</span>). Converting one into the other may also be achieved with hwloc-calc which may manipulate either logical or physical indexes as input or output. See also <a class="el" href="tools.html#cli_hwloc_calc">hwloc-calc</a>.</p>
<pre class="fragment"># Convert PU with physical number 3 into logical number
$ hwloc-calc -I pu --physical-input --logical-output pu:3
5

# Convert a set of NUMA nodes from logical to physical
# (beware that the output order may not match the input order)
$ hwloc-calc -I numa --logical-input --physical-output numa:2-3 numa:7
0,2,5
</pre><p>From the C API, converting requires to go through objects to retrieve the other index. One may retrieve an object from a logical index with <a class="el" href="group__hwlocality__levels.html#ga1005a33633ddf9f730de692133e83dbd" title="Returns the topology object at logical index idx with type type.">hwloc_get_obj_by_type()</a> or <a class="el" href="group__hwlocality__levels.html#ga391f6b2613f0065673eaa4069b93d4e0" title="Returns the topology object at logical index idx from depth depth.">hwloc_get_obj_by_depth()</a>. Getting a PU object or NUMA node from a physical index may be performed <a class="el" href="group__hwlocality__helper__find__misc.html#gac060ecf6683fb0d206e46b28c64648ac" title="Returns the object of type HWLOC_OBJ_PU with os_index.">hwloc_get_pu_obj_by_os_index()</a> or <a class="el" href="group__hwlocality__helper__find__misc.html#gacc7623746b55a89bdc175ee99930c420" title="Returns the object of type HWLOC_OBJ_NUMANODE with os_index.">hwloc_get_numanode_obj_by_os_index()</a>.</p>
<p>Given that cpusets and nodesets contain physical index bits, one may also want to convert them to logical indexes. One solution consists in iterating over the input set (e.g. <a class="el" href="group__hwlocality__bitmap.html#ga3f6861045a8029ade373510ffa727d2a" title="Loop macro iterating on bitmap bitmap.">hwloc_bitmap_foreach_begin()</a>) and convert each (physical) bit into a PU object and then get its logical index.</p>
<p>A more general solution for converting a cpuset into the logical indexes of larger objects (e.g. Cores or Packages instead of PUs) is to iterate over the level and keep the objects whose cpuset intersects the input cpuset. See <a class="el" href="group__hwlocality__helper__find__covering.html#gae37eabe1f91b6524576e2c0dad3b3639" title="Iterate through same-type objects covering at least CPU set set.">hwloc_get_next_obj_covering_cpuset_by_type()</a> for instance.</p>
<p>See also <a class="el" href="#faq_indexes">Should I use logical or physical/OS indexes? and how?</a></p>
<h2 class="doxsection"><a class="anchor" id="faq_structural"></a>
hwloc is only a structural model, it ignores performance models, memory bandwidth, etc.?</h2>
<p>hwloc is indeed designed to provide applications with a structural model of the platform. This is an orthogonal approach to describing the machine with performance models, for instance using memory bandwidth or latencies measured by benchmarks. We believe that both approaches are important for helping application make the most of the hardware.</p>
<p>For instance, on a dual-processor host with four cores each, hwloc clearly shows which four cores are together. Latencies between all pairs of cores of the same processor are likely identical, and also likely lower than the latency between cores of different processors. However, the structural model cannot guarantee such implementation details. On the other side, performance models would reveal such details without always clearly identifying which cores are in the same processor.</p>
<p>The focus of hwloc is mainly of the structural modeling side. However, hwloc lets user adds performance information to the topology through distances (see <a class="el" href="topoattrs.html#topoattrs_distances">Distances</a>), memory attributes (see <a class="el" href="topoattrs.html#topoattrs_memattrs">Memory Attributes</a>) or even custom annotations (see <a class="el" href="#faq_annotate">How do I annotate the topology with private notes?</a>). hwloc may also use such distance information for grouping objects together (see <a class="el" href="#faq_onedim">hwloc only has a one-dimensional view of the architecture, it ignores distances?</a> and <a class="el" href="#faq_groups">What are these Group objects in my topology?</a>).</p>
<h2 class="doxsection"><a class="anchor" id="faq_onedim"></a>
hwloc only has a one-dimensional view of the architecture, it ignores distances?</h2>
<p>hwloc places all objects in a tree. Each level is a one-dimensional view of a set of similar objects. All children of the same object (siblings) are assumed to be equally interconnected (same distance between any of them), while the distance between children of different objects (cousins) is supposed to be larger.</p>
<p>Modern machines exhibit complex hardware interconnects, so this tree may miss some information about the actual physical distances between objects. The hwloc topology may therefore be annotated with distance information that may be used to build a more realistic representation (multi-dimensional) of each level. For instance, there can be a distance matrix that representing the latencies between any pair of NUMA nodes if the BIOS and/or operating system reports them.</p>
<p>For more information about the hwloc distances, see <a class="el" href="topoattrs.html#topoattrs_distances">Distances</a>.</p>
<h2 class="doxsection"><a class="anchor" id="faq_groups"></a>
What are these Group objects in my topology?</h2>
<p>hwloc comes with a set of predefined object types (Core, Package, NUMA node, Caches) that match the vast majority of hardware platforms. The <a class="el" href="group__hwlocality__object__types.html#ggacd37bb612667dc437d66bfb175a8dc55a5269ef95be72f88465559d35c9b7ad56" title="Group objects. Objects which do not fit in the above but are detected by hwloc and are useful to take...">HWLOC_OBJ_GROUP</a> type was designed for cases where this set is not sufficient. Groups may be used anywhere to add more structure information to the topology, for instance to show that 2 out of 4 NUMA nodes are actually closer than the others. When applicable, the <span class="tt">subtype</span> field describes why a Group was actually added (see also <a class="el" href="attributes.html#attributes_normal">Normal attributes</a>).</p>
<p>hwloc currently uses Groups for the following reasons: </p><ul>
<li>
NUMA parents when memory locality does not match any existing object. </li>
<li>
I/O parents when I/O locality does not match any existing object. </li>
<li>
Distance-based groups made of close objects. </li>
<li>
AMD Core Complex (CCX) (<span class="tt">subtype</span> is <span class="tt">Complex</span>, in the x86 backend), but these objects are usually merged with the L3 caches or Dies. </li>
<li>
AMD Bulldozer dual-core compute units (<span class="tt">subtype</span> is <span class="tt">ComputeUnit</span>, in the x86 backend), but these objects are usually merged with the L2 caches. </li>
<li>
Intel Extended Topology Enumeration levels such as Module and Tile (in the x86 and Windows backends). </li>
<li>
Windows processor groups when HWLOC_WINDOWS_PROCESSOR_GROUP_OBJS=1 is set in the environment (except if they contain exactly a single NUMA node, or a single Package, etc.). </li>
<li>
IBM S/390 "Books" on Linux (<span class="tt">subtype</span> is <span class="tt">Book</span>). </li>
<li>
Linux Clusters of CPUs (<span class="tt">subtype</span> is <span class="tt">Cluster</span>), for instance for ARM cores sharing of some internal cache or bus, or x86 cores sharing a L2 cache (since Linux kernel 5.16). <span class="tt">HWLOC_DONT_MERGE_CLUSTER_GROUPS=1</span> may be set in the environment to disable the automerging of these groups with identical caches, etc.  </li>
<li>
AIX unknown hierarchy levels. </li>
</ul>
<p>hwloc Groups are only kept if no other object has the same locality information. It means that a Group containing a single child is merged into that child. And a Group is merged into its parent if it is its only child. For instance a Windows processor group containing a single NUMA node would be merged with that NUMA node since it already contains the relevant hierarchy information.</p>
<p>When inserting a custom Group with hwloc_hwloc_topology_insert_group_object(), this merging may be disabled by setting its <span class="tt">dont_merge</span> attribute.</p>
<h2 class="doxsection"><a class="anchor" id="faq_asymmetric"></a>
What happens if my topology is asymmetric?</h2>
<p>hwloc supports asymmetric topologies even if most platforms are usually symmetric. For example, there could be different types of processors in a single machine, each with different numbers of cores, symmetric multithreading, or levels of caches.</p>
<p>In practice, asymmetric topologies are rare but occur for at least two reasons: </p><ul>
<li>
Intermediate groups may added for I/O affinity: on a 4-package machine, an I/O bus may be connected to 2 packages. These packages are below an additional Group object, while the other packages are not (see also <a class="el" href="#faq_groups">What are these Group objects in my topology?</a>). </li>
<li>
If only part of a node is available to the current process, for instance because the resource manager uses Linux Cgroups to restrict process resources, some cores (or NUMA nodes) will disappear from the topology (unless flag <a class="el" href="group__hwlocality__configuration.html#ggada025d3ec20b4b420f8038d23d6e7bdea10907044bbb306fd0dc76acf046d9258" title="Detect the whole system, ignore reservations, include disallowed objects.">HWLOC_TOPOLOGY_FLAG_INCLUDE_DISALLOWED</a> was passed). On a 32-core machine where 12 cores were allocated to the process, this may lead to one CPU package with 8 cores, another one with only 4 cores, and two missing packages.  </li>
</ul>
<p>To understand how hwloc manages such cases, one should first remember the meaning of levels and cousin objects. All objects of the same type are gathered as horizontal levels with a given depth. They are also connected through the cousin pointers of the <a class="el" href="structhwloc__obj.html" title="Structure of a topology object.">hwloc_obj</a> structure. Object attribute (cache depth and type, group depth) are also taken in account when gathering objects as horizontal levels. To be clear: there will be one level for L1i caches, another level for L1d caches, another one for L2, etc.</p>
<p>If the topology is asymmetric (e.g., if a group is missing above some processors), a given horizontal level will still exist if there exist any objects of that type. However, some branches of the overall tree may not have an object located in that horizontal level. Note that this specific hole within one horizontal level does not imply anything for other levels. All objects of the same type are gathered in horizontal levels even if their parents or children have different depths and types.</p>
<p>See the diagram in <a class="el" href="termsanddefs.html">Terms and Definitions</a> for a graphical representation of such topologies.</p>
<p>Moreover, it is important to understand that a same parent object may have children of different types (and therefore, different depths). <b>These children are therefore siblings (because they have the same parent), but they are <em>not</em> cousins (because they do not belong to the same horizontal level).</b></p>
<h2 class="doxsection"><a class="anchor" id="faq_nosmt"></a>
What happens to my topology if I disable symmetric multithreading, hyper-threading, etc. in the system?</h2>
<p>hwloc creates one PU (processing unit) object per hardware thread. If your machine supports symmetric multithreading, for instance Hyper-Threading, each Core object may contain multiple PU objects: </p><pre class="fragment">$ lstopo -
...
  Core L#0
    PU L#0 (P#0)
    PU L#1 (P#2)
  Core L#1
    PU L#2 (P#1)
    PU L#3 (P#3)
</pre><p>x86 machines usually offer the ability to disable hyper-threading in the BIOS. Or it can be disabled on the Linux kernel command-line at boot time, or later by writing in sysfs virtual files.</p>
<p>If you do so, the hwloc topology structure does not significantly change, but some PU objects will not appear anymore. No level will disappear, you will see the same number of Core objects, but each of them will contain a single PU now. The PU level does not disappear either (remember that hwloc topologies always contain a PU level at the bottom of the topology) even if there is a single PU object per Core parent. </p><pre class="fragment">$ lstopo -
...
  Core L#0
    PU L#0 (P#0)
  Core L#1
    PU L#1 (P#1)
</pre><h2 class="doxsection"><a class="anchor" id="faq_smt"></a>
How may I ignore symmetric multithreading, hyper-threading, etc. in hwloc?</h2>
<p>First, see <a class="el" href="#faq_nosmt">What happens to my topology if I disable symmetric multithreading, hyper-threading, etc. in the system?</a> for more information about multithreading.</p>
<p>If you need to ignore symmetric multithreading in software, you should likely manipulate hwloc Core objects directly: </p><pre class="fragment">/* get the number of cores */
unsigned nbcores = hwloc_get_nbobjs_by_type(topology, HWLOC_OBJ_CORE);
...
/* get the third core below the first package */
hwloc_obj_t package, core;
package = hwloc_get_obj_by_type(topology, HWLOC_OBJ_PACKAGE, 0);
core = hwloc_get_obj_inside_cpuset_by_type(topology, package-&gt;cpuset,
                                           HWLOC_OBJ_CORE, 2);
</pre><p>Whenever you want to bind a process or thread to a core, make sure you singlify its cpuset first, so that the task is actually bound to a single thread within this core (to avoid useless migrations). </p><pre class="fragment">/* bind on the second core */
hwloc_obj_t core = hwloc_get_obj_by_type(topology, HWLOC_OBJ_CORE, 1);
hwloc_cpuset_t set = hwloc_bitmap_dup(core-&gt;cpuset);
hwloc_bitmap_singlify(set);
hwloc_set_cpubind(topology, set, 0);
hwloc_bitmap_free(set);
</pre><p>With hwloc-calc or hwloc-bind command-line tools, you may specify that you only want a single-thread within each core by asking for their first PU object: </p><pre class="fragment">$ hwloc-calc core:4-7
0x0000ff00
$ hwloc-calc core:4-7.pu:0
0x00005500
</pre><p>When binding a process on the command-line, you may either specify the exact thread that you want to use, or ask hwloc-bind to singlify the cpuset before binding </p><pre class="fragment">$ hwloc-bind core:3.pu:0 -- echo "hello from first thread on core #3"
hello from first thread on core #3
...
$ hwloc-bind core:3 --single -- echo "hello from a single thread on core #3"
hello from a single thread on core #3
</pre><h1 class="doxsection"><a class="anchor" id="faq2"></a>
Advanced</h1>
<h2 class="doxsection"><a class="anchor" id="faq_xml"></a>
I do not want hwloc to rediscover my enormous machine topology every time I rerun a process</h2>
<p>Although the topology discovery is not expensive on common machines, its overhead may become significant when multiple processes repeat the discovery on large machines (for instance when starting one process per core in a parallel application). The machine topology usually does not vary much, except if some cores are stopped/restarted or if the administrator restrictions are modified. Thus rediscovering the whole topology again and again may look useless.</p>
<p>For this purpose, hwloc offers XML import/export and shared memory features.</p>
<p>XML lets you save the discovered topology to a file (for instance with the lstopo program) and reload it later by setting the HWLOC_XMLFILE environment variable. The HWLOC_THISSYSTEM environment variable should also be set to 1 to assert that loaded file is really the underlying system.</p>
<p>Loading a XML topology is usually much faster than querying multiple files or calling multiple functions of the operating system. It is also possible to manipulate such XML files with the C programming interface, and the import/export may also be directed to memory buffer (that may for instance be transmitted between applications through a package). See also <a class="el" href="xml.html">Importing and exporting topologies from/to XML files</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The environment variable HWLOC_THISSYSTEM_ALLOWED_RESOURCES may be used to load a XML topology that contains the entire machine and restrict it to the part that is actually available to the current process (e.g. when Linux Cgroup/Cpuset are used to restrict the set of resources). See <a class="el" href="envvar.html#envvar_allowed">Environment variables for changing allowed resources</a>.</dd></dl>
<p>Shared-memory topologies consist in one process exposing its topology in a shared-memory buffer so that other processes (running on the same machine) may use it directly. This has the advantage of reducing the memory footprint since a single topology is stored in physical memory for multiple processes. However, it requires all processes to map this shared-memory buffer at the same virtual address, which may be difficult in some cases. This API is described in <a class="el" href="group__hwlocality__shmem.html">Sharing topologies between processes</a>.</p>
<h2 class="doxsection"><a class="anchor" id="faq_multitopo"></a>
How many topologies may I use in my program?</h2>
<p>hwloc lets you manipulate multiple topologies at the same time. However, these topologies consume memory and system resources (for instance file descriptors) until they are destroyed. It is therefore discouraged to open the same topology multiple times.</p>
<p>Sharing a single topology between threads is easy (see <a class="el" href="threadsafety.html">Thread Safety</a>) since the vast majority of accesses are read-only.</p>
<p>If multiple topologies of different (but similar) nodes are needed in your program, have a look at <a class="el" href="#faq_diff">How to avoid memory waste when manipulating multiple similar topologies?</a>.</p>
<h2 class="doxsection"><a class="anchor" id="faq_diff"></a>
How to avoid memory waste when manipulating multiple similar topologies?</h2>
<p>hwloc does not share information between topologies. If multiple similar topologies are loaded in memory, for instance the topologies of different identical nodes of a cluster, lots of information will be duplicated.</p>
<p><a class="el" href="diff_8h_source.html">hwloc/diff.h</a> (see also <a class="el" href="group__hwlocality__diff.html">Topology differences</a>) offers the ability to compute topology differences, apply or unapply them, or export/import to/from XML. However, this feature is limited to basic differences such as attribute changes. It does not support complex modifications such as adding or removing some objects.</p>
<h2 class="doxsection"><a class="anchor" id="faq_annotate"></a>
How do I annotate the topology with private notes?</h2>
<p>Each hwloc object contains a <span class="tt">userdata</span> field that may be used by applications to store private pointers. This field is only valid during the lifetime of these container object and topology. It becomes invalid as soon the topology is destroyed, or as soon as the object disappears, for instance when restricting the topology. The userdata field is not exported/imported to/from XML by default since hwloc does not know what it contains. This behavior may be changed by specifying application-specific callbacks with <span class="tt"><a class="el" href="group__hwlocality__xmlexport.html#ga9d6ff0f7a8dd45be9aa8575ef31978cc" title="Set the application-specific callback for exporting object userdata.">hwloc_topology_set_userdata_export_callback()</a></span> and <span class="tt"><a class="el" href="group__hwlocality__xmlexport.html#ga5ac6917ea7289955fb1ffda4353af9b0" title="Set the application-specific callback for importing userdata.">hwloc_topology_set_userdata_import_callback()</a></span>.</p>
<p>Each object may also contain some <em>info</em> attributes (name and value strings) that are setup by hwloc during discovery and that may be extended by the user with <span class="tt"><a class="el" href="group__hwlocality__info__attr.html#gace7654bb8a9002caae1a4b8a59e7452e" title="Add the given name and value pair to the given object info attributes.">hwloc_obj_add_info()</a></span> (see also <a class="el" href="attributes.html">Object attributes</a>). Contrary to the <span class="tt">userdata</span> field which is unique, multiple info attributes may exist for each object, even with the same name. These attributes are always exported to XML. However, only character strings may be used as names and values.</p>
<p>It is also possible to insert Misc objects with a custom name anywhere as a leaf of the topology (see <a class="el" href="miscobjs.html">Miscellaneous objects</a>). And Misc objects may have their own userdata and info attributes just like any other object.</p>
<p>The hwloc-annotate command-line tool may be used for adding Misc objects and info attributes.</p>
<p>There is also a topology-specific userdata pointer that can be used to recognize different topologies by storing a custom pointer. It may be manipulated with <span class="tt"><a class="el" href="group__hwlocality__configuration.html#ga2cc7b7b155cba58dda203e54f1637b9c" title="Set the topology-specific userdata pointer.">hwloc_topology_set_userdata()</a></span> and <span class="tt"><a class="el" href="group__hwlocality__configuration.html#gad47dee1a30f4b00486b54872af030b43" title="Retrieve the topology-specific userdata pointer.">hwloc_topology_get_userdata()</a></span>.</p>
<h2 class="doxsection"><a class="anchor" id="faq_create_asymmetric"></a>
How do I create a custom heterogeneous and asymmetric topology?</h2>
<p>Synthetic topologies (see <a class="el" href="synthetic.html">Synthetic topologies</a>) allow to create custom topologies but they are always symmetric: same numbers of cores in each package, same local NUMA nodes, same shared cache, etc. To create an asymmetric topology, for instance to simulate hybrid CPUs, one may want to start from a larger symmetric topology and restrict it. <br  />
</p>
<p>Assuming we want two packages, one with 4 dual-threaded cores, and one with 8 single-threaded cores, first we create a topology with two identical packages, each with 8 dual-threaded cores: </p><pre class="fragment">$ lstopo -i "pack:2 core:8 pu:2" topo.xml
</pre><p> Then create the bitmask representing the PUs that we wish to keep and pass it to lstopo's restrict option: </p><pre class="fragment">$ hwloc-calc -i topo.xml pack:0.core:0-3.pu:0-1 pack:1.core:0-7.pu:0
0x555500ff
$ lstopo -i topo.xml --restrict 0x555500ff topo2.xml
$ mv -f topo2.xml topo.xml
</pre><p> To mark the cores of first package as Big (power hungry) and those of second package as Little (energy efficient), define CPU kinds: </p><pre class="fragment">$ hwloc-annotate topo.xml topo.xml -- none -- cpukind $(hwloc-calc -i topo.xml pack:0) 1 0 CoreType Big
$ hwloc-annotate topo.xml topo.xml -- none -- cpukind $(hwloc-calc -i topo.xml pack:1) 0 0 CoreType Little
</pre><p> <br  />
</p>
<p>A similar method may be used for heterogeneous memory. First we specify 2 NUMA nodes per package in our synthetic description: </p><pre class="fragment">$ lstopo -i "pack:2 [numa(memory=100GB)] [numa(memory=10GB)] core:8 pu:2" topo.xml
</pre><p> Then remove the second node of first package: </p><pre class="fragment">$ hwloc-calc -i topo.xml --nodeset node:all ~pack:0.node:1
0x0000000e
$ lstopo -i topo.xml --restrict nodeset=0xe topo2.xml
$ mv -f topo2.xml topo.xml
</pre><p> Then make one large node even bigger: </p><pre class="fragment">$ hwloc-annotate topo.xml topo.xml -- pack:0.numa:0 -- size 200GB
</pre><p> Now we have 200GB in first package, and 100GB+10GB in second package. <br  />
</p>
<p>Next we may specify that the small NUMA node (second of second package) is HBM while the large ones are DRAM: </p><pre class="fragment">$ hwloc-annotate topo.xml topo.xml -- pack:0.numa:0 pack:1.numa:0 -- subtype DRAM
$ hwloc-annotate topo.xml topo.xml -- pack:1.numa:1 -- subtype HBM
</pre><p> Finally we may define memory performance attributes to specify that the HBM bandwidth (200GB/s) from local cores is higher than the DRAM bandwidth (50GB/s): </p><pre class="fragment">$ hwloc-annotate topo.xml topo.xml -- pack:0.numa:0 -- memattr Bandwidth pack:0 50000
$ hwloc-annotate topo.xml topo.xml -- pack:1.numa:0 -- memattr Bandwidth pack:1 50000
$ hwloc-annotate topo.xml topo.xml -- pack:1.numa:1 -- memattr Bandwidth pack:1 200000
</pre><p> <br  />
</p>
<p>There is currently no way to create or modify I/O devices attached to such fake topologies. There is also no way to have some <em>partial levels</em>, e.g. a L3 cache in one package but not in the other. <br  />
</p>
<p>More changes may obviously be performed by manually modifying the XML export file. Simple operations such as modifying object attributes (cache size, memory size, name-value info attributes, etc.), moving I/O subtrees, moving Misc objects, or removing objects are easy to perform.</p>
<p>However, modifying CPU and Memory objects requires care since cpusets and nodesets are supposed to remain consistent between parents and children. Similarly, PCI bus IDs should remain consistent between bridges and children within an I/O subtree.</p>
<h1 class="doxsection"><a class="anchor" id="faq3"></a>
Caveats</h1>
<h2 class="doxsection"><a class="anchor" id="faq_slow_lstopo"></a>
Why is lstopo slow?</h2>
<p>lstopo enables most hwloc objects and discovery flags by default so that the output topology is as precise as possible (while hwloc disables many of them by default). This includes I/O device discovery through PCI libraries as well as external libraries such as NVML. To speed up lstopo, you may disable such features with command-line options such as <span class="tt">--no-io</span>.</p>
<p>When NVIDIA GPU probing is enabled (e.g. with CUDA or NVML), one may enable the <em>Persistent</em> mode (with <span class="tt">nvidia-smi -pm 1</span>) to avoid significant GPU wakeup and initialization overhead.</p>
<p>When AMD GPU discovery is enabled with OpenCL and hwloc is used remotely over ssh, some spurious round-trips on the network may significantly increase the discovery time. Forcing the <span class="tt">DISPLAY</span> environment variable to the remote X server display (usually <span class="tt">:0</span>) instead of only setting the <span class="tt">COMPUTE</span> variable may avoid this.</p>
<p>Also remember that these hwloc components may be disabled. At build-time, one may pass configure flags such as <span class="tt">--disable-opencl</span>, <span class="tt">--disable-cuda</span>, <span class="tt">--disable-nvml</span>, <span class="tt">--disable-rsmi</span>, and <span class="tt">--disable-levelzero</span>. At runtime, one may set the environment variable <span class="tt">HWLOC_COMPONENTS=-opencl,-cuda,-nvml,-rsmi,-levelzero</span> or call <a class="el" href="group__hwlocality__setsource.html#ga9ad41adf418cee1c0ee32ba9bd4a3d36" title="Prevent a discovery component from being used for a topology.">hwloc_topology_set_components()</a>.</p>
<p>Remember that these backends are disabled by default, except in lstopo. If hwloc itself is still too slow even after disabling all the I/O devices as explained above, see also <a class="el" href="#faq_disable_faster">What may I disable to make hwloc faster?</a> for disabling even more features.</p>
<h2 class="doxsection"><a class="anchor" id="faq_privileged"></a>
Does hwloc require privileged access?</h2>
<p>hwloc discovers the topology by querying the operating system. Some minor features may require privileged access to the operation system. For instance memory module discovery on Linux is reserved to root, and the entire PCI discovery on Solaris and BSDs requires access to some special files that are usually restricted to root (/dev/pci* or /devices/pci*).</p>
<p>To workaround this limitation, it is recommended to export the topology as a XML file generated by the administrator (with the lstopo program) and make it available to all users (see <a class="el" href="xml.html">Importing and exporting topologies from/to XML files</a>). It will offer all discovery information to any application without requiring any privileged access anymore. Only the necessary hardware characteristics will be exported, no sensitive information will be disclosed through this XML export.</p>
<p>This XML-based model also has the advantage of speeding up the discovery because reading a XML topology is usually much faster than querying the operating system again.</p>
<p>The utility <span class="tt">hwloc-dump-hwdata</span> is also involved in gathering privileged information at boot time and making it available to non-privileged users (note that this may require a specific SELinux MLS policy module). However, it only applies to Intel Xeon Phi processors for now (see <a class="el" href="#faq_knl_dump">Why do I need hwloc-dump-hwdata for memory on Intel Xeon Phi processor?</a>). See also <span class="tt">HWLOC_DUMPED_HWDATA_DIR</span> in <a class="el" href="envvar.html">Environment Variables</a> for details about the location of dumped files.</p>
<h2 class="doxsection"><a class="anchor" id="faq_os_error"></a>
What should I do when hwloc reports "operating system" warnings?</h2>
<p>When the operating system reports invalid locality information (because of either software or hardware bugs), hwloc may fail to insert some objects in the topology because they cannot fit in the already built tree of resources. If so, hwloc will report a warning like the following. The object causing this error is ignored, the discovery continues but the resulting topology will miss some objects and may be asymmetric (see also <a class="el" href="#faq_asymmetric">What happens if my topology is asymmetric?</a>).</p>
<pre class="fragment">****************************************************************************
* hwloc received invalid information from the operating system.
*
* L3 (cpuset 0x000003f0) intersects with NUMANode (P#0 cpuset 0x0000003f) without inclusion!
* Error occurred in topology.c line 940
*
* Please report this error message to the hwloc user's mailing list,
* along with the files generated by the hwloc-gather-topology script.
*
* hwloc will now ignore this invalid topology information and continue.
****************************************************************************
</pre><p>These errors are common on large AMD platforms because of BIOS and/or Linux kernel bugs causing invalid L3 cache information. In the above example, the hardware reports a L3 cache that is shared by 2 cores in the first NUMA node and 4 cores in the second NUMA node. That's wrong, it should actually be shared by all 6 cores in a single NUMA node. The resulting topology will miss some L3 caches.</p>
<p>If your application does not care about cache sharing, or if you do not plan to request cache-aware binding in your process launcher, you may likely ignore this error (and hide it by setting HWLOC_HIDE_ERRORS=2 in your environment).</p>
<p>Some platforms report similar warnings about conflicting Packages and NUMANodes.</p>
<p>On x86 hosts, passing <span class="tt">HWLOC_COMPONENTS=x86</span> in the environment may workaround some of these issues by switching to a different way to discover the topology.</p>
<p>Upgrading the BIOS and/or the operating system may help. Otherwise, as explained in the message, reporting this issue to the hwloc developers (by sending the tarball that is generated by the hwloc-gather-topology script on this platform) is a good way to make sure that this is a software (operating system) or hardware bug (BIOS, etc).</p>
<p>See also <a class="el" href="index.html#bugs">Questions and Bugs</a>. Opening an issue on GitHub automatically displays hints on what information you should provide when reporting such bugs.</p>
<h2 class="doxsection"><a class="anchor" id="faq_valgrind"></a>
Why does Valgrind complain about hwloc memory leaks?</h2>
<p>If you are debugging your application with Valgrind, you want to avoid memory leak reports that are caused by hwloc and not by your program.</p>
<p>hwloc itself is often checked with Valgrind to make sure it does not leak memory. However, some global variables in hwloc dependencies are never freed. For instance libz allocates its global state once at startup and never frees it so that it may be reused later. Some libxml2 global state is also never freed because hwloc does not know whether it can safely ask libxml2 to free it (the application may also be using libxml2 outside of hwloc).</p>
<p>These unfreed variables cause leak reports in Valgrind. hwloc installs a Valgrind <em>suppressions</em> file to hide them. You should pass the following command-line option to Valgrind to use it: </p><pre class="fragment">  --suppressions=/path/to/hwloc-valgrind.supp
</pre><h1 class="doxsection"><a class="anchor" id="faq4"></a>
Platform-specific</h1>
<h2 class="doxsection"><a class="anchor" id="faq_rocm_build"></a>
How do I enable ROCm SMI and select which version to use?</h2>
<p>hwloc enables ROCm SMI as soon as it finds its development headers and libraries on the system. This detection consists in looking in <span class="tt">/opt/rocm</span> by default. If a ROCm version was specified with <span class="tt">--with-rocm-version=4.4.0</span> or in the <span class="tt">ROCM_VERSION</span> environment variable, then <span class="tt">/opt/rocm-&lt;version&gt;</span> is used instead. Finally, a specific installation path may be specified with <span class="tt">--with-rocm=/path/to/rocm</span>.</p>
<p>As usual, developer header and library paths may also be set through environment variables such as <span class="tt">LIBRARY_PATH</span> and <span class="tt">C_INCLUDE_PATH</span>.</p>
<p>To find out whether ROCm SMI was detected and enabled, look in <em>Probe / display I/O devices</em> at the end of the configure script output. Passing <span class="tt">--enable-rsmi</span> will also cause configure to fail if RSMI could not be found and enabled in hwloc.</p>
<h2 class="doxsection"><a class="anchor" id="faq_cuda_build"></a>
How do I enable CUDA and select which CUDA version to use?</h2>
<p>hwloc enables CUDA as soon as it finds CUDA development headers and libraries on the system. This detection may be performed thanks to <span class="tt">pkg-config</span> but it requires hwloc to know which CUDA version to look for. This may be done by passing <span class="tt">--with-cuda-version=11.0</span> to the configure script. Otherwise hwloc will also look for the <span class="tt">CUDA_VERSION</span> environment variable.</p>
<p>If <span class="tt">pkg-config</span> does not work, passing <span class="tt">--with-cuda=/path/to/cuda</span> to the configure script is another way to define the corresponding library and header paths. Finally, these paths may also be set through environment variables such as <span class="tt">LIBRARY_PATH</span> and <span class="tt">C_INCLUDE_PATH</span>.</p>
<p>These paths, either detected by <span class="tt">pkg-config</span> or given manually, will also be used to detect NVML and OpenCL libraries and enable their hwloc backends.</p>
<p>To find out whether CUDA was detected and enabled, look in <em>Probe / display I/O devices</em> at the end of the configure script output. Passing <span class="tt">--enable-cuda</span> will also cause configure to fail if CUDA could not be found and enabled in hwloc.</p>
<p>Note that <span class="tt">--with-cuda=/nonexisting</span> may be used to disable all dependencies that are installed by CUDA, i.e. the CUDA, NVML and NVIDIA OpenCL backends, since the given directory does not exist.</p>
<h2 class="doxsection"><a class="anchor" id="faq_hybrid_numa"></a>
How do I find the local HBM NUMA node on heterogeneous memory systems?</h2>
<p>Intel Xeon Phi processors introduced a new memory architecture by possibly having two distinct local memories: some normal memory (DRAM) and some high-bandwidth on-package memory (HBM, actually called MCDRAM on Xeon Phi). Processors can be configured in various clustering modes to have up to 4 <em>Clusters</em>. Moreover, each <em>Cluster</em> (quarter, half or whole processor) of the processor may have its own local parts of the DDR and of the MCDRAM. This memory and clustering configuration may be probed by looking at MemoryMode and ClusterMode attributes, see <a class="el" href="attributes.html#attributes_info_platform">Hardware Platform Information</a> and doc/examples/get-knl-modes.c in the source directory. These processors are now obsolete but other models such as the Intel Xeon Max support similar features.</p>
<p>Since with version 2.0, hwloc properly exposes this memory configuration. DRAM and HBM are attached as two memory children of the same parent, DRAM first, and HBM second if any. Depending on the hardware configuration, that parent may be a Package, a Cache, or a Group object (of type <span class="tt">Cluster</span> on Xeon Phi).</p>
<p>Hence cores may have two local NUMA nodes, listed by the core nodeset. An application may allocate local memory from a core by using that nodeset. The operating system will actually allocate from the DRAM when possible, or fallback to the HBM.</p>
<p>To allocate specifically on one of these memories, one should walk up the parent pointers until finding an object with some memory children. Looking at these memory children will give the DRAM first, then the HBM/MCDRAM if any. Their nodeset may then be used for allocating or binding memory buffers.</p>
<p>One may also traverse the list of NUMA nodes until finding some whose cpuset matches the target core or PUs. The high-bandwidth NUMA nodes may be identified thanks to the <span class="tt">subtype</span> field which is set to <span class="tt">HBM</span> (or <span class="tt">MCDRAM</span> on XeonPhi).</p>
<p>Command-line tools such as <span class="tt">hwloc-bind</span> may bind memory on the HBM/MCDRAM by using the <em>hbm</em> keyword or by selecting MCDRAM nodes explicitly. For instance, to bind on the first HBM/MCDRAM NUMA node on Xeon Phi:</p>
<pre class="fragment">$ hwloc-bind --membind --hbm numa:0 -- myprogram
$ hwloc-bind --membind numa[mcdram]:0 -- myprogram
</pre><p>See also <a class="el" href="heteromem.html#heteromem_use_cli">Using Heterogeneous Memory from the command-line</a></p>
<h2 class="doxsection"><a class="anchor" id="faq_knl_dump"></a>
Why do I need hwloc-dump-hwdata for memory on Intel Xeon Phi processor?</h2>
<p>Intel Xeon Phi processors may use the on-package memory (MCDRAM) as either memory or a memory-side cache (reported as a L3 cache by hwloc by default, see <span class="tt">HWLOC_KNL_MSCACHE_L3</span> in <a class="el" href="envvar.html">Environment Variables</a>). There are also several clustering modes that significantly affect the memory organization (see <a class="el" href="#faq_hybrid_numa">How do I find the local HBM NUMA node on heterogeneous memory systems?</a> for more information about these modes). Details about these are currently only available to privileged users. Without them, hwloc relies on a heuristic for guessing the modes.</p>
<p>The hwloc-dump-hwdata utility may be used to dump this privileged binary information into human-readable and world-accessible files that the hwloc library will later load. The utility should usually run as root once during boot, in order to update dumped information (stored under /var/run/hwloc by default) in case the MCDRAM or clustering configuration changed between reboots.</p>
<p>When SELinux MLS policy is enabled, a specific hwloc policy module may be required so that all users get access to the dumped files (in /var/run/hwloc by default). One may use hwloc policy files from the SELinux Reference Policy at <a href="https://github.com/TresysTechnology/refpolicy-contrib">https://github.com/TresysTechnology/refpolicy-contrib</a> (see also the documentation at <a href="https://github.com/TresysTechnology/refpolicy/wiki/GettingStarted">https://github.com/TresysTechnology/refpolicy/wiki/GettingStarted</a>).</p>
<p>hwloc-dump-hwdata requires <span class="tt">dmi-sysfs</span> kernel module loaded.</p>
<p>The utility is currently unneeded on platforms without Intel Xeon Phi processors.</p>
<p>See <span class="tt">HWLOC_DUMPED_HWDATA_DIR</span> in <a class="el" href="envvar.html">Environment Variables</a> for details about the location of dumped files.</p>
<h2 class="doxsection"><a class="anchor" id="faq_bgq"></a>
How do I build hwloc for BlueGene/Q?</h2>
<p>IBM BlueGene/Q machines run a standard Linux on the login/frontend nodes and a custom CNK (<em>Compute Node Kernel</em>) on the compute nodes.</p>
<p>To discover the topology of a login/frontend node, hwloc should be configured as usual, without any BlueGene/Q-specific option.</p>
<p>However, one would likely rather discover the topology of the compute nodes where parallel jobs are actually running. If so, hwloc must be cross-compiled with the following configuration line: </p><pre class="fragment">./configure --host=powerpc64-bgq-linux --disable-shared --enable-static \
  CPPFLAGS='-I/bgsys/drivers/ppcfloor -I/bgsys/drivers/ppcfloor/spi/include/kernel/cnk/'
</pre><p>CPPFLAGS may have to be updated if your platform headers are installed in a different directory.</p>
<h2 class="doxsection"><a class="anchor" id="faq_windows"></a>
How do I build hwloc for Windows?</h2>
<p><b>hwloc binary releases for Windows are available on the website download pages</b> (as pre-built ZIPs for both 32bits and 64bits x86 platforms). However hwloc also offers several ways to build on Windows:</p>
<ul>
<li>
The usual Unix build steps (<span class="tt">configure</span>, <span class="tt">make</span> and <span class="tt">make install</span>) work on the <b>MSYS2/MinGW</b> environment on Windows (the official hwloc binary releases are built this way). Some environment variables and options must be configured, see <span class="tt">contrib/ci.inria.fr/job-3-mingw.sh</span> in the hwloc repository for an example (used for nightly testing).  </li>
<li>
hwloc also supports such Unix-like builds in <b>Cygwin</b> (environment for porting Unix code to Windows).  </li>
<li>
Windows build is also possible with <b>CMake</b> (<span class="tt">CMakeLists.txt</span> available under <span class="tt">contrib/windows-cmake/</span>).  </li>
<li>
hwloc also comes with an example of <b>Microsoft Visual Studio solution</b> (under <span class="tt">contrib/windows/</span>) that may serve as a base for custom builds.  </li>
</ul>
<h2 class="doxsection"><a class="anchor" id="faq_netbsd_bind"></a>
How to get useful topology information on NetBSD?</h2>
<p>The NetBSD (and FreeBSD) backend uses x86-specific topology discovery (through the x86 component). This implementation requires CPU binding so as to query topology information from each individual processor. This means that hwloc cannot find any useful topology information unless user-level process binding is allowed by the NetBSD kernel. The <span class="tt">security.models.extensions.user_set_cpu_affinity</span> sysctl variable must be set to 1 to do so. Otherwise, only the number of processors will be detected.</p>
<h2 class="doxsection"><a class="anchor" id="faq_aix_bind"></a>
Why does binding fail on AIX?</h2>
<p>The AIX operating system requires specific user capabilities for attaching processes to resource sets (CAP_NUMA_ATTACH). Otherwise functions such as <a class="el" href="group__hwlocality__cpubinding.html#ga80bc07473a8edf840cae17bd7ec21d48" title="Bind current process or thread on CPUs given in physical bitmap set.">hwloc_set_cpubind()</a> fail (return -1 with errno set to EPERM).</p>
<p>This capability must also be inherited (through the additional CAP_PROPAGATE capability) if you plan to bind a process before forking another process, for instance with <span class="tt">hwloc-bind</span>.</p>
<p>These capabilities may be given by the administrator with: </p><pre class="fragment">chuser "capabilities=CAP_PROPAGATE,CAP_NUMA_ATTACH" &lt;username&gt;
</pre><h1 class="doxsection"><a class="anchor" id="faq5"></a>
Compatibility between hwloc versions</h1>
<h2 class="doxsection"><a class="anchor" id="faq_version_api"></a>
How do I handle API changes?</h2>
<p>The hwloc interface is extended with every new major release. Any application using the hwloc API should be prepared to check at compile-time whether some features are available in the currently installed hwloc distribution.</p>
<p>For instance, to check whether the hwloc version is at least 2.0, you should use: </p><pre class="fragment">#include &lt;hwloc.h&gt;
#if HWLOC_API_VERSION &gt;= 0x00020000
...
#endif
</pre><p>To check for the API of release X.Y.Z at build time, you may compare <a class="el" href="group__hwlocality__api__version.html#ga8f4dfb8eef138af55dd1a0fa802e5476" title="Indicate at build time which hwloc API version is being used.">HWLOC_API_VERSION</a> with <span class="tt">(X&lt;&lt;16)+(Y&lt;&lt;8)+Z</span>.</p>
<p>For supporting older releases that do not have <span class="tt"><a class="el" href="group__hwlocality__object__types.html#ggacd37bb612667dc437d66bfb175a8dc55a9d917a3e5497950c6d8948b8e183db5a" title="NUMA node. An object that contains memory that is directly and byte-accessible to the host processors...">HWLOC_OBJ_NUMANODE</a></span> and <span class="tt"><a class="el" href="group__hwlocality__object__types.html#ggacd37bb612667dc437d66bfb175a8dc55ab16ab8c0dbffc234921d86f3dfb63129" title="Physical package. The physical package that usually gets inserted into a socket on the motherboard....">HWLOC_OBJ_PACKAGE</a></span> yet, you may use:</p>
<pre class="fragment">#include &lt;hwloc.h&gt;
#if HWLOC_API_VERSION &lt; 0x00010b00
#define HWLOC_OBJ_NUMANODE HWLOC_OBJ_NODE
#define HWLOC_OBJ_PACKAGE HWLOC_OBJ_SOCKET
#endif
</pre><p>Once a program is built against a hwloc library, it may also dynamically link with compatible libraries from other hwloc releases. The version of that runtime library may be queried with <a class="el" href="group__hwlocality__api__version.html#ga9c0b50c98add1adf57ed1ce85bb5190d" title="Indicate at runtime which hwloc API version was used at build time.">hwloc_get_api_version()</a>. For instance, the following code enables the topology flag <a class="el" href="group__hwlocality__configuration.html#ggada025d3ec20b4b420f8038d23d6e7bdea5796b4909eba80f9727b66d07d3a7a05" title="Ignore distances.">HWLOC_TOPOLOGY_FLAG_NO_DISTANCES</a> when compiling on hwloc 2.8 or later, but it disables it at runtime if running on an older hwloc (otherwise <a class="el" href="group__hwlocality__configuration.html#gaaeed4df656979e5f16befea9d29b814b" title="Set OR&#39;ed flags to non-yet-loaded topology.">hwloc_topology_set_flags()</a> would fail).</p>
<pre class="fragment">unsigned long topology_flags = ...; /* wanted flags that were supported before 2.8 */
#if HWLOC_API_VERSION &gt;= 0x20800
if (hwloc_get_api_version() &gt;= 0x20800)
  topology_flags |= HWLOC_TOPOLOGY_FLAG_NO_DISTANCES; /* wanted flags only supported in 2.8+ */
#endif
hwloc_topology_set_flags(topology, topology_flags);
</pre><p>See also <a class="el" href="#faq_version_abi">How do I handle ABI breaks?</a> for using <a class="el" href="group__hwlocality__api__version.html#ga9c0b50c98add1adf57ed1ce85bb5190d" title="Indicate at runtime which hwloc API version was used at build time.">hwloc_get_api_version()</a> for testing ABI compatibility.</p>
<h2 class="doxsection"><a class="anchor" id="faq_version"></a>
What is the difference between API and library version numbers?</h2>
<p><a class="el" href="group__hwlocality__api__version.html#ga8f4dfb8eef138af55dd1a0fa802e5476" title="Indicate at build time which hwloc API version is being used.">HWLOC_API_VERSION</a> is the version of the API. It changes when functions are added, modified, etc. However it does not necessarily change from one release to another. For instance, two releases of the same series (e.g. 2.0.3 and 2.0.4) usually have the same <a class="el" href="group__hwlocality__api__version.html#ga8f4dfb8eef138af55dd1a0fa802e5476" title="Indicate at build time which hwloc API version is being used.">HWLOC_API_VERSION</a> (<span class="tt">0x00020000</span>). However their HWLOC_VERSION strings are different (<span class="tt">"2.0.3"</span> and <span class="tt">"2.0.4"</span> respectively).</p>
<h2 class="doxsection"><a class="anchor" id="faq_version_abi"></a>
How do I handle ABI breaks?</h2>
<p>The hwloc interface was deeply modified in release 2.0 to fix several issues of the 1.x interface (see <a class="el" href="upgrade_to_api_2x.html">Upgrading to the hwloc 2.0 API</a> and the NEWS file in the source directory for details). The ABI was broken, which means <b>applications must be recompiled against the new 2.0 interface</b>.</p>
<p>To check that you are not mixing old/recent headers with a recent/old runtime library, check the major revision number in the API version: </p><pre class="fragment">#include &lt;hwloc.h&gt;
  unsigned version = hwloc_get_api_version();
  if ((version &gt;&gt; 16) != (HWLOC_API_VERSION &gt;&gt; 16)) {
    fprintf(stderr,
           "%s compiled for hwloc API 0x%x but running on library API 0x%x.\n"
           "You may need to point LD_LIBRARY_PATH to the right hwloc library.\n"
           "Aborting since the new ABI is not backward compatible.\n",
           callname, HWLOC_API_VERSION, version);
    exit(EXIT_FAILURE);
  }
</pre><p> To specifically detect v2.0 issues: </p><pre class="fragment">#include &lt;hwloc.h&gt;
#if HWLOC_API_VERSION &gt;= 0x00020000
  /* headers are recent */
  if (hwloc_get_api_version() &lt; 0x20000)
    ... error out, the hwloc runtime library is older than 2.0 ...
#else
  /* headers are pre-2.0 */
  if (hwloc_get_api_version() &gt;= 0x20000)
    ... error out, the hwloc runtime library is more recent than 2.0 ...
#endif
</pre><p>In theory, library sonames prevent linking with incompatible libraries. However custom hwloc installations or improperly configured build environments may still lead to such issues. Hence running one of the above (cheap) checks before initializing hwloc topology may be useful.</p>
<h2 class="doxsection"><a class="anchor" id="faq_version_xml"></a>
Are XML topology files compatible between hwloc releases?</h2>
<p>XML topology files are forward-compatible: a XML file may be loaded by a hwloc library that is more recent than the hwloc release that exported that file.</p>
<p>However, hwloc XMLs are not always backward-compatible: Topologies exported by hwloc 2.x cannot be imported by 1.x by default (see <a class="el" href="upgrade_to_api_2x.html#upgrade_to_api_2x_xml">XML changes</a> for working around such issues). There are also some corner cases where backward compatibility is not guaranteed because of changes between major releases (for instance 1.11 XMLs could not be imported in 1.10).</p>
<p>XMLs are exchanged at runtime between some components of the HPC software stack (for instance the resource managers and MPI processes). Building all these components on the same (cluster-wide) hwloc installation is a good way to avoid such incompatibilities.</p>
<h2 class="doxsection"><a class="anchor" id="faq_version_synthetic"></a>
Are synthetic strings compatible between hwloc releases?</h2>
<p>Synthetic strings (see <a class="el" href="synthetic.html">Synthetic topologies</a>) are forward-compatible: a synthetic string generated by a release may be imported by future hwloc libraries.</p>
<p>However they are often not backward-compatible because new details may have been added to synthetic descriptions in recent releases. Some flags may be given to <a class="el" href="group__hwlocality__syntheticexport.html#ga24b7864a1c588309c4749f621f03b4c7" title="Export the topology as a synthetic string.">hwloc_topology_export_synthetic()</a> to avoid such details and stay backward compatible.</p>
<h2 class="doxsection"><a class="anchor" id="faq_version_shmem"></a>
Is it possible to share a shared-memory topology between different hwloc releases?</h2>
<p>Shared-memory topologies (see <a class="el" href="group__hwlocality__shmem.html">Sharing topologies between processes</a>) have strong requirements on compatibility between hwloc libraries. Adopting a shared-memory topology fails if it was exported by a non-compatible hwloc release. Releases with same major revision are usually compatible (e.g. hwloc 2.0.4 may adopt a topology exported by 2.0.3) but different major revisions may be incompatible (e.g. hwloc 2.1.0 cannot adopt from 2.0.x).</p>
<p>Topologies are shared at runtime between some components of the HPC software stack (for instance the resource managers and MPI processes). Building all these components on the same (system-wide) hwloc installation is a good way to avoid such incompatibilities. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
