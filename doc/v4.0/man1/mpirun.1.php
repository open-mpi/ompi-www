<?php
$topdir = "../../..";
$title = "mpirun(1) man page (version 4.0.3)";
$meta_desc = "Open MPI v4.0.3 man page: mpirun(1)";

include_once("$topdir/doc/nav.inc");
include_once("$topdir/includes/header.inc");
?>
<p> <a href="../">&laquo; Return to documentation listing</a></p>
           <!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
 orterun, mpirun, mpiexec - Execute serial and parallel
jobs in Open MPI. oshrun, shmemrun - Execute serial and parallel jobs in
Open SHMEM.
<p> <b>Note:</b> <i>mpirun</i>, <i>mpiexec</i>, and <i>orterun</i> are all synonyms for each
other as well as <i>oshrun</i>, <i>shmemrun</i> in case Open SHMEM is installed. Using
any of the names will produce the same behavior.
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>
 <p>
Single Process
Multiple Data (SPMD) Model:
<p> <b>mpirun</b> [ options ] <b>&lt;program&gt;</b> [ &lt;args&gt; ] <p>

<p> Multiple
Instruction Multiple Data (MIMD) Model:
<p> <b>mpirun</b> [ global_options ]
   [ local_options1 ]<br>
 <b>&lt;program1&gt;</b> [ &lt;args1&gt; ] :        [ local_options2 ]<br>
 <b>&lt;program2&gt;</b> [ &lt;args2&gt; ] :        ... :<br>
        [ local_optionsN ]<br>
 <b>&lt;programN&gt;</b> [ &lt;argsN&gt; ] <p>

<p> Note that in both models, invoking <i>mpirun</i> via an absolute
path name is equivalent to specifying the <i>--prefix</i> option with a <i>&lt;dir&gt;</i> value
equivalent to the directory where <i>mpirun</i> resides, minus its last subdirectory.
 For example:
<p>     <b>%</b> /usr/local/bin/mpirun ...<br>

<p> is equivalent to
<p>     <b>%</b> mpirun --prefix /usr/local<br>

<p>
<h2><a name='sect2' href='#toc2'>Quick Summary</a></h2>
 If you are simply looking for how to run an MPI application,
you probably want to use a command line of the following form:
<p>     <b>%</b> mpirun
[ -np X ] [ --hostfile &lt;filename&gt; ]  &lt;program&gt;<br>

<p> This will run X copies of <i>&lt;program&gt;</i> in your current run-time environment
(if running under a supported resource manager, Open MPI&rsquo;s <i>mpirun</i> will usually
automatically use the corresponding resource manager process starter, as
opposed to, for example, <i>rsh</i> or <i>ssh</i>, which require the use of a hostfile,
or will default to running all X copies on the localhost), scheduling (by
default) in a round-robin fashion by CPU slot.  See the rest of this page
for more details. <p>
Please note that mpirun automatically binds processes
as of the start of the v1.8 series. Three binding patterns are used in the
absence of any further directives:
<dl>

<dt><b>Bind to core:</b> </dt>
<dd>when the number of processes
is &lt;= 2   </dd>

<dt><b>Bind to socket:</b> </dt>
<dd>when the number of processes is &gt; 2   </dd>

<dt><b>Bind to none:</b>
</dt>
<dd>when oversubscribed   </dd>
</dl>
<p>
If your application uses threads, then you probably
want to ensure that you are either not bound at all (by specifying --bind-to
none), or bound to multiple cores using an appropriate binding level or
specific number of processing elements per application process.
<h2><a name='sect3' href='#toc3'>Options</a></h2>

<i>mpirun</i> will send the name of the directory where it was invoked on the
local node to each of the remote nodes, and attempt to change to that directory.
 See the "Current Working Directory" section below for further details.

<dl>

<dt><b>&lt;program&gt;</b> </dt>
<dd>The program executable. This is identified as the first non-recognized
argument to mpirun.   </dd>

<dt><b>&lt;args&gt;</b> </dt>
<dd>Pass these run-time arguments to every new process.
 These must always be the last arguments to <i>mpirun</i>. If an app context file
is used, <i>&lt;args&gt;</i> will be ignored.   </dd>

<dt><b>-h, --help</b> </dt>
<dd>Display help for this command
 </dd>

<dt><b>-q, --quiet</b> </dt>
<dd>Suppress informative messages from orterun during application
execution.   </dd>

<dt><b>-v, --verbose</b> </dt>
<dd>Be verbose   </dd>

<dt><b>-V, --version</b> </dt>
<dd>Print version number.  If
no other arguments are given, this will also cause orterun to exit.   </dd>

<dt><b>-N
&lt;num&gt;</b> </dt>
<dd><br>
Launch num processes per node on all allocated nodes (synonym for npernode).
   </dd>

<dt><b>-display-map, --display-map</b> </dt>
<dd>Display a table showing the mapped location of
each process prior to launch.    </dd>

<dt><b>-display-allocation, --display-allocation</b> </dt>
<dd>Display
the detected resource allocation.    </dd>

<dt><b>-output-proctable, --output-proctable</b> </dt>
<dd>Output
the debugger proctable after launch.    </dd>

<dt><b>-dvm, --dvm</b> </dt>
<dd>Create a persistent distributed
virtual machine (DVM).    </dd>

<dt><b>-max-vm-size, --max-vm-size &lt;size&gt;</b> </dt>
<dd>Number of processes
to run.    </dd>

<dt><b>-novm, --novm</b> </dt>
<dd>Execute without creating an allocation-spanning virtual
machine (only start daemons on nodes hosting application procs).    </dd>

<dt><b>-hnp,
--hnp &lt;arg0&gt;</b> </dt>
<dd>Specify the URI of the Head Node Process (HNP), or the name of
the file (specified as file:filename) that contains that info.    </dd>
</dl>
<p>
Use one
of the following options to specify which hosts (nodes) of the cluster
to run on. Note that as of the start of the v1.8 release, mpirun will launch
a daemon onto each host in the allocation (as modified by the following
options) at the very beginning of execution, regardless of whether or not
application processes will eventually be mapped to execute there. This is
done to allow collection of hardware topology information from the remote
nodes, thus allowing us to map processes against known topology. However,
it is a change from the behavior in prior releases where daemons were only
launched after mapping was complete, and thus only occurred on nodes where
application processes would actually be executing.
<dl>

<dt><b>-H, -host, --host &lt;host1,host2,...,hostN&gt;</b>
</dt>
<dd>List of hosts on which to invoke processes.   </dd>

<dt><b>-hostfile, --hostfile &lt;hostfile&gt;</b>
</dt>
<dd>Provide a hostfile to use.    </dd>

<dt><b>-default-hostfile, --default-hostfile &lt;hostfile&gt;</b>
</dt>
<dd>Provide a default hostfile.   </dd>

<dt><b>-machinefile, --machinefile &lt;machinefile&gt;</b> </dt>
<dd>Synonym
for <i>-hostfile</i>.     </dd>

<dt><b>-cpu-set, --cpu-set &lt;list&gt;</b> </dt>
<dd>Restrict launched processes to the
specified logical cpus on each node (comma-separated list). Note that the
binding options will still apply within the specified envelope - e.g., you
can elect to bind each process to only one cpu within the specified cpu
set.    </dd>
</dl>
<p>
The following options specify the number of processes to launch.
Note that none of the options imply a particular binding policy - e.g., requesting
N processes for each socket does not imply that the processes will be bound
to the socket.
<dl>

<dt><b>-c, -n, --n, -np &lt;#&gt;</b> </dt>
<dd>Run this many copies of the program on the
given nodes.  This option indicates that the specified file is an executable
program and not an application context. If no value is provided for the
number of copies to execute (i.e., neither the "-np" nor its synonyms are
provided on the command line), Open MPI will automatically execute a copy
of the program on each process slot (see below for description of a "process
slot"). This feature, however, can only be used in the SPMD model and will
return an error (without beginning execution of the application) otherwise.
  </li><b>-&lt;&gt;</b><li>Launch N times the number of objects of the specified type on each node.
  </dd>

<dt><b>-npersocket, --npersocket &lt;#persocket&gt;</b> </dt>
<dd>On each node, launch this many processes
times the number of processor sockets on the node. The <i>-npersocket</i> option
also turns on the <i>-bind-to-socket</i> option. (deprecated in favor of --map-by ppr:n:socket)
  </dd>

<dt><b>-npernode, --npernode &lt;#pernode&gt;</b> </dt>
<dd>On each node, launch this many processes.
(deprecated in favor of --map-by ppr:n:node)   </dd>

<dt><b>-pernode, --pernode</b> </dt>
<dd>On each node,
launch one process -- equivalent to <i>-npernode</i> 1. (deprecated in favor of --map-by
ppr:1:node)     </dd>
</dl>
<p>
To map processes:
<dl>

<dt><b>--map-by &lt;foo&gt;</b> </dt>
<dd>Map to the specified object,
defaults to <i>socket</i>. Supported options include slot, hwthread, core, L1cache,
L2cache, L3cache, socket, numa, board, node, sequential, distance, and
ppr. Any object can include modifiers by adding a : and any combination
of PE=n (bind n processing elements to each proc), SPAN (load balance the
processes across the allocation), OVERSUBSCRIBE (allow more processes on
a node than processing elements), and NOOVERSUBSCRIBE. This includes PPR,
where the pattern would be terminated by another colon to separate it from
the modifiers.  </dd>

<dt><b>-bycore, --bycore</b> </dt>
<dd>Map processes by core (deprecated in favor
of --map-by core)  </dd>

<dt><b>-byslot, --byslot</b> </dt>
<dd>Map and rank processes round-robin by slot.
 </dd>

<dt><b>-nolocal, --nolocal</b> </dt>
<dd>Do not run any copies of the launched application on
the same node as orterun is running.  This option will override listing
the localhost with <b>--host</b> or any other host-specifying mechanism.  </dd>

<dt><b>-nooversubscribe,
--nooversubscribe</b> </dt>
<dd>Do not oversubscribe any nodes; error (without starting
any processes) if the requested number of processes would cause oversubscription.
This option implicitly sets "max_slots" equal to the "slots" value for
each node. (Enabled by default).  </dd>

<dt><b>-oversubscribe, --oversubscribe</b> </dt>
<dd>Nodes are
allowed to be oversubscribed, even on a managed system, and overloading
of processing elements.  </dd>

<dt><b>-bynode, --bynode</b> </dt>
<dd>Launch processes one per node, cycling
by node in a round-robin fashion.  This spreads processes evenly among nodes
and assigns MPI_COMM_WORLD ranks in a round-robin, "by node" manner.  </dd>

<dt><b>-cpu-list,
--cpu-list &lt;cpus&gt;</b> </dt>
<dd>Comma-delimited list of processor IDs to which to bind processes
[default=NULL].  Processor IDs are interpreted as hwloc logical core IDs.
 Run the hwloc <i><i>lstopo(1)</i></i> command to see a list of available cores and their
logical IDs.     </dd>
</dl>
<p>
To order processes&rsquo; ranks in MPI_COMM_WORLD:
<dl>

<dt><b>--rank-by &lt;foo&gt;</b>
</dt>
<dd>Rank in round-robin fashion according to the specified object, defaults
to <i>slot</i>. Supported options include slot, hwthread, core, L1cache, L2cache,
L3cache, socket, numa, board, and node.     </dd>
</dl>
<p>
For process binding:
<dl>

<dt><b>--bind-to
&lt;foo&gt;</b> </dt>
<dd>Bind processes to the specified object, defaults to <i>core</i>. Supported
options include slot, hwthread, core, l1cache, l2cache, l3cache, socket,
numa, board, cpu-list, and none.  </dd>

<dt><b>-cpus-per-proc, --cpus-per-proc &lt;#perproc&gt;</b> </dt>
<dd>Bind
each process to the specified number of cpus. (deprecated in favor of --map-by
&lt;obj&gt;:PE=n)  </dd>

<dt><b>-cpus-per-rank, --cpus-per-rank &lt;#perrank&gt;</b> </dt>
<dd>Alias for <i>-cpus-per-proc</i>. (deprecated
in favor of --map-by &lt;obj&gt;:PE=n)  </dd>

<dt><b>-bind-to-core, --bind-to-core</b> </dt>
<dd>Bind processes to cores
(deprecated in favor of --bind-to core)  </dd>

<dt><b>-bind-to-socket, --bind-to-socket</b> </dt>
<dd>Bind processes
to processor sockets  (deprecated in favor of --bind-to socket)  </dd>

<dt><b>-report-bindings,
--report-bindings</b> </dt>
<dd>Report any bindings for launched processes.     </dd>
</dl>
<p>
For rankfiles:

<dl>

<dt><b>-rf, --rankfile &lt;rankfile&gt;</b> </dt>
<dd>Provide a rankfile file.     </dd>
</dl>
<p>
To manage standard
I/O:
<dl>

<dt><b>-output-filename, --output-filename &lt;filename&gt;</b> </dt>
<dd>Redirect the stdout, stderr,
and stddiag of all processes to a process-unique version of the specified
filename. Any directories in the filename will automatically be created.
Each output file will consist of filename.id, where the id will be the processes&rsquo;
rank in MPI_COMM_WORLD, left-filled with zero&rsquo;s for correct ordering in listings.
A relative path value will be converted to an absolute path based on the
cwd where mpirun is executed. Note that this <i>will not</i> work on environments
where the file system on compute nodes differs from that where mpirun is
executed.   </dd>

<dt><b>-stdin, --stdin &lt;rank&gt; </b> </dt>
<dd>The MPI_COMM_WORLD rank of the process that
is to receive stdin. The default is to forward stdin to MPI_COMM_WORLD rank
0, but this option can be used to forward stdin to any process. It is also
acceptable to specify <i>none</i>, indicating that no processes are to receive
stdin.   </dd>

<dt><b>-merge-stderr-to-stdout, --merge-stderr-to-stdout</b> </dt>
<dd>Merge stderr to stdout
for each process.   </dd>

<dt><b>-tag-output, --tag-output</b> </dt>
<dd>Tag each line of output to stdout,
stderr, and stddiag with <b>[jobid, MCW_rank]&lt;stdxxx&gt;</b> indicating the process
jobid and MPI_COMM_WORLD rank of the process that generated the output,
and the channel which generated it.   </dd>

<dt><b>-timestamp-output, --timestamp-output</b> </dt>
<dd>Timestamp
each line of output to stdout, stderr, and stddiag.   </dd>

<dt><b>-xml, --xml</b> </dt>
<dd>Provide all
output to stdout, stderr, and stddiag in an xml format.   </dd>

<dt><b>-xml-file, --xml-file
&lt;filename&gt;</b> </dt>
<dd>Provide all output in XML format to the specified file.   </dd>

<dt><b>-xterm,
--xterm &lt;ranks&gt;</b> </dt>
<dd>Display the output from the processes identified by their MPI_COMM_WORLD
ranks in separate xterm windows. The ranks are specified as a comma-separated
list of ranges, with a -1 indicating all. A separate window will be created
for each specified process. <b>Note:</b> xterm will normally terminate the window
upon termination of the process running within it. However, by adding a
"!" to the end of the list of specified ranks, the proper options will
be provided to ensure that xterm keeps the window open <i>after</i> the process
terminates, thus allowing you to see the process&rsquo; output. Each xterm window
will subsequently need to be manually closed. <b>Note:</b> In some environments,
xterm may require that the executable be in the user&rsquo;s path, or be specified
in absolute or relative terms. Thus, it may be necessary to specify a local
executable as "./foo" instead of just "foo". If xterm fails to find the executable,
mpirun will hang, but still respond correctly to a ctrl-c. If this happens,
please check that the executable is being specified correctly and try again.
    </dd>
</dl>
<p>
To manage files and runtime environment:
<dl>

<dt><b>-path, --path &lt;path&gt;</b> </dt>
<dd>&lt;path&gt; that
will be used when attempting to locate the requested executables.  This
is used prior to using the local PATH setting.   </dd>

<dt><b>--prefix &lt;dir&gt;</b> </dt>
<dd>Prefix directory
that will be used to set the <i>PATH</i> and <i>LD_LIBRARY_PATH</i> on the remote node
before invoking Open MPI or the target process.  See the "Remote Execution"
section, below.   </dd>

<dt><b>--noprefix</b> </dt>
<dd>Disable the automatic --prefix behavior   </dd>

<dt><b>-s, --preload-binary</b>
</dt>
<dd>Copy the specified executable(s) to remote machines prior to starting remote
processes. The executables will be copied to the Open MPI session directory
and will be deleted upon completion of the job.   </dd>

<dt><b>--preload-files &lt;files&gt;</b> </dt>
<dd>Preload
the comma separated list of files to the current working directory of the
remote machines where processes will be launched prior to starting those
processes.   </dd>

<dt><b>-set-cwd-to-session-dir, --set-cwd-to-session-dir</b> </dt>
<dd>Set the working directory
of the started processes to their session directory.   </dd>

<dt><b>-wd &lt;dir&gt;</b> </dt>
<dd>Synonym for
<i>-wdir</i>.   </dd>

<dt><b>-wdir &lt;dir&gt;</b> </dt>
<dd>Change to the directory &lt;dir&gt; before the user&rsquo;s program executes.
See the "Current Working Directory" section for notes on relative paths.
<b>Note:</b> If the <i>-wdir</i> option appears both on the command line and in an application
context, the context will take precedence over the command line. Thus, if
the path to the desired wdir is different on the backend nodes, then it
must be specified as an absolute path that is correct for the backend node.
  </dd>

<dt><b>-x &lt;env&gt;</b> </dt>
<dd>Export the specified environment variables to the remote nodes
before executing the program.  Only one environment variable can be specified
per <i>-x</i> option.  Existing environment variables can be specified or new variable
names specified with corresponding values.  For example:     <b>%</b> mpirun -x
DISPLAY -x OFILE=/tmp/out ...<br>

<p> The parser for the <i>-x</i> option is not very sophisticated; it does not even
understand quoted values.  Users are advised to set variables in the environment,
and then use <i>-x</i> to export (not define) them.     </dd>
</dl>
<p>
Setting MCA parameters:

<dl>

<dt><b>-gmca, --gmca &lt;key&gt; &lt;value&gt;</b> </dt>
<dd>Pass global MCA parameters that are applicable to
all contexts. <i>&lt;key&gt;</i> is the parameter name; <i>&lt;value&gt;</i> is the parameter value.
</dd>

<dt><b>-mca, --mca &lt;key&gt; &lt;value&gt;</b> </dt>
<dd>Send arguments to various MCA modules.  See the "MCA"
section, below.   </dd>

<dt><b>-am &lt;arg0&gt;</b> </dt>
<dd>Aggregate MCA parameter set file list.   </dd>

<dt><b>-tune,
--tune &lt;tune_file&gt;</b> </dt>
<dd>Specify a tune file to set arguments for various MCA modules
and environment variables. See the "Setting MCA parameters and environment
variables from file" section, below.     </dd>
</dl>
<p>
For debugging:
<dl>

<dt><b>-debug, --debug</b> </dt>
<dd>Invoke
the user-level debugger indicated by the <i>orte_base_user_debugger</i> MCA parameter.
  </dd>

<dt><b>--get-stack-traces</b> </dt>
<dd>When paired with the <b>--timeout</b> option, <i>mpirun</i> will obtain
and print out stack traces from all launched processes that are still alive
when the timeout expires.  Note that obtaining stack traces can take a little
time and produce a lot of output, especially for large process-count jobs.
  </dd>

<dt><b>-debugger, --debugger &lt;args&gt;</b> </dt>
<dd>Sequence of debuggers to search for when <i>--debug</i>
is used (i.e. a synonym for <i>orte_base_user_debugger</i> MCA parameter).   </dd>

<dt><b>--timeout
&lt;seconds&gt;</b> </dt>
<dd>The maximum number of seconds that <i>mpirun</i> (also known as <i>mpiexec,<i></i>
oshrun</i>,<i> orterun</i>,<i> etc.) will run.  After this many seconds, <i>mpirun</i> will abort
the launched job and exit with a non-zero exit status. Using <b>--timeout</b> can
be also useful when combined with the <b>--get-stack-traces</b> option.   </dd>

<dt><b>-tv</i>, --tv</b> </dt>
<dd>Launch
processes under the TotalView debugger. Deprecated backwards compatibility
flag. Synonym for <i>--debug</i>.     </dd>
</dl>
<p>
There are also other options:
<dl>

<dt><b>--allow-run-as-root</b>
</dt>
<dd>Allow <i>mpirun</i> to run when executed by the root user (<i>mpirun</i> defaults to
aborting when launched as the root user).  Be sure to see the <i>Running</i> as
root section, below, for more detail.   </dd>

<dt><b>--app &lt;appfile&gt;</b> </dt>
<dd>Provide an appfile,
ignoring all other command line options.   </dd>

<dt><b>-cf, --cartofile &lt;cartofile&gt;</b> </dt>
<dd>Provide
a cartography file.   </dd>

<dt><b>-continuous, --continuous</b> </dt>
<dd>Job is to run until explicitly
terminated.   </dd>

<dt><b>-disable-recovery, --disable-recovery</b> </dt>
<dd>Disable recovery (resets
all recovery options to off).   </dd>

<dt><b>-do-not-launch, --do-not-launch</b> </dt>
<dd>Perform all necessary
operations to prepare to launch the application, but do not actually launch
it.   </dd>

<dt><b>-do-not-resolve, --do-not-resolve</b> </dt>
<dd>Do not attempt to resolve interfaces.
</dd>

<dt><b>-enable-recovery, --enable-recovery</b> </dt>
<dd>Enable recovery from process failure [Default
= disabled].   </dd>

<dt><b>-index-argv-by-rank, --index-argv-by-rank</b> </dt>
<dd>Uniquely index argv[0] for
each process using its rank.   </dd>

<dt><b>-leave-session-attached, --leave-session-attached</b>
</dt>
<dd>Do not detach OmpiRTE daemons used by this application. This allows error
messages from the daemons as well as the underlying environment (e.g., when
failing to launch a daemon) to be output.   </dd>

<dt><b>-max-restarts, --max-restarts &lt;num&gt;</b>
</dt>
<dd>Max number of times to restart a failed process.   </dd>

<dt><b>-ompi-server, --ompi-server
&lt;uri or file&gt;</b> </dt>
<dd>Specify the URI of the Open MPI server (or the mpirun to be
used as the server), the name of the file (specified as file:filename)
that contains that info, or the PID (specified as pid:#) of the mpirun
to be used as the server. The Open MPI server is used to support multi-application
data exchange via the MPI-2 <a href="../man3/MPI_Publish_name.3.php">MPI_Publish_name</a> and <a href="../man3/MPI_Lookup_name.3.php">MPI_Lookup_name</a> functions.
  </dd>

<dt><b>-personality, --personality &lt;list&gt;</b> </dt>
<dd>Comma-separated list of programming model,
languages, and containers being used (default="ompi").   </dd>

<dt><b>--ppr &lt;list&gt;</b> </dt>
<dd>Comma-separated
list of number of processes on a given resource type [default: none].
</dd>

<dt><b>-report-child-jobs-separately, --report-child-jobs-separately</b> </dt>
<dd>Return the exit status
of the primary job only.   </dd>

<dt><b>-report-events, --report-events &lt;URI&gt;</b> </dt>
<dd>Report events
to a tool listening at the specified URI.   </dd>

<dt><b>-report-pid, --report-pid &lt;channel&gt;</b>
</dt>
<dd>Print out mpirun&rsquo;s PID during startup. The channel must be either a &rsquo;-&rsquo; to indicate
that the pid is to be output to stdout, a &rsquo;+&rsquo; to indicate that the pid is
to be output to stderr, or a filename to which the pid is to be written.
  </dd>

<dt><b>-report-uri, --report-uri &lt;channel&gt;</b> </dt>
<dd>Print out mpirun&rsquo;s URI during startup. The
channel must be either a &rsquo;-&rsquo; to indicate that the URI is to be output to stdout,
a &rsquo;+&rsquo; to indicate that the URI is to be output to stderr, or a filename to
which the URI is to be written.   </dd>

<dt><b>-show-progress, --show-progress</b> </dt>
<dd>Output a brief
periodic report on launch progress.   </dd>

<dt><b>-terminate, --terminate</b> </dt>
<dd>Terminate the
DVM.   </dd>

<dt><b>-use-hwthread-cpus, --use-hwthread-cpus</b> </dt>
<dd>Use hardware threads as independent
cpus.   </dd>

<dt><b>-use-regexp, --use-regexp</b> </dt>
<dd>Use regular expressions for launch.     </dd>
</dl>
<p>
The
following options are useful for developers; they are not generally useful
to most ORTE and/or MPI users:
<dl>

<dt><b>-d, --debug-devel</b> </dt>
<dd>Enable debugging of the OmpiRTE
(the run-time layer in Open MPI). This is not generally useful for most users.
  </dd>

<dt><b>--debug-daemons</b> </dt>
<dd>Enable debugging of any OmpiRTE daemons used by this application.
  </dd>

<dt><b>--debug-daemons-file</b> </dt>
<dd>Enable debugging of any OmpiRTE daemons used by this
application, storing output in files.   </dd>

<dt><b>-display-devel-allocation, --display-devel-allocation</b>
</dt>
<dd>Display a detailed list of the allocation being used by this job.   </dd>

<dt><b>-display-devel-map,
--display-devel-map</b> </dt>
<dd>Display a more detailed table showing the mapped location
of each process prior to launch.   </dd>

<dt><b>-display-diffable-map, --display-diffable-map</b>
</dt>
<dd>Display a diffable process map just before launch.   </dd>

<dt><b>-display-topo, --display-topo</b>
</dt>
<dd>Display the topology as part of the process map just before launch.   </dd>

<dt><b>-launch-agent,
--launch-agent</b> </dt>
<dd>Name of the executable that is to be used to start processes
on the remote nodes. The default is "orted". This option can be used to test
new daemon concepts, or to pass options back to the daemons without having
mpirun itself see them. For example, specifying a launch agent of orted
-mca odls_base_verbose 5 allows the developer to ask the orted for debugging
output without clutter from mpirun itself.   </dd>

<dt><b>--report-state-on-timeout</b> </dt>
<dd>When paired
with the <b>--timeout</b> command line option, report the run-time subsystem state
of each process when the timeout expires.   </dd>
</dl>
<p>
There may be other options listed
with <i>mpirun --help</i>.
<h3><a name='sect4' href='#toc4'>Environment Variables</a></h3>

<dl>

<dt><b>MPIEXEC_TIMEOUT</b> </dt>
<dd>Synonym for the
<b>--timeout</b> command line option.      </dd>
</dl>

<h2><a name='sect5' href='#toc5'>Description</a></h2>
 One invocation of <i>mpirun</i> starts
an MPI application running under Open MPI. If the application is single
process multiple data (SPMD), the application can be specified on the <i>mpirun</i>
command line.
<p> If the application is multiple instruction multiple data
(MIMD), comprising of multiple programs, the set of programs and argument
can be specified in one of two ways: Extended Command Line Arguments, and
Application Context. <p>
An application context describes the MIMD program set
including all arguments in a separate file.  This file essentially contains
multiple <i>mpirun</i> command lines, less the command name itself.  The ability
to specify different options for different instantiations of a program
is another reason to use an application context. <p>
Extended command line arguments
allow for the description of the application layout on the command line
using colons (<i>:</i>) to separate the specification of programs and arguments.
Some options are globally set across all specified programs (e.g. --hostfile),
while others are specific to a single program (e.g. -np).
<h3><a name='sect6' href='#toc6'>Specifying Host
Nodes</a></h3>
 Host nodes can be identified on the <i>mpirun</i> command line with the
<i>-host</i> option or in a hostfile.  <p>
For example,
<dl>

<dt>mpirun -H aa,aa,bb ./a.out </dt>
<dd>launches
two processes on node aa and one on bb.  </dd>
</dl>
<p>
Or, consider the hostfile
<p>
<b>%</b> cat myhostfile<br>
    aa slots=2<br>
    bb slots=2<br>
    cc slots=2<br>

<p>  <p>
Here, we list both the host names (aa, bb, and cc) but also how many
"slots" there are for each.  Slots indicate how many processes can potentially
execute on a node.  For best performance, the number of slots may be chosen
to be the number of cores on the node or the number of processor sockets.
 If the hostfile does not provide slots information, Open MPI will attempt
to discover the number of cores (or hwthreads, if the use-hwthreads-as-cpus
option is set) and set the number of slots to that value. This default behavior
also occurs when specifying the <i>-host</i> option with a single hostname. Thus,
the command
<dl>

<dt>mpirun -H aa ./a.out </dt>
<dd>launches a number of processes equal to
the number of cores on node aa.  </dd>
</dl>
<p>

<dl>

<dt>mpirun -hostfile myhostfile ./a.out </dt>
<dd>will
launch two processes on each of the three nodes.  </dd>

<dt>mpirun -hostfile myhostfile
-host aa ./a.out </dt>
<dd>will launch two processes, both on node aa.  </dd>

<dt>mpirun -hostfile
myhostfile -host dd ./a.out </dt>
<dd>will find no hosts to run on and abort with an
error. That is, the specified host dd is not in the specified hostfile.
</dd>
</dl>
<p>
When running under resource managers (e.g., SLURM, Torque, etc.), Open MPI
will obtain both the hostnames and the number of slots directly from the
resource manger.
<h3><a name='sect7' href='#toc7'>Specifying Number of Processes</a></h3>
 As we have just seen, the
number of processes to run can be set using the hostfile.  Other mechanisms
exist.  <p>
The number of processes launched can be specified as a multiple
of the number of nodes or processor sockets available.  For example,
<dl>

<dt>mpirun
-H aa,bb -npersocket 2 ./a.out </dt>
<dd>launches processes 0-3 on node aa and process
4-7 on node bb, where aa and bb are both dual-socket nodes. The <i>-npersocket</i>
option also turns on the <i>-bind-to-socket</i> option, which is discussed in a later
section.  </dd>

<dt>mpirun -H aa,bb -npernode 2 ./a.out </dt>
<dd>launches processes 0-1 on node
aa and processes 2-3 on node bb.  </dd>

<dt>mpirun -H aa,bb -npernode 1 ./a.out </dt>
<dd>launches
one process per host node.  </dd>

<dt>mpirun -H aa,bb -pernode ./a.out </dt>
<dd>is the same as
<i>-npernode</i> 1.   </dd>
</dl>
<p>
Another alternative is to specify the number of processes
with the <i>-np</i> option.  Consider now the hostfile
<p>    <b>%</b> cat myhostfile<br>
    aa slots=4<br>
    bb slots=4<br>
    cc slots=4<br>

<p>  <p>
Now,
<dl>

<dt>mpirun -hostfile myhostfile -np 6 ./a.out </dt>
<dd>will launch processes 0-3
on node aa and processes 4-5 on node bb.  The remaining slots in the hostfile
will not be used since the <i>-np</i> option indicated that only 6 processes should
be launched.  </dd>
</dl>

<h3><a name='sect8' href='#toc8'>Mapping Processes to Nodes:  Using Policies</a></h3>
 The examples above
illustrate the default mapping of process processes to nodes.  This mapping
can also be controlled with various <i>mpirun</i> options that describe mapping
policies.   <p>
Consider the same hostfile as above, again with <i>-np</i> 6:
<p>
                      node aa      node bb      node cc<br>

<p>   mpirun                  0 1 2 3      4 5<br>

<p>   mpirun --map-by node    0 3          1 4          2 5<br>

<p>   mpirun -nolocal                      0 1 2 3      4 5<br>
  <p>
The <i>--map-by node</i> option will load balance the processes across the available
nodes, numbering each process in a round-robin fashion.  <p>
The <i>-nolocal</i> option
prevents any processes from being mapped onto the local host (in this case
node aa).  While <i>mpirun</i> typically consumes few system resources, <i>-nolocal</i>
can be helpful for launching very large jobs where <i>mpirun</i> may actually
need to use noticeable amounts of memory and/or processing time.  <p>
Just as
<i>-np</i> can specify fewer processes than there are slots, it can also oversubscribe
the slots.  For example, with the same hostfile:
<dl>

<dt>mpirun -hostfile myhostfile
-np 14 ./a.out </dt>
<dd>will launch processes 0-3 on node aa, 4-7 on bb, and 8-11 on cc.
 It will then add the remaining two processes to whichever nodes it chooses.
 </dd>
</dl>
<p>
One can also specify limits to oversubscription.  For example, with the
same hostfile:
<dl>

<dt>mpirun -hostfile myhostfile -np 14 -nooversubscribe ./a.out
</dt>
<dd>will produce an error since <i>-nooversubscribe</i> prevents oversubscription.
</dd>
</dl>
<p>
Limits to oversubscription can also be specified in the hostfile itself:
  % cat myhostfile<br>
  aa slots=4 max_slots=4<br>
  bb         max_slots=4<br>
  cc slots=4<br>
  <p>
The <i>max_slots</i> field specifies such a limit.  When it does, the <i>slots</i> value
defaults to the limit.  Now:
<dl>

<dt>mpirun -hostfile myhostfile -np 14 ./a.out </dt>
<dd>causes
the first 12 processes to be launched as before, but the remaining two
processes will be forced onto node cc.  The other two nodes are protected
by the hostfile against oversubscription by this job.  </dd>
</dl>
<p>
Using the <i>--nooversubscribe</i>
option can be helpful since Open MPI currently does not get "max_slots"
values from the resource manager.  <p>
Of course, <i>-np</i> can also be used with the
<i>-H</i> or <i>-host</i> option.  For example,
<dl>

<dt>mpirun -H aa,bb -np 8 ./a.out </dt>
<dd>launches 8 processes.
 Since only two hosts are specified, after the first two processes are
mapped, one to aa and one to bb, the remaining processes oversubscribe
the specified hosts.  </dd>
</dl>
<p>
And here is a MIMD example:
<dl>

<dt>mpirun -H aa -np 1 hostname
: -H bb,cc -np 2 uptime </dt>
<dd>will launch process 0 running <i>hostname</i> on node aa
and processes 1 and 2 each running <i>uptime</i> on nodes bb and cc, respectively.
 </dd>
</dl>

<h3><a name='sect9' href='#toc9'>Mapping, Ranking, and Binding: Oh My!</a></h3>
 Open MPI employs a three-phase procedure
for assigning process locations and ranks:
<dl>

<dt><b>mapping</b> </dt>
<dd>Assigns a default location
to each process  </dd>

<dt><b>ranking</b> </dt>
<dd>Assigns an MPI_COMM_WORLD rank value to each process
 </dd>

<dt><b>binding</b> </dt>
<dd>Constrains each process to run on specific processors  </dd>
</dl>
<p>
The <i>mapping</i>
step is used to assign a default location to each process based on the
mapper being employed. Mapping by slot, node, and sequentially results in
the assignment of the processes to the node level. In contrast, mapping
by object, allows the mapper to assign the process to an actual object
on each node.  <p>
<b>Note:</b> the location assigned to the process is independent
of where it will be bound - the assignment is used solely as input to the
binding algorithm.  <p>
The mapping of process processes to nodes can be defined
not just with general policies but also, if necessary, using arbitrary
mappings that cannot be described by a simple policy.  One can use the "sequential
mapper," which reads the hostfile line by line, assigning processes to
nodes in whatever order the hostfile specifies.  Use the <i>-mca rmaps seq</i> option.
 For example, using the same hostfile as before:  <p>
mpirun -hostfile myhostfile
-mca rmaps seq ./a.out  <p>
will launch three processes, one on each of nodes
aa, bb, and cc, respectively. The slot counts don&rsquo;t matter;  one process
is launched per line on whatever node is listed on the line.  <p>
Another way
to specify arbitrary mappings is with a rankfile, which gives you detailed
control over process binding as well.  Rankfiles are discussed below.  <p>
The
second phase focuses on the <i>ranking</i> of the process within the job&rsquo;s MPI_COMM_WORLD.
 Open MPI separates this from the mapping procedure to allow more flexibility
in the relative placement of MPI processes. This is best illustrated by
considering the following two cases where we used the —map-by ppr:2:socket
option:  <p>
                          node aa       node bb<br>

<p>     rank-by core         0 1 ! 2 3     4 5 ! 6 7<br>

<p>    rank-by socket        0 2 ! 1 3     4 6 ! 5 7<br>

<p>    rank-by socket:span   0 4 ! 1 5     2 6 ! 3 7<br>
  <p>
Ranking by core and by slot provide the identical result - a simple progression
of MPI_COMM_WORLD ranks across each node. Ranking by socket does a round-robin
ranking within each node until all processes have been assigned an MCW
rank, and then progresses to the next node. Adding the <i>span</i> modifier to
the ranking directive causes the ranking algorithm to treat the entire
allocation as a single entity - thus, the MCW ranks are assigned across
all sockets before circling back around to the beginning.  <p>
The <i>binding</i> phase
actually binds each process to a given set of processors. This can improve
performance if the operating system is placing processes suboptimally.
For example, it might oversubscribe some multi-core processor sockets, leaving
other sockets idle;  this can lead processes to contend unnecessarily for
common resources.  Or, it might spread processes out too widely;  this can
be suboptimal if application performance is sensitive to interprocess communication
costs.  Binding can also keep the operating system from migrating processes
excessively, regardless of how optimally those processes were placed to
begin with.  <p>
The processors to be used for binding can be identified in
terms of topological groupings - e.g., binding to an l3cache will bind each
process to all processors within the scope of a single L3 cache within
their assigned location. Thus, if a process is assigned by the mapper to
a certain socket, then a <i>—bind-to l3cache</i> directive will cause the process
to be bound to the processors that share a single L3 cache within that
socket.  <p>
Alternatively, processes can be assigned to processors based on
their local rank on a node using the <i>--bind-to cpu-list:ordered</i> option with
an associated <i>--cpu-list "0,2,5"</i>. In this example, the first process on a node
will be bound to cpu 0, the second process on the node will be bound to
cpu 2, and the third process on the node will be bound to cpu 5. <i>--bind-to</i>
will also accept <i>cpulist:ortered</i> as a synonym to <i>cpu-list:ordered</i>.  Note
that an error will result if more processes are assigned to a node than
cpus are provided.  <p>
To help balance loads, the binding directive uses a
round-robin method when binding to levels lower than used in the mapper.
For example, consider the case where a job is mapped to the socket level,
and then bound to core. Each socket will have multiple cores, so if multiple
processes are mapped to a given socket, the binding algorithm will assign
each process located to a socket to a unique core in a round-robin manner.
 <p>
Alternatively, processes mapped by l2cache and then bound to socket will
simply be bound to all the processors in the socket where they are located.
In this manner, users can exert detailed control over relative MCW rank
location and binding.  <p>
Finally, <i>--report-bindings</i> can be used to report bindings.
 <p>
As an example, consider a node with two processor sockets, each comprising
four cores.  We run <i>mpirun</i> with <i>-np 4 --report-bindings</i> and the following additional
options:
<p>  % mpirun ... --map-by core --bind-to core<br>
  [...] ... binding child [...,0] to cpus 0001<br>
  [...] ... binding child [...,1] to cpus 0002<br>
  [...] ... binding child [...,2] to cpus 0004<br>
  [...] ... binding child [...,3] to cpus 0008<br>

<p>  % mpirun ... --map-by socket --bind-to socket<br>
  [...] ... binding child [...,0] to socket 0 cpus 000f<br>
  [...] ... binding child [...,1] to socket 1 cpus 00f0<br>
  [...] ... binding child [...,2] to socket 0 cpus 000f<br>
  [...] ... binding child [...,3] to socket 1 cpus 00f0<br>

<p>  % mpirun ... --map-by core:PE=2 --bind-to core<br>
  [...] ... binding child [...,0] to cpus 0003<br>
  [...] ... binding child [...,1] to cpus 000c<br>
  [...] ... binding child [...,2] to cpus 0030<br>
  [...] ... binding child [...,3] to cpus 00c0<br>

<p>  % mpirun ... --bind-to none<br>
  <p>
Here, <i>--report-bindings</i> shows the binding of each process as a mask. In the
first case, the processes bind to successive cores as indicated by the
masks 0001, 0002, 0004, and 0008.  In the second case, processes bind to
all cores on successive sockets as indicated by the masks 000f and 00f0.
The processes cycle through the processor sockets in a round-robin fashion
as many times as are needed.  In the third case, the masks show us that
2 cores have been bound per process.  In the fourth case, binding is turned
off and no bindings are reported.  <p>
Open MPI&rsquo;s support for process binding
depends on the underlying operating system.  Therefore, certain process
binding options may not be available on every system.  <p>
Process binding can
also be set with MCA parameters. Their usage is less convenient than that
of <i>mpirun</i> options. On the other hand, MCA parameters can be set not only
on the <i>mpirun</i> command line, but alternatively in a system or user mca-params.conf
file or as environment variables, as described in the MCA section below.
Some examples include:  <p>
    mpirun option          MCA parameter key
      value<br>

<p>   --map-by core          rmaps_base_mapping_policy   core<br>
   --map-by socket        rmaps_base_mapping_policy   socket<br>
   --rank-by core         rmaps_base_ranking_policy   core<br>
   --bind-to core         hwloc_base_binding_policy   core<br>
   --bind-to socket       hwloc_base_binding_policy   socket<br>
   --bind-to none         hwloc_base_binding_policy   none<br>

<h3><a name='sect10' href='#toc10'>Rankfiles</a></h3>
 Rankfiles are text files that specify detailed information
about how individual processes should be mapped to nodes, and to which
processor(s) they should be bound.  Each line of a rankfile specifies the
location of one process (for MPI jobs, the process&rsquo; "rank" refers to its
rank in MPI_COMM_WORLD).  The general form of each line in the rankfile
is:
<p>     rank &lt;N&gt;=&lt;hostname&gt; slot=&lt;slot list&gt;<br>
  <p>
For example:
<p>     $ cat myrankfile<br>
     rank 0=aa slot=1:0-2<br>
     rank 1=bb slot=0:0,1<br>
     rank 2=cc slot=1-2<br>
     $ mpirun -H aa,bb,cc,dd -rf myrankfile ./a.out<br>
  <p>
Means that
<p>   Rank 0 runs on node aa, bound to logical socket 1, cores
0-2.<br>
   Rank 1 runs on node bb, bound to logical socket 0, cores 0 and 1.<br>
   Rank 2 runs on node cc, bound to logical cores 1 and 2.<br>
  <p>
Rankfiles can alternatively be used to specify <i>physical</i> processor locations.
In this case, the syntax is somewhat different. Sockets are no longer recognized,
and the slot number given must be the number of the physical PU as most
OS&rsquo;s do not assign a unique physical identifier to each core in the node.
Thus, a proper physical rankfile looks something like the following:
<p>
    $ cat myphysicalrankfile<br>
     rank 0=aa slot=1<br>
     rank 1=bb slot=8<br>
     rank 2=cc slot=6<br>
  <p>
This means that
<p>   Rank 0 will run on node aa, bound to the core that
contains physical PU 1<br>
   Rank 1 will run on node bb, bound to the core that contains physical
PU 8<br>
   Rank 2 will run on node cc, bound to the core that contains physical
PU 6<br>
  <p>
Rankfiles are treated as <i>logical</i> by default, and the MCA parameter rmaps_rank_file_physical
must be set to 1 to indicate that the rankfile is to be considered as <i>physical</i>.
 <p>
The hostnames listed above are "absolute," meaning that actual resolveable
hostnames are specified.  However, hostnames can also be specified as "relative,"
meaning that they are specified in relation to an externally-specified list
of hostnames (e.g., by mpirun&rsquo;s --host argument, a hostfile, or a job scheduler).
 <p>
The "relative" specification is of the form "+n&lt;X&gt;", where X is an integer
specifying the Xth hostname in the set of all available hostnames, indexed
from 0.  For example:
<p>     $ cat myrankfile<br>
     rank 0=+n0 slot=1:0-2<br>
     rank 1=+n1 slot=0:0,1<br>
     rank 2=+n2 slot=1-2<br>
     $ mpirun -H aa,bb,cc,dd -rf myrankfile ./a.out<br>
  <p>
Starting with Open MPI v1.7, all socket/core slot locations are be specified
as <i>logical</i> indexes (the Open MPI v1.6 series used <i>physical</i> indexes).  You
can use tools such as HWLOC&rsquo;s "lstopo" to find the logical indexes of socket
and cores.
<h3><a name='sect11' href='#toc11'>Application Context or Executable Program?</a></h3>
 To distinguish the
two different forms, <i>mpirun</i> looks on the command line for <i>--app</i> option.  If
it is specified, then the file named on the command line is assumed to
be an application context.  If it is not specified, then the file is assumed
to be an executable program.
<h3><a name='sect12' href='#toc12'>Locating Files</a></h3>
 If no relative or absolute
path is specified for a file, Open MPI will first look for files by searching
the directories specified by the <i>--path</i> option.  If there is no <i>--path</i> option
set or if the file is not found at the <i>--path</i> location, then Open MPI will
search the user&rsquo;s PATH environment variable as defined on the source node(s).
<p>
If a relative directory is specified, it must be relative to the initial
working directory determined by the specific starter used. For example when
using the rsh or ssh starters, the initial directory is $HOME by default.
Other starters may set the initial directory to the current working directory
from the invocation of <i>mpirun</i>.
<h3><a name='sect13' href='#toc13'>Current Working Directory</a></h3>
 The <i>-wdir</i> mpirun
option (and its synonym, <i>-wd</i>) allows the user to change to an arbitrary
directory before the program is invoked.  It can also be used in application
context files to specify working directories on specific nodes and/or for
specific applications. <p>
If the <i>-wdir</i> option appears both in a context file
and on the command line, the context file directory will override the command
line value. <p>
If the <i>-wdir</i> option is specified, Open MPI will attempt to change
to the specified directory on all of the remote nodes. If this fails, <i>mpirun</i>
will abort. <p>
If the <i>-wdir</i> option is <b>not</b> specified, Open MPI will send the
directory name where <i>mpirun</i> was invoked to each of the remote nodes. The
remote nodes will try to change to that directory. If they are unable (e.g.,
if the directory does not exist on that node), then Open MPI will use the
default directory determined by the starter. <p>
All directory changing occurs
before the user&rsquo;s program is invoked; it does not wait until <i><a href="../man3/MPI_Init.3.php">MPI_INIT</a></i> is
called.
<h3><a name='sect14' href='#toc14'>Standard I/O</a></h3>
 Open MPI directs UNIX standard input to /dev/null
on all processes except the MPI_COMM_WORLD rank 0 process. The MPI_COMM_WORLD
rank 0 process inherits standard input from <i>mpirun</i>. <b>Note:</b> The node that
invoked <i>mpirun</i> need not be the same as the node where the MPI_COMM_WORLD
rank 0 process resides. Open MPI handles the redirection of <i>mpirun</i>&rsquo;s standard
input to the rank 0 process. <p>
Open MPI directs UNIX standard output and error
from remote nodes to the node that invoked <i>mpirun</i> and prints it on the
standard output/error of <i>mpirun</i>. Local processes inherit the standard output/error
of <i>mpirun</i> and transfer to it directly. <p>
Thus it is possible to redirect standard
I/O for Open MPI applications by using the typical shell redirection procedure
on <i>mpirun</i>.
<p>       <b>%</b> mpirun -np 2 my_app &lt; my_input &gt; my_output<br>

<p> Note that in this example <i>only</i> the MPI_COMM_WORLD rank 0 process will
receive the stream from <i>my_input</i> on stdin.  The stdin on all the other nodes
will be tied to /dev/null.  However, the stdout from all nodes will be collected
into the <i>my_output</i> file.
<h3><a name='sect15' href='#toc15'>Signal Propagation</a></h3>
 When orterun receives a SIGTERM
and SIGINT, it will attempt to kill the entire job by sending all processes
in the job a SIGTERM, waiting a small number of seconds, then sending all
processes in the job a SIGKILL.  <p>
SIGUSR1 and SIGUSR2 signals received by
orterun are propagated to all processes in the job.  <p>
A SIGTSTOP signal to
mpirun will cause a SIGSTOP signal to be sent to all of the programs started
by mpirun and likewise a SIGCONT signal to mpirun will cause a SIGCONT
sent.  <p>
Other signals are not currently propagated by orterun.
<h3><a name='sect16' href='#toc16'>Process Termination
/ Signal Handling</a></h3>
 During the run of an MPI application, if any process
dies abnormally (either exiting before invoking <i><a href="../man3/MPI_Finalize.3.php">MPI_FINALIZE</a></i>, or dying
as the result of a signal), <i>mpirun</i> will print out an error message and
kill the rest of the MPI application. <p>
User signal handlers should probably
avoid trying to cleanup MPI state (Open MPI is currently not async-signal-safe;
see <i><a href="../man3/MPI_Init_thread.3.php">MPI_Init_thread</a>(3)</i> for details about <i>MPI_THREAD_MULTIPLE</i> and thread
safety).  For example, if a segmentation fault occurs in <i><a href="../man3/MPI_Send.3.php">MPI_SEND</a></i> (perhaps
because a bad buffer was passed in) and a user signal handler is invoked,
if this user handler attempts to invoke <i><a href="../man3/MPI_Finalize.3.php">MPI_FINALIZE</a></i>, Bad Things could
happen since Open MPI was already "in" MPI when the error occurred.  Since
<i>mpirun</i> will notice that the process died due to a signal, it is probably
not necessary (and safest) for the user to only clean up non-MPI state.

<h3><a name='sect17' href='#toc17'>Process Environment</a></h3>
 Processes in the MPI application inherit their environment
from the Open RTE daemon upon the node on which they are running.  The environment
is typically inherited from the user&rsquo;s shell.  On remote nodes, the exact
environment is determined by the boot MCA module used.  The <i>rsh</i> launch module,
for example, uses either <i>rsh</i>/<i>ssh</i> to launch the Open RTE daemon on remote
nodes, and typically executes one or more of the user&rsquo;s shell-setup files
before launching the Open RTE daemon.  When running dynamically linked applications
which require the <i>LD_LIBRARY_PATH</i> environment variable to be set, care
must be taken to ensure that it is correctly set when booting Open MPI.
<p>
See the "Remote Execution" section for more details.
<h3><a name='sect18' href='#toc18'>Remote Execution</a></h3>

Open MPI requires that the <i>PATH</i> environment variable be set to find executables
on remote nodes (this is typically only necessary in <i>rsh</i>- or <i>ssh</i>-based environments
-- batch/scheduled environments typically copy the current environment to
the execution of remote jobs, so if the current environment has <i>PATH</i> and/or
<i>LD_LIBRARY_PATH</i> set properly, the remote nodes will also have it set properly).
 If Open MPI was compiled with shared library support, it may also be necessary
to have the <i>LD_LIBRARY_PATH</i> environment variable set on remote nodes as
well (especially to find the shared libraries required to run user MPI
applications). <p>
However, it is not always desirable or possible to edit shell
startup files to set <i>PATH</i> and/or <i>LD_LIBRARY_PATH</i>.  The <i>--prefix</i> option is
provided for some simple configurations where this is not possible. <p>
The
<i>--prefix</i> option takes a single argument: the base directory on the remote
node where Open MPI is installed.  Open MPI will use this directory to set
the remote <i>PATH</i> and <i>LD_LIBRARY_PATH</i> before executing any Open MPI or user
applications.  This allows running Open MPI jobs without having pre-configured
the <i>PATH</i> and <i>LD_LIBRARY_PATH</i> on the remote nodes. <p>
Open MPI adds the basename
of the current node&rsquo;s "bindir" (the directory where Open MPI&rsquo;s executables
are installed) to the prefix and uses that to set the <i>PATH</i> on the remote
node.  Similarly, Open MPI adds the basename of the current node&rsquo;s "libdir"
(the directory where Open MPI&rsquo;s libraries are installed) to the prefix and
uses that to set the <i>LD_LIBRARY_PATH</i> on the remote node.  For example:
<dl>

<dt>Local
bindir: </dt>
<dd>/local/node/directory/bin </dd>

<dt>Local libdir: </dt>
<dd>/local/node/directory/lib64
</dd>
</dl>
<p>
If the following command line is used:
<p>     <b>%</b> mpirun --prefix /remote/node/directory<br>

<p> Open MPI will add "/remote/node/directory/bin" to the <i>PATH</i> and "/remote/node/directory/lib64"
to the <i>LD_LIBRARY_PATH</i> on the remote node before attempting to execute
anything. <p>
The <i>--prefix</i> option is not sufficient if the installation paths
on the remote node are different than the local node (e.g., if "/lib" is
used on the local node, but "/lib64" is used on the remote node), or if
the installation paths are something other than a subdirectory under a
common prefix. <p>
Note that executing <i>mpirun</i> via an absolute pathname is equivalent
to specifying <i>--prefix</i> without the last subdirectory in the absolute pathname
to <i>mpirun</i>.  For example:
<p>     <b>%</b> /usr/local/bin/mpirun ...<br>

<p> is equivalent to
<p>     <b>%</b> mpirun --prefix /usr/local<br>

<h3><a name='sect19' href='#toc19'>Exported Environment Variables</a></h3>
 All environment variables that are named
in the form OMPI_* will automatically be exported to new processes on the
local and remote nodes. Environmental parameters can also be set/forwarded
to the new processes using the MCA parameter <i>mca_base_env_list</i>. The <i>-x</i> option
to <i>mpirun</i> has been deprecated, but the syntax of the MCA param follows
that prior example. While the syntax of the <i>-x</i> option and MCA param allows
the definition of new variables, note that the parser for these options
are currently not very sophisticated - it does not even understand quoted
values.  Users are advised to set variables in the environment and use the
option to export them; not to define them.
<h3><a name='sect20' href='#toc20'>Setting MCA Parameters</a></h3>
 The
<i>-mca</i> switch allows the passing of parameters to various MCA (Modular Component
Architecture) modules.  MCA modules have direct impact on MPI programs because
they allow tunable parameters to be set at run time (such as which BTL
communication device driver to use, what parameters to pass to that BTL,
etc.). <p>
The <i>-mca</i> switch takes two arguments: <i>&lt;key&gt;</i> and <i>&lt;value&gt;</i>. The <i>&lt;key&gt;</i> argument
generally specifies which MCA module will receive the value. For example,
the <i>&lt;key&gt;</i> "btl" is used to select which BTL to be used for transporting MPI
messages.  The <i>&lt;value&gt;</i> argument is the value that is passed. For example:

<dl>

<dt>mpirun -mca btl tcp,self -np 1 foo </dt>
<dd>Tells Open MPI to use the "tcp" and "self"
BTLs, and to run a single copy of "foo" an allocated node.  </dd>

<dt>mpirun -mca btl
self -np 1 foo </dt>
<dd>Tells Open MPI to use the "self" BTL, and to run a single
copy of "foo" an allocated node.  </dd>
</dl>
<p>
The <i>-mca</i> switch can be used multiple times
to specify different <i>&lt;key&gt;</i> and/or <i>&lt;value&gt;</i> arguments.  If the same <i>&lt;key&gt;</i> is specified
more than once, the <i>&lt;value&gt;</i>s are concatenated with a comma (",") separating
them. <p>
Note that the <i>-mca</i> switch is simply a shortcut for setting environment
variables. The same effect may be accomplished by setting corresponding
environment variables before running <i>mpirun</i>. The form of the environment
variables that Open MPI sets is:
<p>       OMPI_MCA_&lt;key&gt;=&lt;value&gt;<br>
 <p>
Thus, the <i>-mca</i> switch overrides any previously set environment variables.
 The <i>-mca</i> settings similarly override MCA parameters set in the $OPAL_PREFIX/etc/openmpi-mca-params.conf
or $HOME/.openmpi/mca-params.conf file.  <p>
Unknown <i>&lt;key&gt;</i> arguments are still set
as environment variable -- they are not checked (by <i>mpirun</i>) for correctness.
Illegal or incorrect <i>&lt;value&gt;</i> arguments may or may not be reported -- it depends
on the specific MCA module. <p>
To find the available component types under
the MCA architecture, or to find the available parameters for a specific
component, use the <i>ompi_info</i> command. See the <i><i>ompi_info(1)</i></i> man page for
detailed information on the command.
<h3><a name='sect21' href='#toc21'>Setting MCA parameters and environment
variables from file.</a></h3>
The <i>-tune</i> command line option and its synonym <i>-mca mca_base_envar_file_prefix</i>
allows a user to set mca parameters and environment variables with the
syntax described below. This option requires a single file or list of files
separated by "," to follow. <p>
A valid line in the file may contain zero or
many "-x", "-mca", or “--mca” arguments. The following patterns are supported:
-mca var val -mca var "val" -x var=val -x var. If any argument is duplicated
in the file, the last value read will be used. <p>
MCA parameters and environment
specified on the command line have higher precedence than variables specified
in the file.
<h3><a name='sect22' href='#toc22'>Running as root</a></h3>
 The Open MPI team strongly advises against
executing <i>mpirun</i> as the root user.  MPI applications should be run as regular
(non-root) users.  <p>
Reflecting this advice, mpirun will refuse to run as root
by default. To override this default, you can add the <i>--allow-run-as-root</i> option
to the <i>mpirun</i> command line, or you can set the environmental parameters
<i>OMPI_ALLOW_RUN_AS_ROOT=1</i> and <i>OMPI_ALLOW_RUN_AS_ROOT_CONFIRM=1</i>. Note that
it takes setting <i>two</i> environment variables to effect the same behavior
as <i>--allow-run-as-root</i> in order to stress the Open MPI team&rsquo;s strong advice against
running as the root user.  After extended discussions with communities who
use containers (where running as the root user is the default), there was
a persistent desire to be able to enable root execution of <i>mpirun</i> via an
environmental control (vs. the existing <i>--allow-run-as-root</i> command line parameter).
 The compromise of using <i>two</i> environment variables was reached: it allows
root execution via an environmental control, but it conveys the Open MPI
team&rsquo;s strong recomendation against this behavior.
<h3><a name='sect23' href='#toc23'>Exit status</a></h3>
 There is
no standard definition for what <i>mpirun</i> should return as an exit status.
After considerable discussion, we settled on the following method for assigning
the <i>mpirun</i> exit status (note: in the following description, the "primary"
job is the initial application started by mpirun - all jobs that are spawned
by that job are designated "secondary" jobs):
<dl>

<dt>[bu]</dt>
<dd>if all processes in
the primary job normally terminate with exit status 0, we return 0 </dd>

<dt>[bu]</dt>
<dd>if
one or more processes in the primary job normally terminate with non-zero
exit status, we return the exit status of the process with the lowest MPI_COMM_WORLD
rank to have a non-zero status </dd>

<dt>[bu]</dt>
<dd>if all processes in the primary job normally
terminate with exit status 0, and one or more processes in a secondary
job normally terminate with non-zero exit status, we (a) return the exit
status of the process with the lowest MPI_COMM_WORLD rank in the lowest
jobid to have a non-zero status, and (b) output a message summarizing the
exit status of the primary and all secondary jobs. </dd>

<dt>[bu]</dt>
<dd>if the cmd line option
--report-child-jobs-separately is set, we will return -only- the exit status of
the primary job. Any non-zero exit status in secondary jobs will be reported
solely in a summary print statement.  </dd>
</dl>
<p>
By default, OMPI records and notes
that MPI processes exited with non-zero termination status. This is generally
not considered an "abnormal termination" - i.e., OMPI will not abort an MPI
job if one or more processes return a non-zero status. Instead, the default
behavior simply reports the number of processes terminating with non-zero
status upon completion of the job. <p>
However, in some cases it can be desirable
to have the job abort when any process terminates with non-zero status. For
example, a non-MPI job might detect a bad result from a calculation and
want to abort, but doesn&rsquo;t want to generate a core file. Or an MPI job might
continue past a call to <a href="../man3/MPI_Finalize.3.php">MPI_Finalize</a>, but indicate that all processes should
abort due to some post-MPI result. <p>
It is not anticipated that this situation
will occur frequently. However, in the interest of serving the broader community,
OMPI now has a means for allowing users to direct that jobs be aborted
upon any process exiting with non-zero status. Setting the MCA parameter
"orte_abort_on_non_zero_status" to 1 will cause OMPI to abort all processes
once any process  exits with non-zero status.<br>
 <p>
Terminations caused in this manner will be reported on the console as
an "abnormal termination", with the first process to so exit identified
along with its exit status. <p>

<h2><a name='sect24' href='#toc24'>Examples</a></h2>
Be sure also to see the examples
throughout the sections above.
<dl>

<dt>mpirun -np 4 -mca btl ib,tcp,self prog1 </dt>
<dd>Run
4 copies of prog1 using the "ib", "tcp", and "self" BTL&rsquo;s for the transport
of MPI messages.   </dd>

<dt>mpirun -np 4 -mca btl tcp,sm,self </dt>
<dd><br>
--mca btl_tcp_if_include eth0 prog1 <br>
Run 4 copies of prog1 using the "tcp", "sm" and "self" BTLs for the transport
of MPI messages, with TCP using only the eth0 interface to communicate.
 Note that other BTLs have similar if_include MCA parameters.
    </dd>
</dl>

<h2><a name='sect25' href='#toc25'>Return Value</a></h2>
 <i>mpirun</i> returns 0 if all processes started by <i>mpirun</i> exit
after calling <a href="../man3/MPI_Finalize.3.php">MPI_FINALIZE</a>.  A non-zero value is returned if an internal
error occurred in mpirun, or one or more processes exited before calling
<a href="../man3/MPI_Finalize.3.php">MPI_FINALIZE</a>.  If an internal error occurred in mpirun, the corresponding
error code is returned. In the event that one or more processes exit before
calling <a href="../man3/MPI_Finalize.3.php">MPI_FINALIZE</a>, the return value of the MPI_COMM_WORLD rank of the
process that <i>mpirun</i> first notices died before calling <a href="../man3/MPI_Finalize.3.php">MPI_FINALIZE</a> will
be returned.  Note that, in general, this will be the first process that
died but is not guaranteed to be so.  <p>
If the <b>--timeout</b> command line option
is used and the timeout expires before the job completes (thereby forcing
<i>mpirun</i> to kill the job) <i>mpirun</i> will return an exit status equivalent to
the value of <b>ETIMEDOUT</b> (which is typically 110 on Linux and OS X systems).

<p>
<h2><a name='sect26' href='#toc26'>See Also</a></h2>
<i><a href="../man3/MPI_Init_thread.3.php">MPI_Init_thread</a>(3)</i> <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Quick Summary</a></li>
<li><a name='toc3' href='#sect3'>Options</a></li>
<ul>
<li><a name='toc4' href='#sect4'>Environment Variables</a></li>
</ul>
<li><a name='toc5' href='#sect5'>Description</a></li>
<ul>
<li><a name='toc6' href='#sect6'>Specifying Host Nodes</a></li>
<li><a name='toc7' href='#sect7'>Specifying Number of Processes</a></li>
<li><a name='toc8' href='#sect8'>Mapping Processes to Nodes:  Using Policies</a></li>
<li><a name='toc9' href='#sect9'>Mapping, Ranking, and Binding: Oh My!</a></li>
<li><a name='toc10' href='#sect10'>Rankfiles</a></li>
<li><a name='toc11' href='#sect11'>Application Context or Executable Program?</a></li>
<li><a name='toc12' href='#sect12'>Locating Files</a></li>
<li><a name='toc13' href='#sect13'>Current Working Directory</a></li>
<li><a name='toc14' href='#sect14'>Standard I/O</a></li>
<li><a name='toc15' href='#sect15'>Signal Propagation</a></li>
<li><a name='toc16' href='#sect16'>Process Termination / Signal Handling</a></li>
<li><a name='toc17' href='#sect17'>Process Environment</a></li>
<li><a name='toc18' href='#sect18'>Remote Execution</a></li>
<li><a name='toc19' href='#sect19'>Exported Environment Variables</a></li>
<li><a name='toc20' href='#sect20'>Setting MCA Parameters</a></li>
<li><a name='toc21' href='#sect21'>Setting MCA parameters and environment variables from file.</a></li>
<li><a name='toc22' href='#sect22'>Running as root</a></li>
<li><a name='toc23' href='#sect23'>Exit status</a></li>
</ul>
<li><a name='toc24' href='#sect24'>Examples</a></li>
<li><a name='toc25' href='#sect25'>Return Value</a></li>
<li><a name='toc26' href='#sect26'>See Also</a></li>
</ul>


<p> <a href="../">&laquo; Return to documentation listing</a></p>
<?php
include_once("$topdir/includes/footer.inc");
