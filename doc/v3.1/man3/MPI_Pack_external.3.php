<?php
$topdir = "../../..";
$title = "MPI_Pack_external(3) man page (version 3.1.1)";
$meta_desc = "Open MPI v3.1.1 man page: MPI_PACK_EXTERNAL(3)";

include_once("$topdir/doc/nav.inc");
include_once("$topdir/includes/header.inc");
?>
<p> <a href="../">&laquo; Return to documentation listing</a></p>
      <!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>

<p>
<h2><a name='sect0' href='#toc0'>Name</a></h2>
<b>MPI_Pack_external</b> - Writes data to a portable format
<p>
<h2><a name='sect1' href='#toc1'>Syntax</a></h2>

<p>

<h2><a name='sect2' href='#toc2'>C Syntax</a></h2>
<br>
<pre>#include &lt;mpi.h&gt;
int MPI_Pack_external(const char *datarep, const void *inbuf,
<tt> </tt>&nbsp;<tt> </tt>&nbsp;int incount, MPI_Datatype datatype,
<tt> </tt>&nbsp;<tt> </tt>&nbsp;void *outbuf, MPI_Aint outsize,
<tt> </tt>&nbsp;<tt> </tt>&nbsp;MPI_Aint *position)
</pre>
<h2><a name='sect3' href='#toc3'>Fortran Syntax</a></h2>
<br>
<pre>USE MPI
! or the older form: INCLUDE &rsquo;mpif.h&rsquo;
MPI_PACK_EXTERNAL(DATAREP, INBUF, INCOUNT, DATATYPE,
<tt> </tt>&nbsp;<tt> </tt>&nbsp;OUTBUF, OUTSIZE, POSITION, IERROR)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;INTEGER<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;INCOUNT, DATATYPE, IERROR
<tt> </tt>&nbsp;<tt> </tt>&nbsp;INTEGER(KIND=MPI_ADDRESS_KIND) OUTSIZE, POSITION
<tt> </tt>&nbsp;<tt> </tt>&nbsp;CHARACTER*(*)<tt> </tt>&nbsp;<tt> </tt>&nbsp;DATAREP
<tt> </tt>&nbsp;<tt> </tt>&nbsp;&lt;type&gt;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;INBUF(*), OUTBUF(*)
</pre>
<h2><a name='sect4' href='#toc4'>Fortran 2008 Syntax</a></h2>
<br>
<pre>USE mpi_f08
MPI_Pack_external(datarep, inbuf, incount, datatype, outbuf, outsize,
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;position, ierror)
<tt> </tt>&nbsp;<tt> </tt>&nbsp;CHARACTER(LEN=*), INTENT(IN) :: datarep
<tt> </tt>&nbsp;<tt> </tt>&nbsp;TYPE(*), DIMENSION(..), INTENT(IN) :: inbuf
<tt> </tt>&nbsp;<tt> </tt>&nbsp;TYPE(*), DIMENSION(..) :: outbuf
<tt> </tt>&nbsp;<tt> </tt>&nbsp;INTEGER, INTENT(IN) :: incount
<tt> </tt>&nbsp;<tt> </tt>&nbsp;TYPE(MPI_Datatype), INTENT(IN) :: datatype
<tt> </tt>&nbsp;<tt> </tt>&nbsp;INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(IN) :: outsize
<tt> </tt>&nbsp;<tt> </tt>&nbsp;INTEGER(KIND=MPI_ADDRESS_KIND), INTENT(INOUT) :: position
<tt> </tt>&nbsp;<tt> </tt>&nbsp;INTEGER, OPTIONAL, INTENT(OUT) :: ierror
</pre>
<h2><a name='sect5' href='#toc5'>Input Parameters</a></h2>

<dl>

<dt>datarep </dt>
<dd>Data representation (string). </dd>

<dt>inbuf </dt>
<dd>Input buffer
start (choice). </dd>

<dt>incount </dt>
<dd>Number of input data items (integer). </dd>

<dt>datatype </dt>
<dd>Datatype
of each input data item (handle). </dd>

<dt>outsize </dt>
<dd>Output buffer size, in bytes (integer).

<p> </dd>
</dl>

<h2><a name='sect6' href='#toc6'>Input/Output Parameter</a></h2>

<dl>

<dt>position </dt>
<dd>Current position in buffer, in bytes (integer).

<p> </dd>
</dl>

<h2><a name='sect7' href='#toc7'>Output Parameters</a></h2>

<dl>

<dt>outbuf </dt>
<dd>Output buffer start (choice). </dd>

<dt>IERROR </dt>
<dd>Fortran only:
Error status (integer).
<p> </dd>
</dl>

<h2><a name='sect8' href='#toc8'>Description</a></h2>
MPI_Pack_external packs data into the
external32 format, a universal data representation defined by the MPI Forum.
This format is useful for exchanging data between MPI implementations,
or when writing data to a file. <p>
The input buffer is specified by <i>inbuf</i>,
<i>incount</i> and <i>datatype</i>, and may be any communication buffer allowed in <a href="../man3/MPI_Send.3.php">MPI_Send</a>.
The output buffer <i>outbuf</i> must be a contiguous storage area containing <i>outsize</i>
bytes. <p>
The input value of <i>position</i> is the first position in <i>outbuf</i> to be
used for packing (measured in bytes, not elements, relative to the start
of the buffer). When the function returns, <i>position</i> is incremented by the
size of the packed message, so that it points to the first location in
<i>outbuf</i> following the packed message. This way it may be used as input to
a subsequent call to MPI_Pack_external. <p>

<p> <b>Example:</b> An example using MPI_Pack_external:
<p>
<br>
<pre><tt> </tt>&nbsp;<tt> </tt>&nbsp;int position, i;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;double msg[5];
<tt> </tt>&nbsp;<tt> </tt>&nbsp;char buf[1000];
<tt> </tt>&nbsp;<tt> </tt>&nbsp;...
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<a href="../man3/MPI_Comm_rank.3.php">MPI_Comm_rank</a>(MPI_COMM_WORLD, &amp;myrank);
<tt> </tt>&nbsp;<tt> </tt>&nbsp;if (myrank == 0) {<tt> </tt>&nbsp;<tt> </tt>&nbsp;/* SENDER CODE */
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;position = 0;
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;i = 5; /* number of doubles in msg[] */
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;MPI_Pack_external("external32", &amp;i, 1, MPI_INT,
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;    buf, 1000, &amp;position);
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;MPI_Pack_external("external32", &amp;msg, i, MPI_DOUBLE,
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;    buf, 1000, &amp;position);
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<a href="../man3/MPI_Send.3.php">MPI_Send</a>(buf, position, MPI_BYTE, 1, 0,
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;    MPI_COMM_WORLD);
<tt> </tt>&nbsp;<tt> </tt>&nbsp;} else {<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;/* RECEIVER CODE */
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<a href="../man3/MPI_Recv.3.php">MPI_Recv</a>(buf, 1, MPI_BYTE, 0, 0, MPI_COMM_WORLD,
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;    MPI_STATUS_IGNORE);
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<a href="../man3/MPI_Unpack_external.3.php">MPI_Unpack_external</a>("external32", buf, 1000,
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;    MPI_INT, &amp;i, 1, &amp;position);
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<a href="../man3/MPI_Unpack_external.3.php">MPI_Unpack_external</a>("external32", buf, 1000,
<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;<tt> </tt>&nbsp;    MPI_DOUBLE, &amp;msg, i, &amp;position);
<tt> </tt>&nbsp;<tt> </tt>&nbsp;}
</pre>
<h2><a name='sect9' href='#toc9'>Notes</a></h2>
The <i>datarep</i> argument specifies the data format. The only valid value
in the current version of MPI is "external32". The argument is provided
for future extensibility. <p>
To understand the behavior of pack and unpack,
it is convenient to think of the data part of a message as being the sequence
obtained by concatenating the successive values sent in that message. The
pack operation stores this sequence in the buffer space, as if sending
the message to that buffer. The unpack operation retrieves this sequence
from buffer space, as if receiving a message from that buffer. (It is helpful
to think of internal Fortran files or sscanf in C for a similar function.)
<p>
Several messages can be successively packed into one packing unit. This
is effected by several successive related calls to MPI_Pack_external, where
the first call provides <i>position</i>=0, and each successive call inputs the
value of <i>position</i> that was output by the previous call, along with the
same values for <i>outbuf</i> and <i>outcount</i>. This packing unit now contains the
equivalent information that would have been stored in a message by one
send call with a send buffer that is the "concatenation" of the individual
send buffers. <p>
A packing unit can be sent using type MPI_BYTE. Any point-to-point
or collective communication function can be used to move the sequence of
bytes that forms the packing unit from one process to another. This packing
unit can now be received using any receive operation, with any datatype.
(The type-matching rules are relaxed for messages sent with type MPI_BYTE.)
<p>
A packing unit can be unpacked into several successive messages. This is
effected by several successive related calls to <a href="../man3/MPI_Unpack_external.3.php">MPI_Unpack_external</a>, where
the first call provides <i>position</i>=0, and each successive call inputs the
value of position that was output by the previous call, and the same values
for <i>inbuf</i> and <i>insize</i>. <p>
The concatenation of two packing units is not necessarily
a packing unit; nor is a substring of a packing unit necessarily a packing
unit. Thus, one cannot concatenate two packing units and then unpack the
result as one packing unit; nor can one unpack a substring of a packing
unit as a separate packing unit. Each packing unit that was created by a
related sequence of pack calls must be unpacked as a unit by a sequence
of related unpack calls.
<p>
<h2><a name='sect10' href='#toc10'>Errors</a></h2>
Almost all MPI routines return an error
value; C routines as the value of the function and Fortran routines in
the last argument. C++ functions do not return errors. If the default error
handler is set to MPI::ERRORS_THROW_EXCEPTIONS, then on error the C++ exception
mechanism will be used to throw an MPI::Exception object. <p>
Before the error
value is returned, the current MPI error handler is called. By default,
this error handler aborts the MPI job, except for I/O function errors. The
error handler may be changed with <a href="../man3/MPI_Comm_set_errhandler.3.php">MPI_Comm_set_errhandler</a>; the predefined
error handler MPI_ERRORS_RETURN may be used to cause error values to be
returned. Note that MPI does not guarantee that an MPI program can continue
past an error. <p>
See the MPI man page for a full list of MPI error codes.
<p>

<h2><a name='sect11' href='#toc11'>See Also</a></h2>
<br>
<pre><a href="../man3/MPI_Pack_external_size.3.php">MPI_Pack_external_size</a>
<a href="../man3/MPI_Send.3.php">MPI_Send</a>
<a href="../man3/MPI_Unpack_external.3.php">MPI_Unpack_external</a>
sscanf(3C)

<p> <a href="../">&laquo; Return to documentation listing</a></p>
<?php
include_once("$topdir/includes/footer.inc");
