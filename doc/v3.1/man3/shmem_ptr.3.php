<?php
$topdir = "../../..";
$title = "shmem_ptr(3) man page (version 3.1.0)";
$meta_desc = "Open MPI v3.1.0 man page: shmem_ptr(3)";

include_once("$topdir/doc/nav.inc");
include_once("$topdir/includes/header.inc");
?>
<p> <a href="../">&laquo; Return to documentation listing</a></p>
    <!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>

<p> <i><i>shmem_ptr</i>(3)</i> - Returns a pointer to a data object on a specified
processing element (PE).
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>

<p> C or C++: <br>
<pre>#include &lt;mpp/shmem.h&gt;
void *shmem_ptr(const void *target, int pe);
</pre> Fortran: <br>
<pre>INCLUDE "mpp/shmem.fh"
POINTER (PTR, POINTEE)
INTEGER pe
PTR = SHMEM_PTR(target, pe)
</pre>
<h2><a name='sect2' href='#toc2'>Description</a></h2>

<p> The shmem_ptr routine returns an address that can be used
to directly reference <b>target</b> on the remote PE <b>pe</b>. With this address we can
perform ordinary loads and stores to the remote address. <p>
When a sequence
of loads (gets) and stores (puts) to a data object on a remote PE does
not match the access pattern provided in a SHMEM data transfer routine
like <i><i>shmem_put32</i>(3)</i> or <i><i>shmem_real_iget</i>(3)</i>, the shmem_ptr function can provide
an efficient means to accomplish the communication. <p>
The arguments are as
follows:
<dl>

<dt>target </dt>
<dd>The symmetric data object to be referenced. </dd>

<dt>pe </dt>
<dd>An integer
that indicates the PE number on which target is to be accessed. If you are
using Fortran, it must be a default integer value. </dd>
</dl>
<p>

<h2><a name='sect3' href='#toc3'>Examples</a></h2>

<p> This Fortran
program calls shmem_ptr and then PE 0 writes to the BIGD array on PE 1:
<br>
<pre>PROGRAM REMOTEWRITE
  INCLUDE &rsquo;mpp/shmem.fh&rsquo;
  INTEGER BIGD(100)
  SAVE BIGD
  INTEGER POINTEE(*)
  POINTER (PTR,POINTEE)
  CALL START_PES(0)
  IF (MY_PE() .EQ. 0) THEN
                             ! initialize PE 1&rsquo;s BIGD array
    PTR = SHMEM_PTR(BIGD, 1) ! get address of PE 1&rsquo;s BIGD
                             ! array
    DO I=1,100
      POINTEE(I) = I
    ENDDO
  ENDIF
  CALL SHMEM_BARRIER_ALL
  IF (MY_PE() .EQ. 1) THEN
    PRINT *, &rsquo;BIGD on PE 1 is: &rsquo;
    PRINT *, BIGD
  ENDIF
END
</pre> This is the equivalent program written in C: <br>
<pre>#include &lt;mpp/shmem.h&gt;
main()
{
  static int bigd[100];
  int *ptr;
  int i;
  shmem_init();
  if (shmem_my_pe() == 0) {
  /* initialize PE 1&rsquo;s bigd array */
    ptr = shmem_ptr(bigd, 1);
    for (i=0; i&lt;100; i++)
      *ptr++ = i+1;
  }
  shmem_barrier_all();
  if (shmem_my_pe() == 1) {
    printf("bigd on PE 1 is:\n");
    for (i=0; i&lt;100; i++)
      printf(" %d\n",bigd[i]);
    printf("\n");
  }
}
</pre>
<h2><a name='sect4' href='#toc4'>Notes</a></h2>

<p> The shmem_ptr function is available only on systems where ordinary
memory loads and stores are used to implement SHMEM put and get operations.
<p>

<h2><a name='sect5' href='#toc5'>Return Values</a></h2>

<p> shmem_ptr returns a pointer to the data object on the specified
remote PE. If target is not remotely accessible, a NULL pointer is returned.
<p>

<h2><a name='sect6' href='#toc6'>See Also</a></h2>

<p> <i><i>intro_shmem</i>(3)</i>, <i><i>shmem_put</i>(3)</i>, <i><i>shmem_get</i>(3)</i> <p>
<p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Examples</a></li>
<li><a name='toc4' href='#sect4'>Notes</a></li>
<li><a name='toc5' href='#sect5'>Return Values</a></li>
<li><a name='toc6' href='#sect6'>See Also</a></li>
</ul>


<p> <a href="../">&laquo; Return to documentation listing</a></p>
<?php
include_once("$topdir/includes/footer.inc");
