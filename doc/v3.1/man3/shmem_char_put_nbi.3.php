<?php
$topdir = "../../..";
$title = "shmem_char_put_nbi(3) man page (version 3.1.3)";
$meta_desc = "Open MPI v3.1.3 man page: shmem_char_put_nbi(3)";

include_once("$topdir/doc/nav.inc");
include_once("$topdir/includes/header.inc");
?>
<p> <a href="../">&laquo; Return to documentation listing</a></p>
   <!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>

<p> <i><i>shmem_putmem_nbi</i>(3)</i>, <i><i>shmem_char_put_nbi</i>(3)</i>, <i><i>shmem_short_put_nbi</i>(3)</i>,
<i><i>shmem_int_put_nbi</i>(3)</i>, <i><i>shmem_long_put_nbi</i>(3)</i>, <i><i>shmem_longlong_put_nbi</i>(3)</i>,
<i><i>shmem_float_put_nbi</i>(3)</i>, <i><i>shmem_double_put_nbi</i>(3)</i>, <i><i>shmem_longdouble_put_nbi</i>(3)</i>,
<i><i>shmem_put8_nbi</i>(3)</i>, <i><i>shmem_put16_nbi</i>(3)</i>, <i><i>shmem_put32_nbi</i>(3)</i>, <i><i>shmem_put64_nbi</i>(3)</i>,
<i><i>shmem_put128_nbi</i>(3)</i>, - The nonblocking put routines provide a method for
copying data from a contiguous local data object to a data object on a
specified PE.
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>

<p> C or C++: <br>
<pre>#include &lt;mpp/shmem.h&gt;
void shmem_putmem_nbi(void *dest, const void *source,
  size_t nelems, int pe);
void shmem_char_put(char *dest, const char *source,
  size_t nelems, int pe);
void shmem_short_put(short *dest, const short *source,
  size_t nelems, int pe);
void shmem_int_put(int *dest, const int *source,
  size_t nelems, int pe);
void shmem_long_put(long *dest, const long *source,
  size_t nelems, int pe);
void shmem_longlong_put(long long *dest, const long long *source,
  size_t nelems, int pe);
void shmem_float_put(float *dest, const float *source,
  size_t nelems, int pe);
void shmem_double_put(double *dest, const double *source,
  size_t nelems, int pe);
void shmem_longdouble_put(long double *dest, const long double *source,
  size_t nelems, int pe);
void shmem_put8(void *dest, const void *source,
  size_t nelems, int pe);
void shmem_put16(void *dest, const void *source,
  size_t nelems, int pe);
void shmem_put32(void *dest, const void *source,
  size_t nelems, int pe);
void shmem_put64(void *dest, const void *source,
  size_t nelems, int pe);
void shmem_put128(void *dest, const void *source,
  size_t nelems, int pe);
</pre> Fortran: <br>
<pre>INCLUDE "mpp/shmem.fh"
INTEGER nelems, pe
CALL SHMEM_PUTMEM_NBI(dest, source, nelems, pe)
CALL SHMEM_CHARACTER_PUT_NBI(dest, source, nelems, pe)
CALL SHMEM_COMPLEX_PUT_NBI(dest, source, nelems, pe)
CALL SHMEM_DOUBLE_PUT_NBI(dest, source, nelems, pe)
CALL SHMEM_INTEGER_PUT_NBI(dest, source, nelems, pe)
CALL SHMEM_LOGICAL_PUT_NBI(dest, source, nelems, pe)
CALL SHMEM_REAL_PUT_NBI(dest, source, nelems, pe)
CALL SHMEM_PUT4_NBI(dest, source, nelems, pe)
CALL SHMEM_PUT8_NBI(dest, source, nelems, pe)
CALL SHMEM_PUT32_NBI(dest, source, nelems, pe)
CALL SHMEM_PUT64_NBI(dest, source, nelems, pe)
CALL SHMEM_PUT128_NBI(dest, source, nelems, pe)
</pre>
<h2><a name='sect2' href='#toc2'>Description</a></h2>

<p> The routines return after posting the operation. The operation
is considered complete after a subsequent call to shmem_quiet. At the completion
of shmem_quiet, the data has been copied into the dest array on the destination
PE. The delivery of data words into the data object on the destination PE
may occur in any order. Furthermore, two successive put routines may deliver
data out of order unless a call to shmem_fence is introduced between the
two calls. <p>
The arguments are as follows:
<dl>

<dt>dest </dt>
<dd>Data object to be updated
on the remote PE. This data object must be remotely accessible. </dd>

<dt>source </dt>
<dd>Data
object containing the data to be copied. </dd>

<dt>nelems </dt>
<dd>Number of elements in the
dest and source arrays. nelems must be of type size_t for C. If you are using
Fortran, it must be a constant, variable, or array element of default integer
type. </dd>

<dt>pe </dt>
<dd>PE number of the remote PE. pe must be of type integer. If you are
using Fortran, it must be a constant, variable, or array element of default
integer type. </dd>
</dl>
<p>
If you are using Fortran, data types must be of default size.
For example, a real variable must be declared as REAL, REAL*4, or REAL(KIND=4).

<h2><a name='sect3' href='#toc3'>Notes</a></h2>

<p> See <i><i>intro_shmem</i>(3)</i> for a definition of the term remotely accessible.

<h2><a name='sect4' href='#toc4'>Examples</a></h2>

<p> Consider this simple example for Fortran. <br>
<pre>#include &lt;stdio.h&gt;
#include &lt;mpp/shmem.h&gt;
main()
{
  long source[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
  static long target[10];
  shmem_init();
  if (shmem_my_pe() == 0) {
    /* put 10 words into target on PE 1 */
    shmem_long_put_nbi(target, source, 10, 1);
    shmem_quiet();
  }
  shmem_barrier_all();  /* sync sender and receiver */
  if (shmem_my_pe() == 1)
    shmem_udcflush();  /* not required on Altix systems */
  printf("target[0] on PE %d is %d\n", shmem_my_pe(), target[0]);
}
</pre>
<h2><a name='sect5' href='#toc5'>See Also</a></h2>

<p> <i><i>intro_shmem</i>(3)</i>, <i><i>shmem_quiet</i>(3)</i>  <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Notes</a></li>
<li><a name='toc4' href='#sect4'>Examples</a></li>
<li><a name='toc5' href='#sect5'>See Also</a></li>
</ul>


<p> <a href="../">&laquo; Return to documentation listing</a></p>
<?php
include_once("$topdir/includes/footer.inc");
