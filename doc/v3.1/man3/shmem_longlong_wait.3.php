<?php
$topdir = "../../..";
$title = "shmem_longlong_wait(3) man page (version 3.1.3)";
$meta_desc = "Open MPI v3.1.3 man page: shmem_longlong_wait(3)";

include_once("$topdir/doc/nav.inc");
include_once("$topdir/includes/header.inc");
?>
<p> <a href="../">&laquo; Return to documentation listing</a></p>
    <!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>

<p> <i><i>shmem_int_wait</i>(3)</i>, <i><i>shmem_int_wait</i>(3)</i>_until, <i><i>shmem_int4_wait</i>(3)</i>,
<i><i>shmem_int4_wait</i>(3)</i>_until, <i><i>shmem_int8_wait</i>(3)</i>, <i><i>shmem_int8_wait</i>(3)</i>_until,
<i><i>shmem_long_wait</i>(3)</i>, <i><i>shmem_long_wait</i>(3)</i>_until, <i><i>shmem_longlong_wait</i>(3)</i>, <i><i>shmem_longlong_wait</i>(3)</i>_until,
<i><i>shmem_short_wait</i>(3)</i>, <i><i>shmem_short_wait</i>(3)</i>_until, <i><i>shmem_wait</i>(3)</i>, <i><i>shmem_wait</i>(3)</i>_until
- Waits for a variable on the local processing element (PE) to change
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>

<p>
C or C++: <br>
<pre>#include &lt;mpp/shmem.h&gt;
void shmem_int_wait(volatile int *var, int value);
void shmem_int_wait_until(volatile int *var, int cond, int value);
void shmem_long_wait(volatile long *var, long value);
void shmem_long_wait_until(volatile long *var, int cond, long value);
void shmem_longlong_wait(volatile long long *var, long long value);
void shmem_longlong_wait_until(volatile long long *var, int cond,
  long long value);
void shmem_short_wait(volatile short *var, short value);
void shmem_short_wait_until(volatile short *var, int cond,
  short value);
void shmem_wait(volatile long *ivar, long cmp_value);
void shmem_wait_until(volatile long *ivar, int cmp, long value);
</pre> Fortran: <br>
<pre>INCLUDE "mpp/shmem.fh"
CALL SHMEM_INT4_WAIT(ivar, cmp_value)
CALL SHMEM_INT4_WAIT_UNTIL(ivar, cmp, cmp_value)
CALL SHMEM_INT8_WAIT(ivar, cmp_value)
CALL SHMEM_INT8_WAIT_UNTIL(ivar, cmp, cmp_value)
CALL SHMEM_WAIT(ivar, cmp_value)
CALL SHMEM_WAIT_UNTIL(ivar, cmp, cmp_value)
</pre>
<h2><a name='sect2' href='#toc2'>Description</a></h2>

<p> shmem_wait and shmem_wait_until wait for <b>ivar</b> to be changed
by a remote write or atomic swap issued by a different processor. These
routines can be used for point-to- point directed synchronization. A call
to shmem_wait does not return until some other processor writes a value,
not equal to cmp_value, into <b>ivar</b> on the waiting processor. A call to shmem_wait_until
does not return until some other processor changes <b>ivar</b> to satisfy the
condition implied by cmp and cmp_value. This mechanism is useful when a
processor needs to tell another processor that it has completed some action.
<p>
The arguments are as follows:
<dl>

<dt>target </dt>
<dd>The remotely accessible integer data
object to be updated on the remote PE. If you are using C/C++, the type
of target should match that implied in the SYNOPSIS section. If you are
using the Fortran compiler, it must be of type integer with an element
size of 4 bytes for SHMEM_INT4_ADD and 8 bytes for SHMEM_INT8_ADD. </dd>

<dt>value
</dt>
<dd>The value to be atomically added to target. If you are using C/C++, the
type of value should match that implied in the SYNOPSIS section. If you
are using Fortran, it must be of type integer with an element size of target.
</dd>

<dt>pe </dt>
<dd>An integer that indicates the PE number upon which target is to be updated.
If you are using Fortran, it must be a default integer value. </dd>

<dt>ivar </dt>
<dd>A remotely
accessible integer variable that is being updated by another PE. If you
are using C/C++, the type of ivar should match that implied in the SYNOPSIS
section. If you are using Fortran, ivar must be a specific sized integer
type according to the function being called, as follows: <blockquote></dd>

<dt><b>shmem_wait, shmem_wait_until:</b>
default INTEGER </dt>
<dd></dd>

<dt><b>shmem_int4_wait, shmem_int4_wait_until:</b> INTEGER*4 </dt>
<dd></dd>

<dt><b>shmem_int8_wait,
shmem_int8_wait_until:</b> INTEGER*8 </dt>
<dd></dd>
</dl>
</blockquote>
<blockquote><p>
</blockquote>

<dl>

<dt>cmp </dt>
<dd>The compare operator that compares
ivar with cmp_value. cmp must be of type integer. If you are using Fortran,
it must be of default kind. If you are using C/C++, the type of cmp should
match that implied in the SYNOPSIS section. The following cmp values are
supported: <blockquote></dd>

<dt>SHMEM_CMP_EQ </dt>
<dd>Equal </dd>

<dt>SHMEM_CMP_NE </dt>
<dd>Not equal </dd>

<dt>SHMEM_CMP_GT </dt>
<dd>Greater
than </dd>

<dt>SHMEM_CMP_LE </dt>
<dd>Less than or equal to </dd>

<dt>SHMEM_CMP_LT </dt>
<dd>Less than </dd>

<dt>SHMEM_CMP_GE
</dt>
<dd></dd>
</dl>
Greater than or equal to </blockquote>
<blockquote><p>
</blockquote>

<dl>

<dt>cmp_value </dt>
<dd>cmp_value must be of type integer. If
you are using C/C++, the type of cmp_value should match thatimplied in
the SYNOPSIS section. If you are using Fortran, cmp_value must be an integer
of the same size and kind as ivar. The shmem_wait routines return when ivar
is no longer equal to cmp_value. The shmem_wait_until routines return when
the compare condition is true. The compare condition is defined by the ivar
argument compared with the cmp_value using the comparison operator, cmp.
</dd>
</dl>
<p>

<h2><a name='sect3' href='#toc3'>Examples</a></h2>

<p> <b>Example 1:</b> The following call returns when variable ivar is not
equal to 100: <br>
<pre>INTEGER*8 IVAR
CALL SHMEM_INT8_WAIT(IVAR, INT8(100))
</pre> <b>Example 2:</b> The following call to SHMEM_INT8_WAIT_UNTIL is equivalent to
the call to SHMEM_INT8_WAIT in example 1: <br>
<pre>INTEGER*8 IVAR
CALL SHMEM_INT8_WAIT_UNTIL(IVAR, SHMEM_CMP_NE, INT8(100))
</pre> <b>Example 3:</b> The following C/C++ call waits until the sign bit in ivar is
set by a transfer from a remote PE: <br>
<pre>int ivar;
shmem_int_wait_until(&amp;ivar, SHMEM_CMP_LT, 0);
</pre> <b>Example 4:</b> The following Fortran example is in the context of a subroutine:
<br>
<pre>SUBROUTINE EXAMPLE()
  INTEGER FLAG_VAR
  COMMON/FLAG/FLAG_VAR
  . . .
  FLAG_VAR = FLAG_VALUE ! initialize the event variable
  . . .
  IF (FLAG_VAR .EQ. FLAG_VALUE) THEN
    CALL SHMEM_WAIT(FLAG_VAR, FLAG_VALUE)
  ENDIF
  FLAG_VAR = FLAG_VALUE ! reset the event variable for next time
  . . .
END
</pre>
<h2><a name='sect4' href='#toc4'>See Also</a></h2>

<p> <i><i>intro_shmem</i>(3)</i>, <i><i>shmem_put</i>(3)</i>  <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Examples</a></li>
<li><a name='toc4' href='#sect4'>See Also</a></li>
</ul>


<p> <a href="../">&laquo; Return to documentation listing</a></p>
<?php
include_once("$topdir/includes/footer.inc");
