<?php
$topdir = "../../..";
$title = "shmem_putmem(3) man page (version 3.1.5)";
$meta_desc = "Open MPI v3.1.5 man page: shmem_putmem(3)";

include_once("$topdir/doc/nav.inc");
include_once("$topdir/includes/header.inc");
?>
<p> <a href="../">&laquo; Return to documentation listing</a></p>
    <!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>

<p> <i><i>shmem_character_put</i>(3)</i>, <i><i>shmem_complex_put</i>(3)</i>, <i><i>shmem_double_put</i>(3)</i>,
<i><i>shmem_float_put</i>(3)</i>, <i><i>shmem_int_put</i>(3)</i>, <i><i>shmem_integer_put</i>(3)</i>, <i><i>shmem_logical_put</i>(3)</i>,
<i><i>shmem_long_put</i>(3)</i>, <i><i>shmem_longdouble_put</i>(3)</i>, <i><i>shmem_longlong_put</i>(3)</i>, <i><i>shmem_put4</i>(3)</i>,
<i><i>shmem_put8</i>(3)</i>, <i><i>shmem_put32</i>(3)</i>, <i><i>shmem_put64</i>(3)</i>, <i><i>shmem_put128</i>(3)</i>, <i><i>shmem_putmem</i>(3)</i>,
<i><i>shmem_real_put</i>(3)</i>, <i><i>shmem_short_put</i>(3)</i> - Transfers data to a specified processing
element (PE)
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>

<p> C or C++: <br>
<pre>#include &lt;mpp/shmem.h&gt;
void shmem_double_put(double *target, const double *source,
  size_t len, int pe);
void shmem_float_put(float *target, const float *source,
  size_t len, int pe);
void shmem_int_put(int *target, const int *source, size_t len,
  int pe);
void shmem_long_put(long *target, const long *source,
  size_t len, int pe);
void shmem_longdouble_put(long double *target,
  const long double *source, size_t len, int pe);
void shmem_longlong_put(long long *target,
  const long long *source, size_t len, int pe);
void shmem_put32(void *target, const void *source, size_t len,
  int pe);
void shmem_put64(void *target, const void *source, size_t len,
  int pe);
void shmem_put128(void *target, const void *source, size_t len,
  int pe);
void shmem_putmem(void *target, const void *source, size_t len,
  int pe);
void shmem_short_put(short *target, const short *source,
  size_t len, int pe);
</pre> Fortran: <br>
<pre>INCLUDE "mpp/shmem.fh"
INTEGER len, pe
CALL SHMEM_CHARACTER_PUT(target, source, len, pe)
CALL SHMEM_COMPLEX_PUT(target, source, len, pe)
CALL SHMEM_DOUBLE_PUT(target, source, len, pe)
CALL SHMEM_INTEGER_PUT(target, source, len, pe)
CALL SHMEM_LOGICAL_PUT(target, source, len, pe)
CALL SHMEM_PUT(target, source, len, pe)
CALL SHMEM_PUT4(target, source, len, pe)
CALL SHMEM_PUT8(target, source, len, pe)
CALL SHMEM_PUT32(target, source, len, pe)
CALL SHMEM_PUT64(target, source, len, pe)
CALL SHMEM_PUT128(target, source, len, pe)
CALL SHMEM_PUTMEM(target, source, len, pe)
CALL SHMEM_REAL_PUT(target, source, len, pe)
</pre>
<h2><a name='sect2' href='#toc2'>Description</a></h2>

<p> These routines transfer <b>nelems</b> elements of the data object
at address <b>source</b> on the calling PE, to the data object at address <b>target</b>
on the remote PE <b>pe</b>. These routines start the remote transfer and may return
before the data is delivered to the remote PE. <p>
The delivery of data into
the data object on the destination PE from different put calls may occur
in any order. Because of this, two successive put operations may deliver
data out of order unless a call to <i><i>shmem_fence</i>(3)</i> is introduced between
the two calls. <p>
The arguments are as follows:
<dl>

<dt>target </dt>
<dd>Data object to be updated
on the remote PE. This data object must be remotely accessible. </dd>

<dt>source </dt>
<dd>Data
object containing the data to be copied. </dd>

<dt>len </dt>
<dd>Number of elements in the target
and source arrays. len must be of type integer. If you are using Fortran,
it must be a constant, variable, or array element of default integer type.
</dd>

<dt>pe </dt>
<dd>PE number of the remote PE. pe must be of type integer. If you are using
Fortran, it must be a constant, variable, or array element of default integer
type. </dd>
</dl>
<p>
The target and source data objects must conform to certain typing
constraints, which are as follows:
<dl>

<dt><b>shmem_putmem</b>: Fortran: Any noncharacter
type. C: Any data type. len is scaled in </dt>
<dd>bytes. </dd>

<dt><b>shmem_put4, shmem_put32:</b> Any
noncharacter type that has a storage size </dt>
<dd>equal to 32 bits. </dd>

<dt><b>shmem_put8,
shmem_put64:</b> Any noncharacter type that has a storage size </dt>
<dd>equal to 64
bits. </dd>

<dt><b>shmem_put128:</b> Any noncharacter type that has a storage size equal
to 128 </dt>
<dd>bits. </dd>

<dt><b>shmem_short_put:</b> Elements of type short. </dt>
<dd></dd>

<dt><b>shmem_int_put:</b> Elements
of type int. </dt>
<dd></dd>

<dt><b>shmem_long_put:</b> Elements of type long. </dt>
<dd></dd>

<dt><b>shmem_longlong_put:</b> Elements
of type long long. </dt>
<dd></dd>

<dt><b>shmem_float_put:</b> Elements of type float. </dt>
<dd></dd>

<dt><b>shmem_double_put:</b>
Elements of type double. </dt>
<dd></dd>

<dt><b>shmem_longdouble_put:</b> Elements of type long double.
</dt>
<dd></dd>

<dt><b>SHMEM_CHARACTER_PUT:</b> Elements of type character. len is the number of </dt>
<dd>characters
to transfer. The actual character lengths of the source and target variables
are ignored. </dd>

<dt><b>SHMEM_COMPLEX_PUT:</b> Elements of type complex of default size.
</dt>
<dd></dd>

<dt><b>SHMEM_DOUBLE_PUT:</b> (Fortran) Elements of type double precision. </dt>
<dd></dd>

<dt><b>SHMEM_INTEGER_PUT:</b>
Elements of type integer. </dt>
<dd></dd>

<dt><b>SHMEM_LOGICAL_PUT:</b> Elements of type logical. </dt>
<dd></dd>

<dt><b>SHMEM_REAL_PUT:</b>
Elements of type real. </dt>
<dd>If you are using Fortran, data types must be of default
size. For example, a real variable must be declared as REAL, REAL*4, or
REAL(KIND=4). </dd>
</dl>
<p>

<h2><a name='sect3' href='#toc3'>Examples</a></h2>

<p> The following shmem_put example is for C/C++ programs:
<br>
<pre>#include &lt;stdio.h&gt;
#include &lt;mpp/shmem.h&gt;
main()
{
  long source[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
  static long target[10];
  shmem_init();
  if (shmem_my_pe() == 0) {
    /* put 10 words into target on PE 1 */
    shmem_long_put(target, source, 10, 1);
  }
  shmem_barrier_all();  /* sync sender and receiver */
  if (shmem_my_pe() == 1)
    shmem_udcflush();  /* not required on Altix systems */
  printf("target[0] on PE %d is %d\n", shmem_my_pe(), target[0]);
}
</pre>
<h2><a name='sect4' href='#toc4'>See Also</a></h2>

<p> <i><i>intro_shmem</i>(3)</i>, <i><i>shmem_iput</i>(3)</i>, <i><i>shmem_quiet</i>(3)</i>  <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Examples</a></li>
<li><a name='toc4' href='#sect4'>See Also</a></li>
</ul>


<p> <a href="../">&laquo; Return to documentation listing</a></p>
<?php
include_once("$topdir/includes/footer.inc");
