<?php
$topdir = "../../..";
$title = "mpiexec(1) man page (version 1.6.4)";
$meta_desc = "Open MPI v1.6.4 man page: mpiexec(1)";

include_once("$topdir/doc/nav.inc");
include_once("$topdir/includes/header.inc");
?>
<p> <a href="../">&laquo; Return to documentation listing</a></p>
        <!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
 orterun, mpirun, mpiexec - Execute serial and parallel jobs
in Open MPI.
<p> <b>Note:</b> <i>mpirun</i>, <i>mpiexec</i>, and <i>orterun</i> are all synonyms for each
other.  Using any of the names will produce the same behavior.
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>

<p>
Single Process Multiple Data (SPMD) Model:
<p> <b>mpirun</b> [ options ]  <b>&lt;program&gt;</b>
[ &lt;args&gt; ] <p>

<p> Multiple Instruction Multiple Data (MIMD) Model:
<p> <b>mpirun</b> [ global_options
]        [ local_options1 ]<br>
 <b>&lt;program1&gt;</b> [ &lt;args1&gt; ] :        [ local_options2 ]<br>
 <b>&lt;program2&gt;</b> [ &lt;args2&gt; ] :         ... : <br>
        [ local_optionsN ]<br>
 <b>&lt;programN&gt;</b> [ &lt;argsN&gt; ] <p>

<p> Note that in both models, invoking <i>mpirun</i> via an absolute
path name is equivalent to specifying the <i>--prefix</i> option with a <i>&lt;dir&gt;</i> value
equivalent to the directory where <i>mpirun</i> resides, minus its last subdirectory.
 For example:
<p>     <b>%</b> /usr/local/bin/mpirun ...<br>

<p> is equivalent to
<p>     <b>%</b> mpirun --prefix /usr/local<br>

<p>
<h2><a name='sect2' href='#toc2'>Quick Summary</a></h2>
 If you are simply looking for how to run an MPI application,
you probably want to use a command line of the following form:
<p>     <b>%</b> mpirun
[ -np X ] [ --hostfile &lt;filename&gt; ]  &lt;program&gt;<br>

<p> This will run X copies of <i>&lt;program&gt;</i> in your current run-time environment
(if running under a supported resource manager, Open MPI&rsquo;s <i>mpirun</i> will usually
automatically use the corresponding resource manager process starter, as
opposed to, for example, <i>rsh</i> or <i>ssh</i>, which require the use of a hostfile,
or will default to running all X copies on the localhost), scheduling (by
default) in a round-robin fashion by CPU slot.  See the rest of this page
for more details.
<h2><a name='sect3' href='#toc3'>Options</a></h2>
 <i>mpirun</i> will send the name of the directory
where it was invoked on the local node to each of the remote nodes, and
attempt to change to that directory.  See the "Current Working Directory"
section below for further details.
<dl>

<dt><b>&lt;program&gt;</b> </dt>
<dd>The program executable. This
is identified as the first non-recognized argument to mpirun.   </dd>

<dt><b>&lt;args&gt;</b> </dt>
<dd>Pass
these run-time arguments to every new process.  These must always be the
last arguments to <i>mpirun</i>. If an app context file is used, <i>&lt;args&gt;</i> will be ignored.
  </dd>

<dt><b>-h, --help</b> </dt>
<dd>Display help for this command   </dd>

<dt><b>-q, --quiet</b> </dt>
<dd>Suppress informative
messages from orterun during application execution.   </dd>

<dt><b>-v, --verbose</b> </dt>
<dd>Be verbose
  </dd>

<dt><b>-V, --version</b> </dt>
<dd>Print version number.  If no other arguments are given, this
will also cause orterun to exit.     </dd>
</dl>
<p>
To specify which hosts (nodes) of the
cluster to run on:
<dl>

<dt><b>-H, -host, --host &lt;host1,host2,...,hostN&gt;</b> </dt>
<dd>List of hosts on
which to invoke processes.   </dd>

<dt><b></b> -hostfile, --hostfile &lt;hostfile&gt; </dt>
<dd>Provide a hostfile
to use.     </dd>

<dt><b>-machinefile, --machinefile &lt;machinefile&gt;</b> </dt>
<dd>Synonym for <i>-hostfile</i>.
  </dd>
</dl>
<p>
To specify the number of processes to launch:
<dl>

<dt><b>-c, -n, --n, -np &lt;#&gt;</b> </dt>
<dd>Run this
many copies of the program on the given nodes.  This option indicates that
the specified file is an executable program and not an application context.
If no value is provided for the number of copies to execute (i.e., neither
the "-np" nor its synonyms are provided on the command line), Open MPI will
automatically execute a copy of the program on each process slot (see below
for description of a "process slot"). This feature, however, can only be
used in the SPMD model and will return an error (without beginning execution
of the application) otherwise.    </dd>

<dt><b>-npersocket, --npersocket &lt;#persocket&gt;</b> </dt>
<dd>On each
node, launch this many processes times the number of processor sockets
on the node. The <i>-npersocket</i> option also turns on the <i>-bind-to-socket</i> option.
  </dd>

<dt><b>-npernode, --npernode &lt;#pernode&gt;</b> </dt>
<dd>On each node, launch this many processes.
  </dd>

<dt><b>-pernode, --pernode</b> </dt>
<dd>On each node, launch one process -- equivalent to <i>-npernode</i>
1.     </dd>
</dl>
<p>
To map processes to nodes:
<dl>

<dt><b>-loadbalance, --loadbalance</b> </dt>
<dd>Uniform distribution
of ranks across all nodes. See more detailed description below.  </dd>

<dt><b>-nolocal,
--nolocal</b> </dt>
<dd>Do not run any copies of the launched application on the same node
as orterun is running.  This option will override listing the localhost
with <b>--host</b> or any other host-specifying mechanism.  </dd>

<dt><b>-nooversubscribe, --nooversubscribe</b>
</dt>
<dd>Do not oversubscribe any nodes; error (without starting any processes)
if the requested number of processes would cause oversubscription. This
option implicitly sets "max_slots" equal to the "slots" value for each
node.  </dd>

<dt><b>-bynode, --bynode</b> </dt>
<dd>Launch processes one per node, cycling by node in
a round-robin fashion.  This spreads processes evenly among nodes and assigns
ranks in a round-robin, "by node" manner.     </dd>
</dl>
<p>
For process binding:
<dl>

<dt><b>-bycore,
--bycore</b> </dt>
<dd>Associate processes with successive cores if used with one of the
<i>-bind-to-*</i> options.  </dd>

<dt><b>-bysocket, --bysocket</b> </dt>
<dd>Associate processes with successive
processor sockets if used with one of the <i>-bind-to-*</i> options.  </dd>

<dt><b>-cpus-per-proc,
--cpus-per-proc &lt;#perproc&gt;</b> </dt>
<dd>Use the number of cores per process if used with one
of the <i>-bind-to-*</i> options.  </dd>

<dt><b>-cpus-per-rank, --cpus-per-rank &lt;#perrank&gt;</b> </dt>
<dd>Alias for <i>-cpus-per-proc</i>.
 </dd>

<dt><b>-bind-to-core, --bind-to-core</b> </dt>
<dd>Bind processes to cores.  </dd>

<dt><b>-bind-to-socket, --bind-to-socket</b>
</dt>
<dd>Bind processes to processor sockets.  </dd>

<dt><b>-bind-to-none, --bind-to-none</b> </dt>
<dd>Do not bind
processes.  (Default.)  </dd>

<dt><b>-report-bindings, --report-bindings</b> </dt>
<dd>Report any bindings
for launched processes.  </dd>

<dt><b>-slot-list, --slot-list &lt;slots&gt;</b> </dt>
<dd>List of processor IDs
to be used for binding MPI processes. The specified bindings will be applied
to all MPI processes. See explanation below for syntax.     </dd>
</dl>
<p>
For rankfiles:

<dl>

<dt><b>-rf, --rankfile &lt;rankfile&gt;</b> </dt>
<dd>Provide a rankfile file.     </dd>
</dl>
<p>
To manage standard
I/O:
<dl>

<dt><b>-output-filename, --output-filename &lt;filename&gt;</b> </dt>
<dd>Redirect the stdout, stderr,
and stddiag of all ranks to a rank-unique version of the specified filename.
Any directories in the filename will automatically be created. Each output
file will consist of filename.rank, where the rank will be left-filled with
zero&rsquo;s for correct ordering in listings.   </dd>

<dt><b>-stdin, --stdin &lt;rank&gt;</b> </dt>
<dd>The MPI rank
that is to receive stdin. The default is to forward stdin to rank=0, but
this option can be used to forward stdin to any rank. It is also acceptable
to specify <i>none</i>, indicating that no ranks are to receive stdin.   </dd>

<dt><b>-tag-output,
--tag-output</b> </dt>
<dd>Tag each line of output to stdout, stderr, and stddiag with <b>[jobid,
rank]&lt;stdxxx&gt;</b> indicating the process jobid and rank that generated the output,
and the channel which generated it.   </dd>

<dt><b>-timestamp-output, --timestamp-output</b> </dt>
<dd>Timestamp
each line of output to stdout, stderr, and stddiag.   </dd>

<dt><b>-xml, --xml</b> </dt>
<dd>Provide all
output to stdout, stderr, and stddiag in an xml format.   </dd>

<dt><b>-xterm, --xterm &lt;ranks&gt;</b>
</dt>
<dd>Display the specified ranks in separate xterm windows. The ranks are specified
as a comma-separated list of ranges, with a -1 indicating all. A separate
window will be created for each specified rank. <b>Note:</b> xterm will normally
terminate the window upon termination of the process running within it.
However, by adding a "!" to the end of the list of specified ranks, the
proper options will be provided to ensure that xterm keeps the window open
<i>after</i> the process terminates, thus allowing you to see the process&rsquo; output.
Each xterm window will subsequently need to be manually closed. <b>Note:</b> In
some environments, xterm may require that the executable be in the user&rsquo;s
path, or be specified in absolute or relative terms. Thus, it may be necessary
to specify a local executable as "./foo" instead of just "foo". If xterm
fails to find the executable, mpirun will hang, but still respond correctly
to a ctrl-c. If this happens, please check that the executable is being specified
correctly and try again.     </dd>
</dl>
<p>
To manage files and runtime environment:

<dl>

<dt><b>-path, --path &lt;path&gt;</b> </dt>
<dd>&lt;path&gt; that will be used when attempting to locate the requested
executables.  This is used prior to using the local PATH setting.   </dd>

<dt><b>--prefix
&lt;dir&gt;</b> </dt>
<dd>Prefix directory that will be used to set the <i>PATH</i> and <i>LD_LIBRARY_PATH</i>
on the remote node before invoking Open MPI or the target process.  See
the "Remote Execution" section, below.   </dd>

<dt><b>--preload-binary</b> </dt>
<dd>Copy the specified
executable(s) to remote machines prior to starting remote processes. The
executables will be copied to the Open MPI session directory and will be
deleted upon completion of the job.   </dd>

<dt><b>--preload-files &lt;files&gt;</b> </dt>
<dd>Preload the comma
separated list of files to the current working directory of the remote
machines where processes will be launched prior to starting those processes.
  </dd>

<dt><b>--preload-files-dest-dir &lt;path&gt;</b> </dt>
<dd>The destination directory to be used for preload-files,
if other than the current working directory. By default, the absolute and
relative paths provided by --preload-files are used.   </dd>

<dt><b>--tmpdir &lt;dir&gt;</b> </dt>
<dd>Set the root
for the session directory tree for mpirun only.   </dd>

<dt><b>-wd &lt;dir&gt;</b> </dt>
<dd>Synonym for <i>-wdir</i>.
  </dd>

<dt><b>-wdir &lt;dir&gt;</b> </dt>
<dd>Change to the directory &lt;dir&gt; before the user&rsquo;s program executes.
See the "Current Working Directory" section for notes on relative paths.
<b>Note:</b> If the <i>-wdir</i> option appears both on the command line and in an application
context, the context will take precedence over the command line. Thus, if
the path to the desired wdir is different on the backend nodes, then it
must be specified as an absolute path that is correct for the backend node.
  </dd>

<dt><b>-x &lt;env&gt;</b> </dt>
<dd>Export the specified environment variables to the remote nodes
before executing the program.  Only one environment variable can be specified
per <i>-x</i> option.  Existing environment variables can be specified or new variable
names specified with corresponding values.  For example:     <b>%</b> mpirun -x
DISPLAY -x OFILE=/tmp/out ...<br>

<p> The parser for the <i>-x</i> option is not very sophisticated; it does not even
understand quoted values.  Users are advised to set variables in the environment,
and then use <i>-x</i> to export (not define) them.     </dd>
</dl>
<p>
Setting MCA parameters:

<dl>

<dt><b>-gmca, --gmca &lt;key&gt; &lt;value&gt;</b> </dt>
<dd>Pass global MCA parameters that are applicable to
all contexts. <i>&lt;key&gt;</i> is the parameter name; <i>&lt;value&gt;</i> is the parameter value.
</dd>

<dt><b>-mca, --mca &lt;key&gt; &lt;value&gt;</b> </dt>
<dd>Send arguments to various MCA modules.  See the "MCA"
section, below.     </dd>
</dl>
<p>
For debugging:
<dl>

<dt><b>-debug, --debug</b> </dt>
<dd>Invoke the user-level debugger
indicated by the <i>orte_base_user_debugger</i> MCA parameter.   </dd>

<dt><b>-debugger, --debugger</b>
</dt>
<dd>Sequence of debuggers to search for when <i>--debug</i> is used (i.e. a synonym for
<i>orte_base_user_debugger</i> MCA parameter).   </dd>

<dt><b>-tv, --tv</b> </dt>
<dd>Launch processes under
the TotalView debugger. Deprecated backwards compatibility flag. Synonym
for <i>--debug</i>.     </dd>
</dl>
<p>
There are also other options:
<dl>

<dt><b>-aborted, --aborted &lt;#&gt;</b> </dt>
<dd>Set the
maximum number of aborted processes to display.   </dd>

<dt><b>--app &lt;appfile&gt;</b> </dt>
<dd>Provide an
appfile, ignoring all other command line options.   </dd>

<dt><b>-cf, --cartofile &lt;cartofile&gt;</b>
</dt>
<dd>Provide a cartography file.   </dd>

<dt><b>--hetero</b> </dt>
<dd>Indicates that multiple app_contexts
are being provided that are a mix of 32/64-bit binaries.   </dd>

<dt><b>-leave-session-attached,
--leave-session-attached</b> </dt>
<dd>Do not detach OmpiRTE daemons used by this application.
This allows error messages from the daemons as well as the underlying environment
(e.g., when failing to launch a daemon) to be output.   </dd>

<dt><b>-ompi-server, --ompi-server
&lt;uri or file&gt;</b> </dt>
<dd>Specify the URI of the Open MPI server (or the mpirun to be
used as the server) , the name of the file (specified as file:filename)
that contains that info, or the PID (specified as pid:#) of the mpirun
to be used as  the server.<br>
 The Open MPI server is used to support multi-application data exchange
via the MPI-2 <a href="../man3/MPI_Publish_name.3.php">MPI_Publish_name</a> and <a href="../man3/MPI_Lookup_name.3.php">MPI_Lookup_name</a> functions.   </dd>

<dt><b>-report-pid,
--report-pid &lt;channel&gt;</b> </dt>
<dd>Print out mpirun&rsquo;s PID during startup. The channel must
be either a &rsquo;-&rsquo; to indi cate that the pid is to be output to stdout, a &rsquo;+&rsquo; to
indicate that the pid is to be outp ut to stderr, or a filename to which
the pid is to be written.   </dd>

<dt><b>-report-uri, --report-uri &lt;channel&gt;</b> </dt>
<dd>Print out mpirun&rsquo;s
URI during startup. The channel must be either a &rsquo;-&rsquo; to indi cate that the
URI is to be output to stdout, a &rsquo;+&rsquo; to indicate that the URI is to be outp
ut to stderr, or a filename to which the URI is to be written.   </dd>

<dt><b>-wait-for-server,
--wait-for-server</b> </dt>
<dd>Pause mpirun before launching the job until ompi-server is
detected. This is useful in scripts where ompi-server may be started in the
background, followed immediately by an <i>mpirun</i> command that wishes to connect
to it. Mpirun will pause until either the specified ompi-server is contacted
or the server-wait-time is exceeded.   </dd>

<dt><b>-server-wait-time, --server-wait-time &lt;secs&gt;</b>
</dt>
<dd>The max amount of time (in seconds) mpirun should wait for the ompi-server
to start. The default is 10 seconds.     </dd>
</dl>
<p>
The following options are useful
for developers; they are not generally useful to most ORTE and/or MPI users:

<dl>

<dt><b>-d, --debug-devel</b> </dt>
<dd>Enable debugging of the OmpiRTE (the run-time layer in Open
MPI). This is not generally useful for most users.   </dd>

<dt><b>--debug-daemons</b> </dt>
<dd>Enable
debugging of any OmpiRTE daemons used by this application.   </dd>

<dt><b>--debug-daemons-file</b>
</dt>
<dd>Enable debugging of any OmpiRTE daemons used by this application, storing
output in files.   </dd>

<dt><b>-launch-agent, --launch-agent</b> </dt>
<dd>Name of the executable that
is to be used to start processes on the remote nodes. The default is "orted".
This option can be used to test new daemon concepts, or to pass options
back to the daemons without having mpirun itself see them. For example,
specifying a launch agent of orted -mca odls_base_verbose 5 allows the developer
to ask the orted for debugging output without clutter from mpirun itself.
  </dd>

<dt><b>--noprefix</b> </dt>
<dd>Disable the automatic --prefix behavior   </dd>
</dl>
<p>
There may be other options
listed with <i>mpirun --help</i>.
<h2><a name='sect4' href='#toc4'>Description</a></h2>
 One invocation of <i>mpirun</i> starts
an MPI application running under Open MPI. If the application is single
process multiple data (SPMD), the application can be specified on the <i>mpirun</i>
command line.
<p> If the application is multiple instruction multiple data
(MIMD), comprising of multiple programs, the set of programs and argument
can be specified in one of two ways: Extended Command Line Arguments, and
Application Context. <p>
An application context describes the MIMD program set
including all arguments in a separate file.  This file essentially contains
multiple <i>mpirun</i> command lines, less the command name itself.  The ability
to specify different options for different instantiations of a program
is another reason to use an application context. <p>
Extended command line arguments
allow for the description of the application layout on the command line
using colons (<i>:</i>) to separate the specification of programs and arguments.
Some options are globally set across all specified programs (e.g. --hostfile),
while others are specific to a single program (e.g. -np).
<h3><a name='sect5' href='#toc5'>Specifying Host
Nodes</a></h3>
 Host nodes can be identified on the <i>mpirun</i> command line with the
<i>-host</i> option or in a hostfile.  <p>
For example,
<dl>

<dt>mpirun -H aa,aa,bb ./a.out </dt>
<dd>launches
two processes on node aa and one on bb.  </dd>
</dl>
<p>
Or, consider the hostfile
<p>
<b>%</b> cat myhostfile<br>
    aa slots=2<br>
    bb slots=2<br>
    cc slots=2<br>

<p>  <p>
Here, we list both the host names (aa, bb, and cc) but also how many
"slots" there are for each.  Slots indicate how many processes can potentially
execute on a node.  For best performance, the number of slots may be chosen
to be the number of cores on the node or the number of processor sockets.
 If the hostfile does not provide slots information, a default of 1 is
assumed. When running under resource managers (e.g., SLURM, Torque, etc.),
Open MPI will obtain both the hostnames and the number of slots directly
from the resource manger.  <p>

<dl>

<dt>mpirun -hostfile myhostfile ./a.out </dt>
<dd>will launch
two processes on each of the three nodes.  </dd>

<dt>mpirun -hostfile myhostfile -host
aa ./a.out </dt>
<dd>will launch two processes, both on node aa.  </dd>

<dt>mpirun -hostfile myhostfile
-host dd ./a.out </dt>
<dd>will find no hosts to run on and abort with an error. That
is, the specified host dd is not in the specified hostfile.  </dd>
</dl>

<h3><a name='sect6' href='#toc6'>Specifying
Number of Processes</a></h3>
 As we have just seen, the number of processes to run
can be set using the hostfile.  Other mechanisms exist.  <p>
The number of processes
launched can be specified as a multiple of the number of nodes or processor
sockets available.  For example,
<dl>

<dt>mpirun -H aa,bb -npersocket 2 ./a.out </dt>
<dd>launches
processes 0-3 on node aa and process 4-7 on node bb, where aa and bb are
both dual-socket nodes. The <i>-npersocket</i> option also turns on the <i>-bind-to-socket</i>
option, which is discussed in a later section.  </dd>

<dt>mpirun -H aa,bb -npernode
2 ./a.out </dt>
<dd>launches processes 0-1 on node aa and processes 2-3 on node bb.  </dd>

<dt>mpirun
-H aa,bb -npernode 1 ./a.out </dt>
<dd>launches one process per host node.  </dd>

<dt>mpirun -H aa,bb
-pernode ./a.out </dt>
<dd>is the same as <i>-npernode</i> 1.   </dd>
</dl>
<p>
Another alternative is to specify
the number of processes with the <i>-np</i> option.  Consider now the hostfile

<p>    <b>%</b> cat myhostfile<br>
    aa slots=4<br>
    bb slots=4<br>
    cc slots=4<br>

<p>  <p>
Now,
<dl>

<dt>mpirun -hostfile myhostfile -np 6 ./a.out </dt>
<dd>will launch ranks 0-3 on
node aa and ranks 4-5 on node bb.  The remaining slots in the hostfile will
not be used since the <i>-np</i> option indicated that only 6 processes should
be launched.  </dd>
</dl>

<h3><a name='sect7' href='#toc7'>Mapping Processes to Nodes</a></h3>
 The examples above illustrate the
default mapping of process ranks to nodes.  This mapping can also be controlled
with various <i>mpirun</i> options.  Here, we consider the same hostfile as above
with <i>-np</i> 6 again:
<p>                           node aa      node bb
node cc<br>

<p>   mpirun                  0 1 2 3      4 5<br>

<p>   mpirun -loadbalance     0 1          2 3          4 5<br>

<p>   mpirun -bynode          0 3          1 4          2 5<br>

<p>   mpirun -nolocal                      0 1 2 3      4 5<br>
  <p>
The <i>-loadbalance</i> option tries to spread processes out fairly among the
nodes.  <p>
The <i>-bynode</i> option does likewise but numbers the processes in "by
node" in a round-robin fashion.  <p>
The <i>-nolocal</i> option prevents any processes
from being mapped onto the local host (in this case node aa).  While <i>mpirun</i>
typically consumes few system resources, <i>-nolocal</i> can be helpful for launching
very large jobs where <i>mpirun</i> may actually need to use noticeable amounts
of memory and/or processing time.  <p>
Just as <i>-np</i> can specify fewer processes
than there are slots, it can also oversubscribe the slots.  For example,
with the same hostfile:
<dl>

<dt>mpirun -hostfile myhostfile -np 14 ./a.out </dt>
<dd>will launch
processes 0-3 on node aa, 4-7 on bb, and 8-11 on cc.  It will then add the
remaining two processes to whichever nodes it chooses.  </dd>
</dl>
<p>
One can also specify
limits to oversubscription.  For example, with the same hostfile:
<dl>

<dt>mpirun
-hostfile myhostfile -np 14 -nooversubscribe ./a.out </dt>
<dd>will produce an error since
<i>-nooversubscribe</i> prevents oversubscription.  </dd>
</dl>
<p>
Limits to oversubscription can
also be specified in the hostfile itself:   % cat myhostfile<br>
  aa slots=4 max_slots=4<br>
  bb         max_slots=4<br>
  cc slots=4<br>
  <p>
The <i>max_slots</i> field specifies such a limit.  When it does, the <i>slots</i> value
defaults to the limit.  Now:
<dl>

<dt>mpirun -hostfile myhostfile -np 14 ./a.out </dt>
<dd>causes
the first 12 processes to be launched as before, but the remaining two
processes will be forced onto node cc.  The other two nodes are protected
by the hostfile against oversubscription by this job.  </dd>
</dl>
<p>
Using the <i>--nooversubscribe</i>
option can be helpful since Open MPI currently does not get "max_slots"
values from the resource manager.  <p>
Of course, <i>-np</i> can also be used with the
<i>-H</i> or <i>-host</i> option.  For example,
<dl>

<dt>mpirun -H aa,bb -np 8 ./a.out </dt>
<dd>launches 8 processes.
 Since only two hosts are specified, after the first two processes are
mapped, one to aa and one to bb, the remaining processes oversubscribe
the specified hosts.  </dd>
</dl>
<p>
And here is a MIMD example:
<dl>

<dt>mpirun -H aa -np 1 hostname
: -H bb,cc -np 2 uptime </dt>
<dd>will launch process 0 running <i>hostname</i> on node aa
and processes 1 and 2 each running <i>uptime</i> on nodes bb and cc, respectively.
 </dd>
</dl>

<h3><a name='sect8' href='#toc8'>Process Binding</a></h3>
 Processes may be bound to specific resources on a node.
 This can improve performance if the operating system is placing processes
suboptimally.  For example, it might oversubscribe some multi-core processor
sockets, leaving other sockets idle;  this can lead processes to contend
unnecessarily for common resources.  Or, it might spread processes out too
widely;  this can be suboptimal if application performance is sensitive
to interprocess communication costs.  Binding can also keep the operating
system from migrating processes excessively, regardless of how optimally
those processes were placed to begin with.  <p>
To bind processes, one must
first associate them with the resources on which they should run.  For example,
the <i>-bycore</i> option associates the processes on a node with successive cores.
 Or, <i>-bysocket</i> associates the processes with successive processor sockets,
cycling through the sockets in a round-robin fashion if necessary. And <i>-cpus-per-proc</i>
indicates how many cores to bind per process.  <p>
But, such association is
meaningless unless the processes are actually bound to those resources.
 The binding option specifies the granularity of binding -- say, with <i>-bind-to-core</i>
or <i>-bind-to-socket</i>. One can also turn binding off with <i>-bind-to-none</i>, which is
typically the default.  <p>
Finally, <i>-report-bindings</i> can be used to report bindings.
 <p>
As an example, consider a node with two processor sockets, each comprising
four cores.  We run <i>mpirun</i> with <i>-np 4 -report-bindings</i> and the following additional
options:
<p>  % mpirun ... -bycore -bind-to-core<br>
  [...] ... binding child [...,0] to cpus 0001<br>
  [...] ... binding child [...,1] to cpus 0002<br>
  [...] ... binding child [...,2] to cpus 0004<br>
  [...] ... binding child [...,3] to cpus 0008<br>

<p>  % mpirun ... -bysocket -bind-to-socket<br>
  [...] ... binding child [...,0] to socket 0 cpus 000f<br>
  [...] ... binding child [...,1] to socket 1 cpus 00f0<br>
  [...] ... binding child [...,2] to socket 0 cpus 000f<br>
  [...] ... binding child [...,3] to socket 1 cpus 00f0<br>

<p>  % mpirun ... -cpus-per-proc 2 -bind-to-core<br>
  [...] ... binding child [...,0] to cpus 0003<br>
  [...] ... binding child [...,1] to cpus 000c<br>
  [...] ... binding child [...,2] to cpus 0030<br>
  [...] ... binding child [...,3] to cpus 00c0<br>

<p>  % mpirun ... -bind-to-none<br>
  <p>
Here, <i>-report-bindings</i> shows the binding of each process as a mask. In the
first case, the processes bind to successive cores as indicated by the
masks 0001, 0002, 0004, and 0008.  In the second case, processes bind to
all cores on successive sockets as indicated by the masks 000f and 00f0.
The processes cycle through the processor sockets in a round-robin fashion
as many times as are needed.  In the third case, the masks show us that
2 cores have been bind per process.  In the fourth case, binding is turned
off and no bindings are reported.  <p>
Open MPI&rsquo;s support for process binding
depends on the underlying operating system.  Therefore, processing binding
may not be available on every system.  <p>
Process binding can also be set with
MCA parameters. Their usage is less convenient than that of <i>mpirun</i> options.
On the other hand, MCA parameters can be set not only on the <i>mpirun</i> command
line, but alternatively in a system or user mca-params.conf file or as environment
variables, as described in the MCA section below. The correspondences are:

<p>   mpirun option          MCA parameter key           value<br>

<p>   -bycore                rmaps_base_schedule_policy  core<br>
   -bysocket              rmaps_base_schedule_policy  socket<br>
   -bind-to-core          orte_process_binding        core<br>
   -bind-to-socket        orte_process_binding        socket<br>
   -bind-to-none          orte_process_binding        none<br>
  <p>
The <i>orte_process_binding</i> value can also take on the <i>:if-avail</i> attribute.
 This attribute means that processes will be bound only if this is supported
on the underlying operating system.  Without the attribute, if there is
no such support, the binding request results in an error. For example, you
could have
<p>   % cat $HOME/.openmpi/mca-params.conf<br>
   rmaps_base_schedule_policy = socket<br>
   orte_process_binding       = socket:if-avail<br>

<h3><a name='sect9' href='#toc9'>Rankfiles</a></h3>
 Rankfiles provide a means for specifying detailed information
about how process ranks should be mapped to nodes and how they should be
bound. Consider the following:
<p>     cat myrankfile<br>
     rank 0=aa slot=1:0-2<br>
     rank 1=bb slot=0:0,1<br>
     rank 2=cc slot=1-2<br>
     mpirun -H aa,bb,cc,dd -rf myrankfile ./a.out<br>
  <p>
So that    Rank 0 runs on node aa, bound to socket 1, cores 0-2.<br>
   Rank 1 runs on node bb, bound to socket 0, cores 0 and 1.<br>
   Rank 2 runs on node cc, bound to cores 1 and 2.<br>
  <p>
Note that all slot locations are to be specified as <i>physical</i> indexes.
 You can use tools such as HWLOC&rsquo;s "lstopo -v" to find the physical indexes
of socket and cores.
<h3><a name='sect10' href='#toc10'>Application Context or Executable Program?</a></h3>
 To distinguish
the two different forms, <i>mpirun</i> looks on the command line for <i>--app</i> option.
 If it is specified, then the file named on the command line is assumed
to be an application context.  If it is not specified, then the file is
assumed to be an executable program.
<h3><a name='sect11' href='#toc11'>Locating Files</a></h3>
 If no relative or
absolute path is specified for a file, Open MPI will first look for files
by searching the directories specified by the <i>--path</i> option.  If there is
no <i>--path</i> option set or if the file is not found at the <i>--path</i> location, then
Open MPI will search the user&rsquo;s PATH environment variable as defined on
the source node(s). <p>
If a relative directory is specified, it must be relative
to the initial working directory determined by the specific starter used.
For example when using the rsh or ssh starters, the initial directory is
$HOME by default. Other starters may set the initial directory to the current
working directory from the invocation of <i>mpirun</i>.
<h3><a name='sect12' href='#toc12'>Current Working Directory</a></h3>

The <i>-wdir</i> mpirun option (and its synonym, <i>-wd</i>) allows the user to change
to an arbitrary directory before the program is invoked.  It can also be
used in application context files to specify working directories on specific
nodes and/or for specific applications. <p>
If the <i>-wdir</i> option appears both
in a context file and on the command line, the context file directory will
override the command line value. <p>
If the <i>-wdir</i> option is specified, Open MPI
will attempt to change to the specified directory on all of the remote
nodes. If this fails, <i>mpirun</i> will abort. <p>
If the <i>-wdir</i> option is <b>not</b> specified,
Open MPI will send the directory name where <i>mpirun</i> was invoked to each
of the remote nodes. The remote nodes will try to change to that directory.
If they are unable (e.g., if the directory does not exist on that node),
then Open MPI will use the default directory determined by the starter.
<p>
All directory changing occurs before the user&rsquo;s program is invoked; it does
not wait until <i><a href="../man3/MPI_Init.3.php">MPI_INIT</a></i> is called.
<h3><a name='sect13' href='#toc13'>Standard I/O</a></h3>
 Open MPI directs UNIX
standard input to /dev/null on all processes except the MPI_COMM_WORLD
rank 0 process. The MPI_COMM_WORLD rank 0 process inherits standard input
from <i>mpirun</i>. <b>Note:</b> The node that invoked <i>mpirun</i> need not be the same as
the node where the MPI_COMM_WORLD rank 0 process resides. Open MPI handles
the redirection of <i>mpirun</i>&rsquo;s standard input to the rank 0 process. <p>
Open MPI
directs UNIX standard output and error from remote nodes to the node that
invoked <i>mpirun</i> and prints it on the standard output/error of <i>mpirun</i>. Local
processes inherit the standard output/error of <i>mpirun</i> and transfer to it
directly. <p>
Thus it is possible to redirect standard I/O for Open MPI applications
by using the typical shell redirection procedure on <i>mpirun</i>.
<p>       <b>%</b> mpirun
-np 2 my_app &lt; my_input &gt; my_output<br>

<p> Note that in this example <i>only</i> the MPI_COMM_WORLD rank 0 process will
receive the stream from <i>my_input</i> on stdin.  The stdin on all the other nodes
will be tied to /dev/null.  However, the stdout from all nodes will be collected
into the <i>my_output</i> file.
<h3><a name='sect14' href='#toc14'>Signal Propagation</a></h3>
 When orterun receives a
SIGTERM and SIGINT, it will attempt to kill the entire job by sending all
processes in the job a SIGTERM, waiting a small number of seconds, then
sending all processes in the job a SIGKILL.  <p>
SIGUSR1 and SIGUSR2 signals
received by orterun are propagated to all processes in the job.  <p>
One can
turn on forwarding of SIGSTOP and SIGCONT to the program executed by mpirun
by setting the MCA parameter orte_forward_job_control to 1. A SIGTSTOP signal
to mpirun will then cause a SIGSTOP signal to be sent to all of the programs
started by mpirun and likewise a SIGCONT signal to mpirun will cause a
SIGCONT sent.  <p>
Other signals are not currently propagated by orterun.
<h3><a name='sect15' href='#toc15'>Process
Termination / Signal Handling</a></h3>
 During the run of an MPI application, if
any rank dies abnormally (either exiting before invoking <i><a href="../man3/MPI_Finalize.3.php">MPI_FINALIZE</a></i>,
or dying as the result of a signal), <i>mpirun</i> will print out an error message
and kill the rest of the MPI application. <p>
User signal handlers should probably
avoid trying to cleanup MPI state (Open MPI is currently not async-signal-safe;
see <i><a href="../man3/MPI_Init_thread.3.php">MPI_Init_thread</a>(3)</i> for details about  <i>MPI_THREAD_MULTIPLE</i>  and thread
safety).  For example, if a segmentation fault occurs in <i><a href="../man3/MPI_Send.3.php">MPI_SEND</a></i> (perhaps
because a bad buffer was passed in) and a user signal handler is invoked,
if this user handler attempts to invoke <i><a href="../man3/MPI_Finalize.3.php">MPI_FINALIZE</a></i>, Bad Things could
happen since Open MPI was already "in" MPI when the error occurred.  Since
<i>mpirun</i> will notice that the process died due to a signal, it is probably
not necessary (and safest) for the user to only clean up non-MPI state.

<h3><a name='sect16' href='#toc16'>Process Environment</a></h3>
 Processes in the MPI application inherit their environment
from the Open RTE daemon upon the node on which they are running.  The environment
is typically inherited from the user&rsquo;s shell.  On remote nodes, the exact
environment is determined by the boot MCA module used.  The <i>rsh</i> launch module,
for example, uses either <i>rsh</i>/<i>ssh</i> to launch the Open RTE daemon on remote
nodes, and typically executes one or more of the user&rsquo;s shell-setup files
before launching the Open RTE daemon.  When running dynamically linked applications
which require the <i>LD_LIBRARY_PATH</i> environment variable to be set, care
must be taken to ensure that it is correctly set when booting Open MPI.
<p>
See the "Remote Execution" section for more details.
<h3><a name='sect17' href='#toc17'>Remote Execution</a></h3>

Open MPI requires that the <i>PATH</i> environment variable be set to find executables
on remote nodes (this is typically only necessary in <i>rsh</i>- or <i>ssh</i>-based environments
-- batch/scheduled environments typically copy the current environment to
the execution of remote jobs, so if the current environment has <i>PATH</i> and/or
<i>LD_LIBRARY_PATH</i> set properly, the remote nodes will also have it set properly).
 If Open MPI was compiled with shared library support, it may also be necessary
to have the <i>LD_LIBRARY_PATH</i> environment variable set on remote nodes as
well (especially to find the shared libraries required to run user MPI
applications). <p>
However, it is not always desirable or possible to edit shell
startup files to set <i>PATH</i> and/or <i>LD_LIBRARY_PATH</i>.  The <i>--prefix</i> option is
provided for some simple configurations where this is not possible. <p>
The
<i>--prefix</i> option takes a single argument: the base directory on the remote
node where Open MPI is installed.  Open MPI will use this directory to set
the remote <i>PATH</i> and <i>LD_LIBRARY_PATH</i> before executing any Open MPI or user
applications.  This allows running Open MPI jobs without having pre-configured
the <i>PATH</i> and <i>LD_LIBRARY_PATH</i> on the remote nodes. <p>
Open MPI adds the basename
of the current node&rsquo;s "bindir" (the directory where Open MPI&rsquo;s executables
are installed) to the prefix and uses that to set the <i>PATH</i> on the remote
node.  Similarly, Open MPI adds the basename of the current node&rsquo;s "libdir"
(the directory where Open MPI&rsquo;s libraries are installed) to the prefix and
uses that to set the <i>LD_LIBRARY_PATH</i> on the remote node.  For example:
<dl>

<dt>Local
bindir: </dt>
<dd>/local/node/directory/bin </dd>

<dt>Local libdir: </dt>
<dd>/local/node/directory/lib64
</dd>
</dl>
<p>
If the following command line is used:
<p>     <b>%</b> mpirun --prefix /remote/node/directory<br>

<p> Open MPI will add "/remote/node/directory/bin" to the <i>PATH</i> and "/remote/node/directory/lib64"
to the D_LIBRARY_PATH on the remote node before attempting to execute anything.
<p>
The <i>--prefix</i> option is not sufficient if the installation paths on the remote
node are different than the local node (e.g., if "/lib" is used on the local
node, but "/lib64" is used on the remote node), or if the installation
paths are something other than a subdirectory under a common prefix.   <p>
Note
that executing <i>mpirun</i> via an absolute pathname is equivalent to specifying
<i>--prefix</i> without the last subdirectory in the absolute pathname to <i>mpirun</i>.
 For example:
<p>     <b>%</b> /usr/local/bin/mpirun ...<br>

<p> is equivalent to
<p>     <b>%</b> mpirun --prefix /usr/local<br>

<h3><a name='sect18' href='#toc18'>Exported Environment Variables</a></h3>
 All environment variables that are named
in the form OMPI_* will automatically be exported to new processes on the
local and remote nodes. The <i>-x</i> option to <i>mpirun</i> can be used to export specific
environment variables to the new processes.  While the syntax of the <i>-x</i> option
allows the definition of new variables, note that the parser for this option
is currently not very sophisticated - it does not even understand quoted
values.  Users are advised to set variables in the environment and use <i>-x</i>
to export them; not to define them.
<h3><a name='sect19' href='#toc19'>Setting MCA Parameters</a></h3>
 The <i>-mca</i> switch
allows the passing of parameters to various MCA (Modular Component Architecture)
modules.  MCA modules have direct impact on MPI programs because they allow
tunable parameters to be set at run time (such as which BTL communication
device driver to use, what parameters to pass to that BTL, etc.). <p>
The <i>-mca</i>
switch takes two arguments: <i>&lt;key&gt;</i> and <i>&lt;value&gt;</i>. The <i>&lt;key&gt;</i> argument generally specifies
which MCA module will receive the value. For example, the <i>&lt;key&gt;</i> "btl" is used
to select which BTL to be used for transporting MPI messages.  The <i>&lt;value&gt;</i>
argument is the value that is passed. For example:
<dl>

<dt>mpirun -mca btl tcp,self
-np 1 foo </dt>
<dd>Tells Open MPI to use the "tcp" and "self" BTLs, and to run a
single copy of "foo" an allocated node.  </dd>

<dt>mpirun -mca btl self -np 1 foo </dt>
<dd>Tells
Open MPI to use the "self" BTL, and to run a single copy of "foo" an allocated
node.  </dd>
</dl>
<p>
The <i>-mca</i> switch can be used multiple times to specify different <i>&lt;key&gt;</i>
and/or <i>&lt;value&gt;</i> arguments.  If the same <i>&lt;key&gt;</i> is specified more than once, the
<i>&lt;value&gt;</i>s are concatenated with a comma (",") separating them. <p>
Note that the
<i>-mca</i> switch is simply a shortcut for setting environment variables. The same
effect may be accomplished by setting corresponding environment variables
before running <i>mpirun</i>. The form of the environment variables that Open MPI
sets is:
<p>       OMPI_MCA_&lt;key&gt;=&lt;value&gt;<br>
 <p>
Thus, the <i>-mca</i> switch overrides any previously set environment variables.
 The <i>-mca</i> settings similarly override MCA parameters set in the $OPAL_PREFIX/etc/openmpi-mca-params.conf
or $HOME/.openmpi/mca-params.conf file.  <p>
Unknown <i>&lt;key&gt;</i> arguments are still set
as environment variable -- they are not checked (by <i>mpirun</i>) for correctness.
Illegal or incorrect <i>&lt;value&gt;</i> arguments may or may not be reported -- it depends
on the specific MCA module. <p>
To find the available component types under
the MCA architecture, or to find the available parameters for a specific
component, use the <i>ompi_info</i> command. See the <i><i>ompi_info(1)</i></i> man page for
detailed information on the command.
<h3><a name='sect20' href='#toc20'>Exit status</a></h3>
 There is no standard definition
for what <i>mpirun</i> should return as an exit status. After considerable discussion,
we settled on the following method for assigning the <i>mpirun</i> exit status
(note: in the following description, the "primary" job is the initial application
started by mpirun - all jobs that are spawned by that job are designated
"secondary" jobs):
<dl>

<dt>[bu]</dt>
<dd>if all processes in the primary job normally terminate
with exit status 0, we return 0 </dd>

<dt>[bu]</dt>
<dd>if one or more processes in the primary
job normally terminate with non-zero exit status,  we return the exit status
of the lowest rank to have a non-zero status </dd>

<dt>[bu]</dt>
<dd>if all processes in the
primary job normally terminate with exit status 0, and one or more processes
in a secondary job normally terminate with non-zero exit status, we (a)
return the exit status of the lowest rank in the lowest jobid to have a
non-zero status, and (b) output a message summarizing the exit status of
the primary and all secondary jobs. </dd>

<dt>[bu]</dt>
<dd>if the cmd line option --report-child-jobs-separately
is set, we will return -only- the exit status of the primary job. Any non-zero
exit status in secondary jobs will be reported solely in a summary print
statement.  </dd>
</dl>
<p>
By default, OMPI records and notes that MPI processes exited
with non-zero termination status. This is generally not considered an "abnormal
termination" - i.e., OMPI will not abort an MPI job if one or more processes
return a non-zero status. Instead, the default behavior simply reports the
number of processes terminating with non-zero status upon completion of
the job. <p>
However, in some cases it can be desirable to have the job abort
when any process terminates with non-zero status. For example, a non-MPI job
might detect a bad result from a calculation and want to abort, but doesn&rsquo;t
want to generate a core file. Or an MPI job might continue past a call to
<a href="../man3/MPI_Finalize.3.php">MPI_Finalize</a>, but indicate that all processes should abort due to some
post-MPI result. <p>
It is not anticipated that this situation will occur frequently.
However, in the interest of serving the broader community, OMPI now has
a means for allowing users to direct that jobs be aborted upon any process
exiting with non-zero status. Setting the MCA parameter "orte_abort_on_non_zero_status"
to 1 will cause OMPI to abort all processes once any process  exits with
non-zero status.<br>
 <p>
Terminations caused in this manner will be reported on the console as
an "abnormal termination", with the first process to so exit identified
along with its exit status. <p>

<h2><a name='sect21' href='#toc21'>Examples</a></h2>
Be sure also to see the examples
throughout the sections above.
<dl>

<dt>mpirun -np 4 -mca btl ib,tcp,self prog1 </dt>
<dd>Run
4 copies of prog1 using the "ib", "tcp", and "self" BTL&rsquo;s for the transport
of MPI messages.   </dd>

<dt>mpirun -np 4 -mca btl tcp,sm,self  </dt>
<dd><br>
--mca btl_tcp_if_include eth0 prog1 <br>
Run 4 copies of prog1 using the "tcp", "sm" and "self" BTLs for the transport
of MPI messages, with TCP using only the eth0 interface to communicate.
 Note that other BTLs have similar if_include MCA parameters.
    </dd>
</dl>

<h2><a name='sect22' href='#toc22'>Return Value</a></h2>
 <i>mpirun</i> returns 0 if all ranks started by <i>mpirun</i> exit after
calling <a href="../man3/MPI_Finalize.3.php">MPI_FINALIZE</a>.  A non-zero value is returned if an internal error
occurred in mpirun, or one or more ranks exited before calling <a href="../man3/MPI_Finalize.3.php">MPI_FINALIZE</a>.
 If an internal error occurred in mpirun, the corresponding error code
is returned. In the event that one or more ranks exit before calling <a href="../man3/MPI_Finalize.3.php">MPI_FINALIZE</a>,
the return value of the rank of the process that <i>mpirun</i> first notices died
before calling <a href="../man3/MPI_Finalize.3.php">MPI_FINALIZE</a> will be returned.  Note that, in general, this
will be the first rank that died but is not guaranteed to be so.
<h2><a name='sect23' href='#toc23'>See
Also</a></h2>
<i><a href="../man3/MPI_Init_thread.3.php">MPI_Init_thread</a>(3)</i> <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Quick Summary</a></li>
<li><a name='toc3' href='#sect3'>Options</a></li>
<li><a name='toc4' href='#sect4'>Description</a></li>
<ul>
<li><a name='toc5' href='#sect5'>Specifying Host Nodes</a></li>
<li><a name='toc6' href='#sect6'>Specifying Number of Processes</a></li>
<li><a name='toc7' href='#sect7'>Mapping Processes to Nodes</a></li>
<li><a name='toc8' href='#sect8'>Process Binding</a></li>
<li><a name='toc9' href='#sect9'>Rankfiles</a></li>
<li><a name='toc10' href='#sect10'>Application Context or Executable Program?</a></li>
<li><a name='toc11' href='#sect11'>Locating Files</a></li>
<li><a name='toc12' href='#sect12'>Current Working Directory</a></li>
<li><a name='toc13' href='#sect13'>Standard I/O</a></li>
<li><a name='toc14' href='#sect14'>Signal Propagation</a></li>
<li><a name='toc15' href='#sect15'>Process Termination / Signal Handling</a></li>
<li><a name='toc16' href='#sect16'>Process Environment</a></li>
<li><a name='toc17' href='#sect17'>Remote Execution</a></li>
<li><a name='toc18' href='#sect18'>Exported Environment Variables</a></li>
<li><a name='toc19' href='#sect19'>Setting MCA Parameters</a></li>
<li><a name='toc20' href='#sect20'>Exit status</a></li>
</ul>
<li><a name='toc21' href='#sect21'>Examples</a></li>
<li><a name='toc22' href='#sect22'>Return Value</a></li>
<li><a name='toc23' href='#sect23'>See Also</a></li>
</ul>


<p> <a href="../">&laquo; Return to documentation listing</a></p>
<?php
include_once("$topdir/includes/footer.inc");
