<?php
$topdir = "../../..";
$title = "prte-rank(1) man page (version 5.0.0rc1)";
$meta_desc = "Open MPI v5.0.0rc1 man page: prte-rank(1)";

include_once("$topdir/doc/nav.inc");
include_once("$topdir/includes/header.inc");
?>
<p> <a href="../">&laquo; Return to documentation listing</a></p>
  <!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
<p>
PRTE: Mapping, Ranking, and Binding
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>
<p>
PRTE employs a three-phase
procedure for assigning process locations and ranks:
<dl>

<dt>1.</dt>
<dd>B]mappingR]: Assigns
a default location to each process </dd>

<dt>2.</dt>
<dd>B]rankingR]: Assigns a unique rank
value to each process </dd>

<dt>3.</dt>
<dd>B]bindingR]: Constrains each process to run on specific
processors </dd>
</dl>
<p>
This document describes these three phases with examples. Unless
otherwise noted, this behavior is shared by C]prunR], C]prterunR], and
C]prteR].
<h2><a name='sect2' href='#toc2'>Quick Summary</a></h2>
<p>
The two binaries that most influence process layout
are C]prteR] and C]prunR]. The C]prteR] process discovers the allocation,
starts the daemons, and defines the default mapping/ranking/binding for
all jobs. The C]prunR] process defines the specific mapping/ranking/binding
for a specific job. Most of the command line controls are targeted to C]prunR]
since each job has its own unique requirements. <p>
C]prterunR] is just a wrapper
around C]prteR] for a single job PRTE DVM. It is doing the job of both C]prteR]
and C]prunR], and, as such, accepts the sum all of their command line arguments.
Any example that uses C]prunR] can substitute the use of C]prterunR] except
where otherwise noted. <p>
The C]prteR] process attempts to automatically discover
the nodes in the allocation by querying supported resource managers. If
a support resource manager is not present then C]prteR] relies on a hostfile
provided by the user. In the absence of such a hostfile it will run all
processes on the localhost. <p>
If running under a supported resource manager,
the C]prteR] process will start the daemon processes (C]prtedR]) on the
remote nodes using the corresponding resource manager process starter. If
no such starter is available then C]rshR] or C]sshR] is used. <p>
PRTE automatically
maps processes in a round-robin fashion by CPU slot in one of two ways in
the absence of any further directives:
<dl>

<dt>B]CB]Map by core:B]R] </dt>
<dd>when the number
of total processes in the job is &lt;= 2 </dd>

<dt>B]CB]Map by package:B]R] </dt>
<dd>when the
number of total processes in the job is &gt; 2 </dd>
</dl>
<p>
PRTE automatically binds processes.
Three binding patterns are used in the absence of any further directives:

<dl>

<dt>B]CB]Bind to core:B]R] </dt>
<dd>when the number of total processes in the job is
&lt;= 2 </dd>

<dt>B]CB]Bind to package:B]R] </dt>
<dd>when the number of total processes in the
job is &gt; 2 </dd>

<dt>B]CB]Bind to none:B]R] </dt>
<dd>when oversubscribed </dd>
</dl>
<p>
If your application
uses threads, then you probably want to ensure that you are either not
bound at all (by specifying C]--bind-to noneR]), or bound to multiple cores
using an appropriate binding level or specific number of processing elements
per application process. <p>
PRTE automatically ranks processes starting from
0. Two ranking patterns are used in the absence of any further directives:

<dl>

<dt>B]CB]Rank by slot:B]R] </dt>
<dd>when the number of total processes in the job is
&lt;= 2 </dd>

<dt>B]CB]Rank by package:B]R] </dt>
<dd>when the number of total processes in the
job is &gt; 2 </dd>
</dl>

<h2><a name='sect3' href='#toc3'>Options</a></h2>
<p>
Listed here are the subset of command line options that
will be used in the process mapping/ranking/binding discussion in this
manual page.
<h3><a name='sect4' href='#toc4'>Specifying Host Nodes</a></h3>
<p>
Use one of the following options to specify
which hosts (nodes) within the PRTE DVM environment to run on.
<dl>

<dt>B]CB]--host
&lt;host1,host2,...,hostN&gt;B]R] or B]CB]--host &lt;host1:X,host2:Y,...,hostN:Z&gt;B]R] </dt>
<dd>List of
hosts on which to invoke processes. After each hostname a colon (C]:R])
followed by a positive integer can be used to specify the number of slots
on that host (C]:XR], C]:YR], and C]:ZR]). The default is C]1R]. </dd>

<dt>B]CB]--hostfile
&lt;hostfile&gt;B]R] </dt>
<dd>Provide a hostfile to use. </dd>

<dt>B]CB]--machinefile &lt;machinefile&gt;B]R]
</dt>
<dd>Synonym for C]-hostfileR]. </dd>

<dt>B]CB]--default-hostfile &lt;hostfile&gt;B]R] </dt>
<dd>Provide a default
hostfile to use. </dd>
</dl>

<h3><a name='sect5' href='#toc5'>Process Mapping / Ranking / Binding Options</a></h3>
<p>
The following
options specify the number of processes to launch. Note that none of the
options imply a particular binding policy - e.g., requesting C]NR] processes
for each socket does not imply that the processes will be bound to the
socket.
<dl>

<dt>B]CB]-c, -n, --n, --np &lt;#&gt;B]R] </dt>
<dd>Run this many copies of the program on the
given nodes. This option indicates that the specified file is an executable
program and not an application context. If no value is provided for the
number of copies to execute (i.e., neither the C]-npR] nor its synonyms are
provided on the command line), C]prunR] will automatically execute a copy
of the program on each process slot (see below for description of a [lq]process
slot[rq]). This feature, however, can only be used in the SPMD model and
will return an error (without beginning execution of the application) otherwise.
</dd>
</dl>
<p>
To map processes across sets of objects:
<dl>

<dt>B]CB]--map-by &lt;object&gt;B]R] </dt>
<dd>Map to the
specified object. See defaults in Quick Summary. Supported options include
C]slotR], C]hwthreadR], C]coreR], C]l1cacheR], C]l2cacheR], C]l3cacheR],
C]packageR], C]nodeR], C]seqR], C]distR], C]pprR], and C]rankfileR]. </dd>
</dl>
<p>
Any
object can include qualifier by adding a colon (C]:R]) and any combination
of one or more of the following to the C]--map-byR] option:
<dl>

<dt>[bu]</dt>
<dd>C]PE=nR] bind
C]nR] processing elements to each process </dd>

<dt>[bu]</dt>
<dd>C]SPANR] load balance the
processes across the allocation </dd>

<dt>[bu]</dt>
<dd>C]OVERSUBSCRIBER] allow more processes
on a node than processing elements </dd>

<dt>[bu]</dt>
<dd>C]NOOVERSUBSCRIBER] means C]!OVERSUBSCRIBER]
</dd>

<dt>[bu]</dt>
<dd>C]NOLOCALR] do not launch processes on the same node as C]prunR] </dd>

<dt>[bu]</dt>
<dd>C]HWTCPUSR]
use hardware threads as CPU slots </dd>

<dt>[bu]</dt>
<dd>C]CORECPUSR] use cores as CPU slots
(default) </dd>

<dt>[bu]</dt>
<dd>C]DEVICE=devR] device specifier for the C]distR] policy </dd>

<dt>[bu]</dt>
<dd>C]INHERITR]
</dd>

<dt>[bu]</dt>
<dd>C]NOINHERITR] means C]!INHERITR] </dd>

<dt>[bu]</dt>
<dd>C]PE-LIST=a,bR] comma-delimited
ranges of cpus to use for this job processed as an unordered pool of CPUs
</dd>

<dt>[bu]</dt>
<dd>C]FILE=%sR] (path to file containing sequential or rankfile entries).
</dd>
</dl>
<p>
C]pprR] policy example: C]--map-by ppr:N:&lt;object&gt;R] will launch C]NR] times
the number of objects of the specified type on each node. <p>
To order processes[cq]
ranks:
<dl>

<dt>B]CB]--rank-by &lt;object&gt;B]R] </dt>
<dd>Rank in round-robin fashion according to the
specified object. See defaults in Quick Summary. Supported options include
C]slotR], C]hwthreadR], C]coreR], C]l1cacheR], C]l2cacheR], C]l3cacheR],
C]packageR], and C]nodeR]. </dd>
</dl>
<p>
Any object can include qualifiers by adding a
colon (C]:R]) and any combination of one or more of the following to the
C]--rank-byR] option:
<dl>

<dt>[bu]</dt>
<dd>C]SPANR] </dd>

<dt>[bu]</dt>
<dd>C]FILLR] </dd>
</dl>
<p>
To bind processes to sets
of objects:
<dl>

<dt>B]CB]--bind-to &lt;object&gt;B]R] </dt>
<dd>Bind processes to the specified object.
See defaults in Quick Summary. Supported options include C]noneR], C]hwthreadR],
C]coreR], C]l1cacheR], C]l2cacheR], C]l3cacheR], and C]packageR]. </dd>
</dl>
<p>
Any object
can include qualifiers by adding a colon (C]:R]) and any combination of
one or more of the following to the C]--bind-toR] option:
<dl>

<dt>[bu]</dt>
<dd>C]overload-allowedR]
allows for binding more than one process in relation to a CPU </dd>

<dt>[bu]</dt>
<dd>C]if-supportedR]
if that object is supported on this system </dd>
</dl>

<h3><a name='sect6' href='#toc6'>Diagnostics</a></h3>

<dl>

<dt>B]CB]--map-by :DISPLAYB]R]
</dt>
<dd>Display a table showing the mapped location of each process prior to launch.
</dd>

<dt>B]CB]--map-by :DISPLAYALLOCB]R] </dt>
<dd>Display the detected allocation of resources
(e.g., nodes, slots) </dd>

<dt>B]CB]--bind-to :REPORTB]R] </dt>
<dd>Report bindings for launched
processes to C]stderrR]. </dd>
</dl>

<h2><a name='sect7' href='#toc7'>Description</a></h2>
<p>
PRTE employs a three-phase procedure
for assigning process locations and ranks:
<dl>

<dt>1.</dt>
<dd>B]mappingR]: Assigns a default
location to each process </dd>

<dt>2.</dt>
<dd>B]rankingR]: Assigns a unique rank value to each
process </dd>

<dt>3.</dt>
<dd>B]bindingR]: Constrains each process to run on specific processors
</dd>
</dl>
<p>
The first phase of B]mappingR] is used to assign a default location to
each process based on the mapper being employed. Mapping by slot, node,
and sequentially results in the assignment of the processes to the node
level. In contrast, mapping by object, allows the mapper to assign the process
to an actual object on each node. <p>
I]Note:R] The location assigned to the
process is independent of where it will be bound - the assignment is used
solely as input to the binding algorithm. <p>
The second phase focuses on the
B]rankingR] of the process within the job[cq]s namespace. PRTE separates
this from the mapping procedure to allow more flexibility in the relative
placement of processes. <p>
The third phase of B]bindingR] actually binds each
process to a given set of processors. This can improve performance if the
operating system is placing processes sub-optimally. For example, it might
oversubscribe some multi-core processor sockets, leaving other sockets idle;
this can lead processes to contend unnecessarily for common resources. Or,
it might spread processes out too widely; this can be suboptimal if application
performance is sensitive to interprocess communication costs. Binding can
also keep the operating system from migrating processes excessively, regardless
of how optimally those processes were placed to begin with. <p>
PRTE[cq]s support
for process binding depends on the underlying operating system. Therefore,
certain process binding options may not be available on every system.
<h3><a name='sect8' href='#toc8'>Specifying
Host Nodes</a></h3>
<p>
Host nodes can be identified on the command line with the C]--hostR]
option or in a hostfile. <p>
For example, assuming no other resource manager
or scheduler is involved,
<dl>

<dt>B]CB]prte --host aa,aa,bb ./a.outB]R] </dt>
<dd>launches two
processes on node C]aaR] and one on C]bbR]. </dd>

<dt>B]CB]prun --host aa ./a.outB]R]
</dt>
<dd>launches one process on node C]aaR]. </dd>

<dt>B]CB]prun --host aa:5 ./a.outB]R] </dt>
<dd>launches
five processes on node C]aaR]. </dd>
</dl>
<p>
Or, consider the hostfile <br>
<pre>

</pre><p>

<dl>

<dt>C]$ cat myhostfileaa slots=2bb slots=2cc slots=2R]Here, we list both the
host names (C]aaR], C]bbR], and </dt>
<dd>C]ccR]) but also how many [lq]slots[rq]
there are for each. Slots indicate how many processes can potentially execute
on a node. For best performance, the number of slots may be chosen to be
the number of cores on the node or the number of processor sockets. </dd>
</dl>
<p>
If the
hostfile does not provide slots information, the PRTE DVM will attempt
to discover the number of cores (or hwthreads, if the C]:HWTCPUSR] qualifier
to the C]--map-byR] option is set) and set the number of slots to that value.
<p>
Examples using the hostfile above with and without the C]--hostR] option

<dl>

<dt>B]CB]prun --hostfile myhostfile ./a.outB]R] </dt>
<dd>will launch two processes on each
of the three nodes. </dd>

<dt>B]CB]prun --hostfile myhostfile --host aa ./a.outB]R] </dt>
<dd>will
launch two processes, both on node C]aaR]. </dd>

<dt>B]CB]prun --hostfile myhostfile
--host dd ./a.outB]R] </dt>
<dd>will find no hosts to run on and abort with an error.
That is, the specified host C]ddR] is not in the specified hostfile. </dd>
</dl>
<p>
When
running under resource managers (e.g., SLURM, Torque, etc.), PRTE will obtain
both the hostnames and the number of slots directly from the resource manger.
The behavior of C]--hostR] in that environment will behave the same as if
a hostfile was provided (since it is provided by the resource manager).

<h3><a name='sect9' href='#toc9'>Specifying Number of Processes</a></h3>
<p>
As we have just seen, the number of processes
to run can be set using the hostfile. Other mechanisms exist. <p>
The number
of processes launched can be specified as a multiple of the number of nodes
or processor sockets available. Consider the hostfile below for the examples
that follow. <br>
<pre>

</pre><p>

<dl>

<dt>C]$ cat myhostfileaabbR]For example, </dt>
<dd></dd>

<dt>B]CB]prun --hostfile myhostfile --map-by
ppr:2:package ./a.outB]R] </dt>
<dd>launches processes 0-3 on node C]aaR] and process
4-7 on node C]bbR], where C]aaR] and C]bbR] are both dual-package nodes. The
C]--map-by ppr:2:packageR] option also turns on the C]--bind-to packageR] option,
which is discussed in a later section. </dd>

<dt>B]CB]prun --hostfile myhostfile --map-by
ppr:2:node ./a.outB]R] </dt>
<dd>launches processes 0-1 on node C]aaR] and processes
2-3 on node C]bbR]. </dd>

<dt>B]CB]prun --hostfile myhostfile --map-by ppr:1:node ./a.outB]R]
</dt>
<dd>launches one process per host node. </dd>
</dl>
<p>
Another alternative is to specify the
number of processes with the C]--npR] option. Consider now the hostfile <br>
<pre>

</pre><p>

<dl>

<dt>C]$ cat myhostfileaa slots=4bb slots=4cc slots=4R]Now, </dt>
<dd></dd>

<dt>B]CB]prun --hostfile
myhostfile --np 6 ./a.outB]R] </dt>
<dd>will launch processes 0-3 on node C]aaR] and processes
4-5 on node C]bbR]. The remaining slots in the hostfile will not be used
since the C]-npR] option indicated that only 6 processes should be launched.
</dd>
</dl>

<h3><a name='sect10' href='#toc10'>Mapping Processes to Nodes: Using Policies</a></h3>
<p>
The examples above illustrate
the default mapping of process processes to nodes. This mapping can also
be controlled with various C]prunR]/C]prterunR] options that describe mapping
policies. <br>
<pre>

</pre><p>

<dl>

<dt>C]$ cat myhostfileaa slots=4bb slots=4cc slots=4R]Consider the hostfile
above, with C]--np 6R]: </dt>
<dd><br>
<pre>

</pre></dd>
</dl>
<p>

<dl>

<dt>C]                              node aa      node bb      node ccprun
                        0 1 2 3      4 5prun --map-by node            0 1
         2 3          4 5prun --map-by node:NOLOCAL                 0 1 2
       3 4 5R]The C]--map-by nodeR] option will load balance the processes
</dt>
<dd>across the available nodes, numbering each process in a round-robin fashion.
</dd>
</dl>
<p>
The C]:NOLOCALR] qualifier to C]--map-byR] prevents any processes from being
mapped onto the local host (in this case node C]aaR]). While C]prunR] typically
consumes few system resources, the C]:NOLOCALR] qualifier can be helpful
for launching very large jobs where C]prunR] may actually need to use noticeable
amounts of memory and/or processing time. <p>
Just as C]--npR] can specify fewer
processes than there are slots, it can also oversubscribe the slots. For
example, with the same hostfile:
<dl>

<dt>B]CB]prun --hostfile myhostfile --np 14 ./a.outB]R]
</dt>
<dd>will produce an error since the default C]:NOOVERSUBSCRIBER] qualifier
to C]--map-byR] prevents oversubscription. </dd>
</dl>
<p>
To oversubscribe the nodes you can
use the C]:OVERSUBSCRIBER] qualifier to C]--map-byR]:
<dl>

<dt>B]CB]prun --hostfile myhostfile
--np 14 --map-by :OVERSUBSCRIBE ./a.outB]R] </dt>
<dd>will launch processes 0-5 on node C]aaR],
6-9 on C]bbR], and 10-13 on C]ccR]. </dd>
</dl>
<p>
Limits to oversubscription can also be
specified in the hostfile itself with the C]max_slotsR] field: <br>
<pre>

</pre><p>

<dl>

<dt>C]% cat myhostfileaa slots=4 max_slots=4bb         max_slots=8cc slots=4R]The
C]max_slotsR] field specifies such a limit. </dt>
<dd>When it does, the C]slotsR]
value defaults to the limit. Now: </dd>

<dt>B]CB]prun --hostfile myhostfile --np 14 --map-by
:OVERSUBSCRIBE ./a.outB]R] </dt>
<dd>causes the first 12 processes to be launched as
before, but the remaining two processes will be forced onto node cc. The
other two nodes are protected by the hostfile against oversubscription
by this job. </dd>
</dl>
<p>
Using the C]:NOOVERSUBSCRIBER] qualifier to C]--map-byR] option
can be helpful since the PRTE DVM currently does not get [lq]max_slots[rq]
values from the resource manager. <p>
Of course, C]--npR] can also be used with
the C]--hostR] option. For example,
<dl>

<dt>B]CB]prun --host aa,bb --np 8 ./a.outB]R] </dt>
<dd>will
produce an error since the default C]:NOOVERSUBSCRIBER] qualifier to C]--map-byR]
prevents oversubscription. </dd>

<dt>B]CB]prun --host aa,bb --np 8 --map-by :OVERSUBSCRIBE
./a.outB]R] </dt>
<dd>launches 8 processes. Since only two hosts are specified, after
the first two processes are mapped, one to C]aaR] and one to C]bbR], the
remaining processes oversubscribe the specified hosts evenly. </dd>

<dt>B]CB]prun
--host aa:2,bb:6 --np 8 ./a.outB]R] </dt>
<dd>launches 8 processes. Processes 0-1 on node
C]aaR] since it has 2 slots and processes 2-7 on node C]bbR] since it has
6 slots. </dd>
</dl>
<p>
And here is a MIMD example:
<dl>

<dt>B]CB]prun --host aa --np 1 hostname : --host
bb,cc --np 2 uptimeB]R] </dt>
<dd>will launch process 0 running C]hostnameR] on node
C]aaR] and processes 1 and 2 each running C]uptimeR] on nodes C]bbR] and
C]ccR], respectively. </dd>
</dl>

<h3><a name='sect11' href='#toc11'>Mapping, Ranking, and Binding: Fundamentals</a></h3>
<p>
The mapping
of process processes to nodes can be defined not just with general policies
but also, if necessary, using arbitrary mappings that cannot be described
by a simple policy. One can use the [lq]sequential mapper,[rq] which reads
the hostfile line by line, assigning processes to nodes in whatever order
the hostfile specifies. Use the C]--prtemca rmaps seqR] option. <p>
For example,
using the hostfile below: <br>
<pre>

</pre><p>

<dl>

<dt>C]% cat myhostfileaa slots=4bb slots=4cc slots=4R]The command below will
launch three processes, one on each of nodes </dt>
<dd>C]aaR], C]bbR], and C]ccR],
respectively. The slot counts don[cq]t matter; one process is launched per
line on whatever node is listed on the line. <br>
<pre>

</pre></dd>
</dl>
<p>

<dl>

<dt>C]% prun --hostfile myhostfile --prtemca rmaps seq ./a.outR]The I]rankingR] phase
is best illustrated by considering the </dt>
<dd>following hostfile and test cases
we used the C]--map-by ppr:2:packageR] option: <br>
<pre>

</pre></dd>

<dt>C]% cat myhostfileaabbR]</dt>
<dd><br>
<pre>C]
                         node aa       node bb
--rank-by core           0 1 ! 2 3     4 5 ! 6 7
--rank-by package        0 2 ! 1 3     4 6 ! 5 7
--rank-by package:SPAN   0 4 ! 1 5     2 6 ! 3 7
R]
</pre></dd>
</dl>
<p>
Ranking by core and by slot provide the identical result - a simple progression
of ranks across each node. Ranking by package does a round-robin ranking
within each node until all processes have been assigned a rank, and then
progresses to the next node. Adding the C]:SPANR] qualifier to the ranking
directive causes the ranking algorithm to treat the entire allocation as
a single entity - thus, the process ranks are assigned across all sockets
before circling back around to the beginning. <p>
The I]bindingR] phase restricts
the process to a subset of the CPU resources on the node. <p>
The processors
to be used for binding can be identified in terms of topological groupings
- e.g., binding to an l3cache will bind each process to all processors within
the scope of a single L3 cache within their assigned location. Thus, if
a process is assigned by the mapper to a certain package, then a C]--bind-to
l3cacheR] directive will cause the process to be bound to the processors
that share a single L3 cache within that package. <p>
To help balance loads,
the binding directive uses a round-robin method when binding to levels lower
than used in the mapper. For example, consider the case where a job is mapped
to the package level, and then bound to core. Each package will have multiple
cores, so if multiple processes are mapped to a given package, the binding
algorithm will assign each process located to a package to a unique core
in a round-robin manner. <p>
Alternatively, processes mapped by l2cache and then
bound to package will simply be bound to all the processors in the package
where they are located. In this manner, users can exert detailed control
over relative process location and binding. <p>
Process mapping/ranking/binding
can also be set with MCA parameters. Their usage is less convenient than
that of the command line options. On the other hand, MCA parameters can
be set not only on the C]prunR] command line, but alternatively in a system
or user C]mca-params.confR] file or as environment variables, as described
in the MCA section below. Some examples include: <br>
<pre>

</pre>
<h3><a name='sect12' href='#toc12'>C]prun option          MCA parameter key           value--map-by core
   rmaps_base_mapping_policy   core--map-by package     rmaps_base_mapping_policy
  package--rank-by core       rmaps_base_ranking_policy   core--bind-to core
      hwloc_base_binding_policy   core--bind-to package    hwloc_base_binding_policy
  package--bind-to none       hwloc_base_binding_policy   noneR]Difference
between overloading and oversubscription</a></h3>
<p>
This section explores the difference
between these two options. Users are often confused by the difference between
these two scenarios.
<dl>

<dt>As such this section provides a number of scenarios
to help illustrate </dt>
<dd>the differences. </dd>

<dt>[bu]</dt>
<dd>C]--map-by :OVERSUBSCRIBER] allow more
processes on a node than processing elements </dd>

<dt>[bu]</dt>
<dd>C]--bind-to &lt;object&gt;:overload-allowedR]
allows for binding more than one process in relation to a CPU </dd>
</dl>
<p>
The important
thing to remember with I]oversubscribingR] is that it can be defined separately
from the actual number of CPUs on a node. This allows the mapper to place
more or fewer processes per node than CPUs. By default, PRTE uses cores
to determine slots in the absence of such information provided in the hostfile
or by the resource manager (except in the case of the C]--hostR] as described
in the [lq]Specifying Host Nodes[rq] section). <p>
The important thing to remember
with I]overloadingR] is that it is defined as binding more processes than
CPUs. By default, PRTE uses cores as a means of counting the number of CPUs.
However, the user can adjust this. For example when using the C]:HWTCPUSR]
qualifier to the C]--map-byR] option PRTE will use hardware threads as a means
of counting the number of CPUs. <p>
For the following examples consider a node
with: - Two processor packages, - Ten cores per package, and - Eight hardware
threads per core. <p>
Consider the node from above with the hostfile below:
<br>
<pre>

</pre><p>

<dl>

<dt>C]$ cat myhostfilenode01 slots=32node02 slots=32R]The [lq]slots[rq] tells
PRTE that it can place up to 32 processes </dt>
<dd>before I]oversubscribingR] the
node. </dd>
</dl>
<p>
If we run the following: <br>
<pre>

</pre><p>

<dl>

<dt>C]prun --np 34 --hostfile myhostfile --map-by core --bind-to core hostnameR]It will
return an error at the binding time indicating an </dt>
<dd>I]overloadingR] scenario.
</dd>
</dl>
<p>
The mapping mechanism assigns 32 processes to C]node01R] matching the [lq]slots[rq]
specification in the hostfile. The binding mechanism will bind the first
20 processes to unique cores leaving it with 12 processes that it cannot
bind without overloading one of the cores (putting more than one process
on the core). <p>
Using the C]overload-allowedR] qualifier to the C]--bind-to coreR]
option tells PRTE that it may assign more than one process to a core. <p>
If
we run the following: <br>
<pre>

</pre><p>

<dl>

<dt>C]prun --np 34 --hostfile myhostfile --map-by core --bind-to core:overload-allowed
hostnameR]This will run correctly placing 32 processes on C]node01R], and
2 </dt>
<dd>processes on C]node02R]. On C]node01R] two processes are bound to cores
0-11 accounting for the overloading of those cores. </dd>
</dl>
<p>
Alternatively, we could
use hardware threads to give binding a lower level CPU to bind to without
overloading. <p>
If we run the following: <br>
<pre>

</pre><p>

<dl>

<dt>C]prun --np 34 --hostfile myhostfile --map-by core:HWTCPUS --bind-to hwthread hostnameR]This
will run correctly placing 32 processes on C]node01R], and 2 </dt>
<dd>processes
on C]node02R]. On C]node01R] two processes are mapped to cores 0-11 but bound
to different hardware threads on those cores (the logical first and second
hardware thread) thus no hardware threads are overloaded at binding time.
</dd>
</dl>
<p>
In both of the examples above the node is not oversubscribed at mapping
time because the hostfile set the oversubscription limit to [lq]slots=32[rq]
for each node. It is only after we exceed that limit that PRTE will throw
an oversubscription error. <p>
Consider next if we ran the following: <br>
<pre>

</pre><p>

<dl>

<dt>C]prun --np 66 --hostfile myhostfile --map-by core:HWTCPUS --bind-to hwthread hostnameR]This
will return an error at mapping time indicating an oversubscription </dt>
<dd>scenario.
The mapping mechanism will assign all of the available slots (64 across
2 nodes) and be left two processes to map. The only way to map those processes
is to exceed the number of available slots putting the job into an oversubscription
scenario. </dd>
</dl>
<p>
You can force PRTE to oversubscribe the nodes by using the C]:OVERSUBSCRIBER]
qualifier to the C]--map-byR] option as seen in the example below: <br>
<pre>

</pre><p>

<dl>

<dt>C]prun --np 66 --hostfile myhostfile --map-by core:HWTCPUS:OVERSUBSCRIBE --bind-to
hwthread hostnameR]This will run correctly placing 34 processes on C]node01R]
and 32 </dt>
<dd>on C]node02R]. Each process is bound to a unique hardware thread.
</dd>
</dl>

<h3><a name='sect13' href='#toc13'>Overloading vs Oversubscription: Package Example</a></h3>
<p>
Let[cq]s extend these examples
by considering the package level. Consider the same node as before, but
with the hostfile below: <br>
<pre>

</pre><p>

<dl>

<dt>C]$ cat myhostfilenode01 slots=22node02 slots=22R]The lowest level CPUs
are &lsquo;cores&rsquo; and we have 20 total (10 per package). </dt>
<dd></dd>
</dl>
<p>
If we run: <br>
<pre>

</pre><p>

<dl>

<dt>C]prun --np 20 --hostfile myhostfile --map-by package --bind-to package:REPORT hostnameR]Then
10 processes are mapped to each package, and bound at the package </dt>
<dd>level.
This is not overloading since we have 10 CPUs (cores) available in the
package at the hardware level. </dd>
</dl>
<p>
However, if we run: <br>
<pre>

</pre><p>

<dl>

<dt>C]prun --np 21 --hostfile myhostfile --map-by package --bind-to package:REPORT hostnameR]Then
11 processes are mapped to the first package and 10 to the second </dt>
<dd>package.
At binding time we have an overloading scenario because there are only
10 CPUs (cores) available in the package at the hardware level. So the first
package is overloaded. </dd>
</dl>

<h3><a name='sect14' href='#toc14'>Overloading vs Oversubscription: Hardware Threads
Example</a></h3>
<p>
Similarly, if we consider hardware threads. <p>
Consider the same node
as before, but with the hostfile below: <br>
<pre>

</pre><p>

<dl>

<dt>C]$ cat myhostfilenode01 slots=165node02 slots=165R]The lowest level CPUs
are &lsquo;hwthreads&rsquo; (because we are going to use the </dt>
<dd>C]:HWTCPUSR] qualifier)
and we have 160 total (80 per package). </dd>
</dl>
<p>
If we re-run (from the package example)
and add the C]:HWTCPUSR] qualifier: <br>
<pre>

</pre><p>

<dl>

<dt>C]prun --np 21 --hostfile myhostfile --map-by package:HWTCPUS --bind-to package:REPORT
hostnameR]Without the C]:HWTCPUSR] qualifier this would be overloading
(as </dt>
<dd>we saw previously). The mapper places 11 processes on the first package
and 10 to the second package. The processes are still bound to the package
level. However, with the C]:HWTCPUSR] qualifier, it is not overloading since
we have 80 CPUs (hwthreads) available in the package at the hardware level.
</dd>
</dl>
<p>
Alternatively, if we run: <br>
<pre>

</pre><p>

<dl>

<dt>C]prun --np 161 --hostfile myhostfile --map-by package:HWTCPUS --bind-to package:REPORT
hostnameR]Then 81 processes are mapped to the first package and 80 to the
second </dt>
<dd>package. At binding time we have an overloading scenario because
there are only 80 CPUs (hwthreads) available in the package at the hardware
level. So the first package is overloaded. </dd>
</dl>

<h3><a name='sect15' href='#toc15'>Diagnostics</a></h3>
<p>
PRTE provides various
diagnostic reports that aid the user in verifying and tuning the mapping/ranking/binding
for a specific job. <p>
The C]:REPORTR] qualifier to C]--bind-toR] command line
option can be used to report process bindings. <p>
As an example, consider a
node with: - Two processor packages, - Four cores per package, and - Eight
hardware threads per core. <p>
In each of the examples below the binding is
reported in a human readable format. <br>
<pre>

</pre><p>

<dl>

<dt>C]$ prun --np 4 --map-by core --bind-to core:REPORT ./a.out[node01:103137] MCW rank
0 bound to package[0][core:0][node01:103137] MCW rank 1 bound to package[0][core:1][node01:103137]
MCW rank 2 bound to package[0][core:2][node01:103137] MCW rank 3 bound
to package[0][core:3]R]The example above processes bind to successive cores
on the first </dt>
<dd>package. <br>
<pre>

</pre></dd>
</dl>
<p>

<dl>

<dt>C]$ prun --np 4 --map-by package --bind-to package:REPORT ./a.out[node01:103115]
MCW rank 0 bound to package[0][core:0-9][node01:103115] MCW rank 1 bound
to package[1][core:10-19][node01:103115] MCW rank 2 bound to package[0][core:0-9][node01:103115]
MCW rank 3 bound to package[1][core:10-19]R]The example above processes
bind to all cores on successive packages. </dt>
<dd>The processes cycle though the
packages in a round-robin fashion as many times as are needed. <br>
<pre>

</pre></dd>
</dl>
<p>

<dl>

<dt>C]$ prun --np 4 --map-by package:PE=2 --bind-to core:REPORT ./a.out[node01:103328]
MCW rank 0 bound to package[0][core:0-1][node01:103328] MCW rank 1 bound
to package[1][core:10-11][node01:103328] MCW rank 2 bound to package[0][core:2-3][node01:103328]
MCW rank 3 bound to package[1][core:12-13]R]The example above shows us that
2 cores have been bound per process. </dt>
<dd>The C]:PE=2R] qualifier states that
2 processing elements underneath the package (which would be cores in this
case) are mapped to each process. The processes cycle though the packages
in a round-robin fashion as many times as are needed. <br>
<pre>

</pre></dd>
</dl>
<p>

<dl>

<dt>C]$ prun --np 4 --map-by core:PE=2:HWTCPUS --bind-to :REPORT  hostname[node01:103506]
MCW rank 0 bound to package[0][hwt:0-1][node01:103506] MCW rank 1 bound
to package[0][hwt:8-9][node01:103506] MCW rank 2 bound to package[0][hwt:16-17][node01:103506]
MCW rank 3 bound to package[0][hwt:24-25]R]The example above shows us that
2 hardware threads have been bound per </dt>
<dd>process. In this case C]prunR] is
mapping by hardware threads since we used the C]:HWTCPUSR] qualifier. Without
that qualifier this command would return an error since by default C]prunR]
will not map to resources smaller than a core. The C]:PE=2R] qualifier states
that 2 processing elements underneath the core (which would be hardware
threads in this case) are mapped to each process. The processes cycle though
the cores in a round-robin fashion as many times as are needed. <br>
<pre>

</pre></dd>
</dl>
<p>

<dl>

<dt>C]$ prun --np 4 --bind-to none:REPORT  hostname[node01:107126] MCW rank 0 is
not bound (or bound to all available processors)[node01:107126] MCW rank
1 is not bound (or bound to all available processors)[node01:107126] MCW
rank 2 is not bound (or bound to all available processors)[node01:107126]
MCW rank 3 is not bound (or bound to all available processors)R]The example
above binding is turned off. </dt>
<dd></dd>
</dl>

<h3><a name='sect16' href='#toc16'>Rankfiles</a></h3>
<p>
Another way to specify arbitrary mappings
is with a rankfile, which gives you detailed control over process binding
as well. <p>
Rankfiles are text files that specify detailed information about
how individual processes should be mapped to nodes, and to which processor(s)
they should be bound. Each line of a rankfile specifies the location of
one process. The general form of each line in the rankfile is: <br>
<pre>

</pre><p>

<dl>

<dt>C]rank &lt;N&gt;=&lt;hostname&gt; slot=&lt;slot list&gt;R]For example: </dt>
<dd><br>
<pre>

</pre></dd>
</dl>
<p>

<dl>

<dt>C]$ cat myrankfilerank 0=c712f6n01 slot=10-12rank 1=c712f6n02 slot=0,1,4rank
2=c712f6n03 slot=1-2$ prun --host aa,bb,cc,dd --map-by rankfile:FILE=myrankfile
./a.outR]Means that </dt>
<dd><br>
<pre>

</pre></dd>
</dl>
<p>

<dl>

<dt>C]Rank 0 runs on node aa, bound to logical cores 10-12.Rank 1 runs on node
bb, bound to logical cores 0, 1, and 4.Rank 2 runs on node cc, bound to
logical cores 1 and 2.R]For example: </dt>
<dd><br>
<pre>

</pre></dd>
</dl>
<p>

<dl>

<dt>C]$ cat myrankfilerank 0=aa slot=1:0-2rank 1=bb slot=0:0,1,4rank 2=cc slot=1-2$
prun --host aa,bb,cc,dd --map-by rankfile:FILE=myrankfile ./a.outR]Means that
</dt>
<dd><br>
<pre>

</pre></dd>
</dl>
<p>

<dl>

<dt>C]Rank 0 runs on node aa, bound to logical package 1, cores 10-12 (the 0th
through 2nd cores on that package).Rank 1 runs on node bb, bound to logical
package 0, cores 0, 1, and 4.Rank 2 runs on node cc, bound to logical cores
1 and 2.R]The hostnames listed above are [lq]absolute,[rq] meaning that
actual </dt>
<dd>resolvable hostnames are specified. However, hostnames can also be
specified as [lq]relative,[rq] meaning that they are specified in relation
to an externally-specified list of hostnames (e.g., by C]prunR][cq]s C]--hostR]
argument, a hostfile, or a job scheduler). </dd>
</dl>
<p>
The [lq]relative[rq] specification
is of the form [lq]C]+n&lt;X&gt;R][rq], where C]XR] is an integer specifying the
Xth hostname in the set of all available hostnames, indexed from 0. For
example: <br>
<pre>

</pre><p>

<dl>

<dt>C]$ cat myrankfilerank 0=+n0 slot=10-12rank 1=+n1 slot=0,1,4rank 2=+n2 slot=1-2$
prun --host aa,bb,cc,dd --map-by rankfile:FILE=myrankfile ./a.outR]All package/core
slot locations are be specified as I]logicalR] </dt>
<dd>indexes. You can use tools
such as HWLOC[cq]s [lq]lstopo[rq] to find the logical indexes of packages
and cores. </dd>
</dl>

<h3><a name='sect17' href='#toc17'>Deprecated Options</a></h3>
<p>
These deprecated options will be removed in
a future release.
<dl>

<dt>B]CB]--bind-to-coreB]R] </dt>
<dd>B](Deprecated: Use CB]--bind-to coreB])R]
Bind processes to cores </dd>

<dt>B]CB]-bind-to-socket, --bind-to-socketB]R] </dt>
<dd>B](Deprecated:
Use CB]--bind-to packageB])R] Bind processes to processor sockets </dd>

<dt>B]CB]--bycoreB]R]
</dt>
<dd>B](Deprecated: Use CB]--map-by coreB])R] Map processes by core </dd>

<dt>B]CB]-bynode,
--bynodeB]R] </dt>
<dd>B](Deprecated: Use CB]--map-by nodeB])R] Launch processes one per
node, cycling by node in a round-robin fashion. This spreads processes evenly
among nodes and assigns ranks in a round-robin, [lq]by node[rq] manner. </dd>

<dt>B]CB]--byslotB]R]
</dt>
<dd>B](Deprecated: Use CB]--map-by slotB])R] Map and rank processes round-robin
by slot. </dd>

<dt>B]CB]--cpus-per-proc &lt;#perproc&gt;B]R] </dt>
<dd>B](Deprecated: Use CB]--map-by &lt;obj&gt;:PE=&lt;#perproc&gt;B])R]
Bind each process to the specified number of cpus. </dd>

<dt>B]CB]--cpus-per-rank &lt;#perrank&gt;B]R]
</dt>
<dd>B](Deprecated: Use CB]--map-by &lt;obj&gt;:PE=&lt;#perrank&gt;B])R] Alias for C]--cpus-per-procR].
</dd>

<dt>B]CB]--display-allocationB]R] </dt>
<dd>B](Deprecated: Use CB]--map-by :DISPLAYALLOCB])R]
Display the detected resource allocation. </dd>

<dt>B]CB]--display-devel-mapB]R] </dt>
<dd>B](Deprecated:
Use CB]--map-by :DISPLAYDEVELB])R] Display a detailed process map (mostly
intended for developers) just before launch. </dd>

<dt>B]CB]--display-mapB]R] </dt>
<dd>B](Deprecated:
Use CB]--map-by :DISPLAYB])R] Display a table showing the mapped location
of each process prior to launch. </dd>

<dt>B]CB]--display-topoB]R] </dt>
<dd>B](Deprecated: Use
CB]--map-by :DISPLAYTOPOB])R] Display the topology as part of the process
map (mostly intended for developers) just before launch. </dd>

<dt>B]CB]--do-not-launchB]R]
</dt>
<dd>B](Deprecated: Use CB]--map-by :DONOTLAUNCHB])R] Perform all necessary operations
to prepare to launch the application, but do not actually launch it (usually
used to test mapping patterns). </dd>

<dt>B]CB]--do-not-resolveB]R] </dt>
<dd>B](Deprecated: Use
CB]--map-by :DONOTRESOLVEB])R] Do not attempt to resolve interfaces - usually
used to determine proposed process placement/binding prior to obtaining
an allocation. </dd>

<dt>B]CB]-N &lt;num&gt;B]R] </dt>
<dd>B](Deprecated: Use CB]--map-by prr:&lt;num&gt;:nodeB])R]
Launch C]numR] processes per node on all allocated nodes. </dd>

<dt>B]CB]--nolocalB]R]
</dt>
<dd>B](Deprecated: Use CB]--map-by :NOLOCALB])R] Do not run any copies of the
launched application on the same node as C]prunR] is running. This option
will override listing the C]localhostR] with C]--hostR] or any other host-specifying
mechanism. </dd>

<dt>B]CB]--nooversubscribeB]R] </dt>
<dd>B](Deprecated: Use CB]--map-by :NOOVERSUBSCRIBEB])R]
Do not oversubscribe any nodes; error (without starting any processes)
if the requested number of processes would cause oversubscription. This
option implicitly sets [lq]max_slots[rq] equal to the [lq]slots[rq] value
for each node. (Enabled by default). </dd>

<dt>B]CB]--npernode &lt;#pernode&gt;B]R] </dt>
<dd>B](Deprecated:
Use CB]--map-by ppr:&lt;#pernode&gt;:nodeB])R] On each node, launch this many processes.
</dd>

<dt>B]CB]--npersocket &lt;#persocket&gt;B]R] </dt>
<dd>B](Deprecated: Use CB]--map-by ppr:&lt;#perpackage&gt;:packageB])R]
On each node, launch this many processes times the number of processor
sockets on the node. The C]--npersocketR] option also turns on the C]--bind-to
socketR] option. The term C]socketR] has been globally replaced with C]packageR].
</dd>

<dt>B]CB]--oversubscribeB]R] </dt>
<dd>B](Deprecated: Use CB]--map-by :OVERSUBSCRIBEB])R]
Nodes are allowed to be oversubscribed, even on a managed system, and overloading
of processing elements. </dd>

<dt>B]CB]--pernodeB]R] </dt>
<dd>B](Deprecated: Use CB]--map-by ppr:1:nodeB])R]
On each node, launch one process. </dd>

<dt>B]CB]--pprB]R] </dt>
<dd>B](Deprecated: Use CB]--map-by
ppr:&lt;list&gt;B])R] Comma-separated list of number of processes on a given resource
type [default: none]. </dd>

<dt>B]CB]--rankfile &lt;FILENAME&gt;B]R] </dt>
<dd>B](Deprecated: Use CB]--map-by
rankfile:FILE=&lt;FILENAME&gt;B])R] Use a rankfile for mapping/ranking/binding
</dd>

<dt>B]CB]--report-bindingsB]R] </dt>
<dd>B](Deprecated: Use CB]--bind-to :REPORTB])R] Report
any bindings for launched processes. </dd>

<dt>B]CB]--tag-outputB]R] </dt>
<dd>B](Deprecated: Use
CB]--map-by :TAGOUTPUTB])R] Tag all output with [job,rank] </dd>

<dt>B]CB]--timestamp-outputB]R]
</dt>
<dd>B](Deprecated: Use CB]--map-by :TIMESTAMPOUTPUTB])R] Timestamp all application
process output </dd>

<dt>B]CB]--use-hwthread-cpusB]R] </dt>
<dd>B](Deprecated: Use CB]--map-by :HWTCPUSB])R]
Use hardware threads as independent cpus. </dd>

<dt>B]CB]--xmlB]R] </dt>
<dd>B](Deprecated: Use
CB]--map-by :XMLOUTPUTB])R] Provide all output in XML format </dd>
</dl>
<p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Quick Summary</a></li>
<li><a name='toc3' href='#sect3'>Options</a></li>
<ul>
<li><a name='toc4' href='#sect4'>Specifying Host Nodes</a></li>
<li><a name='toc5' href='#sect5'>Process Mapping / Ranking / Binding Options</a></li>
<li><a name='toc6' href='#sect6'>Diagnostics</a></li>
</ul>
<li><a name='toc7' href='#sect7'>Description</a></li>
<ul>
<li><a name='toc8' href='#sect8'>Specifying Host Nodes</a></li>
<li><a name='toc9' href='#sect9'>Specifying Number of Processes</a></li>
<li><a name='toc10' href='#sect10'>Mapping Processes to Nodes: Using Policies</a></li>
<li><a name='toc11' href='#sect11'>Mapping, Ranking, and Binding: Fundamentals</a></li>
<li><a name='toc12' href='#sect12'>C]prun option          MCA parameter key           value--map-by core        rmaps_base_mapping_policy   core--map-by package     rmaps_base_mapping_policy   package--rank-by core       rmaps_base_ranking_policy   core--bind-to core       hwloc_base_binding_policy   core--bind-to package    hwloc_base_binding_policy   package--bind-to none       hwloc_base_binding_policy   noneR]Difference between overloading and oversubscription</a></li>
<li><a name='toc13' href='#sect13'>Overloading vs Oversubscription: Package Example</a></li>
<li><a name='toc14' href='#sect14'>Overloading vs Oversubscription: Hardware Threads Example</a></li>
<li><a name='toc15' href='#sect15'>Diagnostics</a></li>
<li><a name='toc16' href='#sect16'>Rankfiles</a></li>
<li><a name='toc17' href='#sect17'>Deprecated Options</a></li>
</ul></ul>


<p> <a href="../">&laquo; Return to documentation listing</a></p>
<?php
include_once("$topdir/includes/footer.inc");
