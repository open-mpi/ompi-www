<?php
$topdir = "../../..";
$title = "MPI_Igather(3) man page (version 5.0.0rc1)";
$meta_desc = "Open MPI v5.0.0rc1 man page: MPI_IGATHER(3)";

include_once("$topdir/doc/nav.inc");
include_once("$topdir/includes/header.inc");
?>
<p> <a href="../">&laquo; Return to documentation listing</a></p>
  <!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>
<p>
C]MPI_GatherR], C]MPI_IgatherR] - Gathers values from a group of
processes.
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>

<h3><a name='sect2' href='#toc2'>C Syntax</a></h3>
<br>
<pre>

</pre>
<h3><a name='sect3' href='#toc3'>C]#include &lt;mpi.h&gt;int <a href="../man3/MPI_Gather.3.php">MPI_Gather</a>(const void *sendbuf, int sendcount, MPI_Datatype
sendtype,    void *recvbuf, int recvcount, MPI_Datatype recvtype, int root,
   MPI_Comm comm)int MPI_Igather(const void *sendbuf, int sendcount, MPI_Datatype
sendtype,    void *recvbuf, int recvcount, MPI_Datatype recvtype, int root,
   MPI_Comm comm, MPI_Request *request)R]Fortran Syntax</a></h3>
<br>
<pre>

</pre>
<h3><a name='sect4' href='#toc4'>C]USE MPI! or the older form: INCLUDE [aq]mpif.h[aq]<a href="../man3/MPI_Gather.3.php">MPI_GATHER</a>(SENDBUF,
SENDCOUNT, SENDTYPE, RECVBUF, RECVCOUNT,        RECVTYPE, ROOT, COMM, IERROR)
   &lt;type&gt;  SENDBUF(*), RECVBUF(*)    INTEGER SENDCOUNT, SENDTYPE, RECVCOUNT,
RECVTYPE, ROOT    INTEGER COMM, IERRORMPI_IGATHER(SENDBUF, SENDCOUNT, SENDTYPE,
RECVBUF, RECVCOUNT,        RECVTYPE, ROOT, COMM, REQUEST, IERROR)    &lt;type&gt;
 SENDBUF(*), RECVBUF(*)    INTEGER SENDCOUNT, SENDTYPE, RECVCOUNT, RECVTYPE,
ROOT    INTEGER COMM, REQUEST, IERRORR]Fortran 2008 Syntax</a></h3>
<br>
<pre>

</pre>
<h2><a name='sect5' href='#toc5'>C]USE mpi_f08MPI_Gather(sendbuf, sendcount, sendtype, recvbuf, recvcount,
recvtype,        root, comm, ierror)    TYPE(*), DIMENSION(..), INTENT(IN)
:: sendbuf    TYPE(*), DIMENSION(..) :: recvbuf    INTEGER, INTENT(IN) ::
sendcount, recvcount, root    TYPE(MPI_Datatype), INTENT(IN) :: sendtype,
recvtype    TYPE(MPI_Comm), INTENT(IN) :: comm    INTEGER, OPTIONAL, INTENT(OUT)
:: ierrorMPI_Igather(sendbuf, sendcount, sendtype, recvbuf, recvcount,
recvtype,        root, comm, request, ierror)    TYPE(*), DIMENSION(..),
INTENT(IN), ASYNCHRONOUS :: sendbuf    TYPE(*), DIMENSION(..), ASYNCHRONOUS
:: recvbuf    INTEGER, INTENT(IN) :: sendcount, recvcount, root    TYPE(MPI_Datatype),
INTENT(IN) :: sendtype, recvtype    TYPE(MPI_Comm), INTENT(IN) :: comm
   TYPE(MPI_Request), INTENT(OUT) :: request    INTEGER, OPTIONAL, INTENT(OUT)
:: ierrorR]Input Parameters</a></h2>

<dl>

<dt>[bu]</dt>
<dd>C]sendbufR] : Starting address of send buffer
(choice). </dd>

<dt>[bu]</dt>
<dd>C]sendcountR] : Number of elements in send buffer (integer).
</dd>

<dt>[bu]</dt>
<dd>C]sendtypeR] : Datatype of send buffer elements (handle). </dd>

<dt>[bu]</dt>
<dd>C]recvcountR]
: Number of elements for any single receive (integer, significant only
at root). </dd>

<dt>[bu]</dt>
<dd>C]recvtypeR] : Datatype of recvbuffer elements (handle, significant
only at root). </dd>

<dt>[bu]</dt>
<dd>C]rootR] : Rank of receiving process (integer). </dd>

<dt>[bu]</dt>
<dd>C]commR]
: Communicator (handle). </dd>
</dl>

<h2><a name='sect6' href='#toc6'>Output Parameters</a></h2>

<dl>

<dt>[bu]</dt>
<dd>C]recvbufR] : Address of receive
buffer (choice, significant only at root). </dd>

<dt>[bu]</dt>
<dd>C]requestR] : Request (handle,
non-blocking only). </dd>

<dt>[bu]</dt>
<dd>C]IERRORR] : Fortran only: Error status (integer).
</dd>
</dl>

<h2><a name='sect7' href='#toc7'>Description</a></h2>
<p>
Each process (root process included) sends the contents of its
send buffer to the root process. The root process receives the messages
and stores them in rank order. The outcome is as if each of the n processes
in the group (including the root process) had executed a call to <br>
<pre>

</pre><p>

<dl>

<dt>C]<a href="../man3/MPI_Send.3.php">MPI_Send</a>(sendbuf, sendcount, sendtype, root, ...)R]and the root had executed
n calls to </dt>
<dd><br>
<pre>

</pre></dd>
</dl>
<p>

<dl>

<dt>C]<a href="../man3/MPI_Recv.3.php">MPI_Recv</a>(recfbuf + i * recvcount * extent(recvtype), recvcount, recvtype,
i, ...)R]where extent(recvtype) is the type extent obtained from a call to
</dt>
<dd>C]<a href="../man3/MPI_Type_extent.3.php">MPI_Type_extent</a>()R]. </dd>
</dl>
<p>
An alternative description is that the n messages
sent by the processes in the group are concatenated in rank order, and
the resulting message is received by the root as if by a call to C]<a href="../man3/MPI_Recv.3.php">MPI_RECV</a>(recvbuf,
recvcount* n, recvtype, ... )R]. <p>
The receive buffer is ignored for all nonroot
processes. <p>
General, derived datatypes are allowed for both sendtype and
recvtype. The type signature of C]sendcountR], C]sendtypeR] on process i
must be equal to the type signature of C]recvcountR], C]recvtypeR] at the
root. This implies that the amount of data sent must be equal to the amount
of data received, pairwise between each process and the root. Distinct type
maps between sender and receiver are still allowed. <p>
All arguments to the
function are significant on process root, while on other processes, only
arguments C]sendbufR], C]sendcountR], C]sendtypeR], C]rootR], C]commR]
are significant. The arguments C]rootR] and C]commR] must have identical
values on all processes. <p>
The specification of counts and types should not
cause any location on the root to be written more than once. Such a call
is erroneous. Note that the C]recvcountR] argument at the root indicates
the number of items it receives from each process, not the total number
of items it receives. <p>
Example 1: Gather 100 ints from every process in group
to root. <br>
<pre>

</pre><p>

<dl>

<dt>C]MPI_Comm comm;int gsize,sendarray[100];int root, *rbuf;//...<a href="../man3/MPI_Comm_size.3.php">MPI_Comm_size</a>(
comm, &amp;gsize);rbuf = (int *)malloc(gsize*100*sizeof(int));<a href="../man3/MPI_Gather.3.php">MPI_Gather</a>( sendarray,
100, MPI_INT, rbuf, 100, MPI_INT, root, comm);R]Example 2: Previous example
modified [en] only the root allocates </dt>
<dd>memory for the receive buffer. <br>
<pre>

</pre></dd>
</dl>
<p>

<dl>

<dt>C]MPI_Comm comm;int gsize,sendarray[100];int root, myrank, *rbuf;//...<a href="../man3/MPI_Comm_rank.3.php">MPI_Comm_rank</a>(
comm, myrank);if ( myrank == root) {    <a href="../man3/MPI_Comm_size.3.php">MPI_Comm_size</a>( comm, &amp;gsize);
 rbuf = (int *)malloc(gsize*100*sizeof(int));}<a href="../man3/MPI_Gather.3.php">MPI_Gather</a>( sendarray, 100,
MPI_INT, rbuf, 100, MPI_INT, root, comm);R]Example 3: Do the same as the
previous example, but use a derived </dt>
<dd>datatype. Note that the type cannot
be the entire set of gsize * 100 ints since type matching is defined pairwise
between the root and each process in the gather. <br>
<pre>

</pre></dd>
</dl>

<h2><a name='sect8' href='#toc8'>C]MPI_Comm comm;int gsize,sendarray[100];int root, *rbuf;MPI_Datatype rtype;//...<a href="../man3/MPI_Comm_size.3.php">MPI_Comm_size</a>(
comm, &amp;gsize);<a href="../man3/MPI_Type_contiguous.3.php">MPI_Type_contiguous</a>( 100, MPI_INT, &amp;rtype );<a href="../man3/MPI_Type_commit.3.php">MPI_Type_commit</a>(
&amp;rtype );rbuf = (int *)malloc(gsize*100*sizeof(int));<a href="../man3/MPI_Gather.3.php">MPI_Gather</a>( sendarray,
100, MPI_INT, rbuf, 1, rtype, root, comm);R]Use Of In-Place Option</a></h2>
<p>
When the
communicator is an intracommunicator,
<dl>

<dt>you can perform a gather </dt>
<dd>operation
in-place (the output buffer is used as the input buffer). Use the variable
C]MPI_IN_PLACER] as the value of the root process C]sendbufR]. In this case,
C]sendcountR] and C]sendtypeR] are ignored, and the contribution of the
root process to the gathered vector is assumed to already be in the correct
place in the receive buffer. Note that C]MPI_IN_PLACER] is a special kind
of value; it has the same restrictions on its use as MPI_BOTTOM. Because
the in-place option converts the receive buffer into a send-and-receive buffer,
a Fortran binding that includes C]INTENTR] must mark these as C]INOUTR],
not C]OUTR]. </dd>
</dl>

<h2><a name='sect9' href='#toc9'>When Communicator Is An Inter-Communicator</a></h2>
<p>
When the communicator
is an inter-communicator, the root process in the first group gathers data
from all the processes in the second group. The first group defines the
root process. That process uses MPI_ROOT as the value of its C]rootR] argument.
The remaining processes use C]MPI_PROC_NULLR] as the value of their C]rootR]
argument. All processes in the second group use the rank of that root process
in the first group as the value of their C]rootR] argument. The send buffer
argument of the processes in the first group must be consistent with the
receive buffer argument of the root process in the second group.
<h2><a name='sect10' href='#toc10'>Errors</a></h2>
<p>
Almost
all MPI routines return an error value; C routines as the value of the
function and Fortran routines in the last argument. Before the error value
is returned, the current MPI error handler is called. By default, this error
handler aborts the MPI job, except for I/O function errors. The error handler
may be changed with C]MPI_Comm_set_errhandlerR]; the predefined error handler
C]MPI_ERRORS_RETURNR] may be used to cause error values to be returned.
Note that MPI does not guarantee that an MPI program can continue past
an error. See the MPI man page for a full list of MPI error codes.
<h2><a name='sect11' href='#toc11'>See Also</a></h2>
<p>
C]MPI_GathervR](3)
C]MPI_ScatterR](3) C]MPI_ScattervR](3)  <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<ul>
<li><a name='toc2' href='#sect2'>C Syntax</a></li>
<li><a name='toc3' href='#sect3'>C]#include <mpi.h>int <a href="../man3/MPI_Gather.3.php">MPI_Gather</a>(const void *sendbuf, int sendcount, MPI_Datatype sendtype,    void *recvbuf, int recvcount, MPI_Datatype recvtype, int root,    MPI_Comm comm)int MPI_Igather(const void *sendbuf, int sendcount, MPI_Datatype sendtype,    void *recvbuf, int recvcount, MPI_Datatype recvtype, int root,    MPI_Comm comm, MPI_Request *request)R]Fortran Syntax</a></li>
<li><a name='toc4' href='#sect4'>C]USE MPI! or the older form: INCLUDE [aq]mpif.h[aq]<a href="../man3/MPI_Gather.3.php">MPI_GATHER</a>(SENDBUF, SENDCOUNT, SENDTYPE, RECVBUF, RECVCOUNT,        RECVTYPE, ROOT, COMM, IERROR)    <type>  SENDBUF(*), RECVBUF(*)    INTEGER SENDCOUNT, SENDTYPE, RECVCOUNT, RECVTYPE, ROOT    INTEGER COMM, IERRORMPI_IGATHER(SENDBUF, SENDCOUNT, SENDTYPE, RECVBUF, RECVCOUNT,        RECVTYPE, ROOT, COMM, REQUEST, IERROR)    <type>  SENDBUF(*), RECVBUF(*)    INTEGER SENDCOUNT, SENDTYPE, RECVCOUNT, RECVTYPE, ROOT    INTEGER COMM, REQUEST, IERRORR]Fortran 2008 Syntax</a></li>
</ul>
<li><a name='toc5' href='#sect5'>C]USE mpi_f08MPI_Gather(sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype,        root, comm, ierror)    TYPE(*), DIMENSION(..), INTENT(IN) :: sendbuf    TYPE(*), DIMENSION(..) :: recvbuf    INTEGER, INTENT(IN) :: sendcount, recvcount, root    TYPE(MPI_Datatype), INTENT(IN) :: sendtype, recvtype    TYPE(MPI_Comm), INTENT(IN) :: comm    INTEGER, OPTIONAL, INTENT(OUT) :: ierrorMPI_Igather(sendbuf, sendcount, sendtype, recvbuf, recvcount, recvtype,        root, comm, request, ierror)    TYPE(*), DIMENSION(..), INTENT(IN), ASYNCHRONOUS :: sendbuf    TYPE(*), DIMENSION(..), ASYNCHRONOUS :: recvbuf    INTEGER, INTENT(IN) :: sendcount, recvcount, root    TYPE(MPI_Datatype), INTENT(IN) :: sendtype, recvtype    TYPE(MPI_Comm), INTENT(IN) :: comm    TYPE(MPI_Request), INTENT(OUT) :: request    INTEGER, OPTIONAL, INTENT(OUT) :: ierrorR]Input Parameters</a></li>
<li><a name='toc6' href='#sect6'>Output Parameters</a></li>
<li><a name='toc7' href='#sect7'>Description</a></li>
<li><a name='toc8' href='#sect8'>C]MPI_Comm comm;int gsize,sendarray[100];int root, *rbuf;MPI_Datatype rtype;//...<a href="../man3/MPI_Comm_size.3.php">MPI_Comm_size</a>( comm, &gsize);<a href="../man3/MPI_Type_contiguous.3.php">MPI_Type_contiguous</a>( 100, MPI_INT, &rtype );<a href="../man3/MPI_Type_commit.3.php">MPI_Type_commit</a>( &rtype );rbuf = (int *)malloc(gsize*100*sizeof(int));<a href="../man3/MPI_Gather.3.php">MPI_Gather</a>( sendarray, 100, MPI_INT, rbuf, 1, rtype, root, comm);R]Use Of In-Place Option</a></li>
<li><a name='toc9' href='#sect9'>When Communicator Is An Inter-Communicator</a></li>
<li><a name='toc10' href='#sect10'>Errors</a></li>
<li><a name='toc11' href='#sect11'>See Also</a></li>
</ul>


<p> <a href="../">&laquo; Return to documentation listing</a></p>
<?php
include_once("$topdir/includes/footer.inc");
