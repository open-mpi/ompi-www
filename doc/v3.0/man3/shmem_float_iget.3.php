<?php
$topdir = "../../..";
$title = "shmem_float_iget(3) man page (version 3.0.5)";
$meta_desc = "Open MPI v3.0.5 man page: shmem_float_iget(3)";

include_once("$topdir/doc/nav.inc");
include_once("$topdir/includes/header.inc");
?>
<p> <a href="../">&laquo; Return to documentation listing</a></p>
    <!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>

<p> <i><i>shmem_complex_iget</i>(3)</i>, <i><i>shmem_double_iget</i>(3)</i>, <i><i>shmem_float_iget</i>(3)</i>,
<i><i>shmem_iget4</i>(3)</i>, <i><i>shmem_iget8</i>(3)</i>, <i><i>shmem_iget32</i>(3)</i>, <i><i>shmem_iget64</i>(3)</i>, <i><i>shmem_iget128</i>(3)</i>,
<i><i>shmem_int_iget</i>(3)</i>, <i><i>shmem_integer_iget</i>(3)</i>, <i><i>shmem_logical_iget</i>(3)</i>, <i><i>shmem_long_iget</i>(3)</i>,
<i><i>shmem_longdouble_iget</i>(3)</i>, <i><i>shmem_longlong_iget</i>(3)</i>, <i><i>shmem_real_iget</i>(3)</i>, <i><i>shmem_short_iget</i>(3)</i>
- Transfers strided data from a specified processing element (PE)
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>

<p>
C or C++: <br>
<pre>#include &lt;mpp/shmem.h&gt;
void shmem_iget32(void *target, const void *source,
  ptrdiff_t tst, ptrdiff_t sst, size_t len, int pe);
void shmem_iget64(void *target, const void *source,
  ptrdiff_t tst, ptrdiff_t sst, size_t len, int pe);
void shmem_iget128(void *target, const void *source,
  ptrdiff_t tst, ptrdiff_t sst, size_t len, int pe);
void shmem_int_iget(int *target, const int *source,
  ptrdiff_t tst, ptrdiff_t sst, size_t len, int pe);
void shmem_double_iget(double *target, const double *source,
  ptrdiff_t tst, ptrdiff_t sst, size_t len, int pe);
void shmem_float_iget(float *target, const float *source,
  ptrdiff_t tst, ptrdiff_t sst, size_t len, int pe);
void shmem_long_iget(long *target, const long *source,
  ptrdiff_t tst, ptrdiff_t sst, size_t len, int pe);
void shmem_longdouble_iget(long double *target,
  const long double *source, ptrdiff_t tst, ptrdiff_t sst,size_t len, int
pe);
void shmem_longlong_iget(long long *target,
  const long long *source, ptrdiff_t tst, ptrdiff_t sst, size_t len, int
pe);
void shmem_short_iget(short *target,
  const short *source, ptrdiff_t tst, ptrdiff_t sst, size_t len, int pe);
</pre> Fortran: <br>
<pre>INCLUDE "mpp/shmem.fh"
INTEGER tst, sst, len, pe
CALL SHMEM_COMPLEX_IGET(target, source, tst, sst, len,
&amp; pe)
CALL SHMEM_DOUBLE_IGET(target, source, tst, sst, len,
&amp; pe)
CALL SHMEM_IGET4(target, source, tst, sst, len, pe)
CALL SHMEM_IGET8(target, source, tst, sst, len, pe)
CALL SHMEM_IGET32(target, source, tst, sst, len, pe)
CALL SHMEM_IGET64(target, source, tst, sst, len, pe)
CALL SHMEM_IGET128(target, source, tst, sst, len, pe)
CALL SHMEM_INTEGER_IGET(target, source, tst, sst, len,
&amp; pe)
CALL SHMEM_LOGICAL_IGET(target, source, tst, sst, len,
&amp; pe)
CALL SHMEM_REAL_IGET(target, source, tst, sst, len, pe)
</pre>
<h2><a name='sect2' href='#toc2'>Description</a></h2>

<p> The strided get routines retrieve array data available at
address source on remote <i>PE (pe)</i>. The elements of the <b>source</b> array are separated
by a stride <b>sst</b>. Once the data is received, it is stored at the local memory
address <b>target</b>, separated by stride <b>tst</b>. The routines return when the data
has been copied into the local <b>target</b> array. <p>
The arguments are as follows:

<dl>

<dt>target </dt>
<dd>Array to be updated on the local PE. </dd>

<dt>source </dt>
<dd>Array containing the
data to be copied on the remote PE. </dd>

<dt>tst </dt>
<dd>The stride between consecutive elements
of the target array. The stride is scaled by the element size of the target
array. A value of 1 indicates contiguous data. tst must be of type integer.
If you are calling from Fortran, it must be a default integer value. </dd>

<dt>sst
</dt>
<dd>The stride between consecutive elements of the source array. The stride
is scaled by the element size of the source array. A value of 1 indicates
contiguous data. sst must be of type integer. If you are calling from Fortran,
it must be a default integer value. </dd>

<dt>len </dt>
<dd>Number of elements in the target
and source arrays. len must be of type integer. If you are using Fortran,
it must be a constant, variable, or array element of default integer type.
</dd>

<dt>pe </dt>
<dd>PE number of the remote PE. pe must be of type integer. If you are using
Fortran, it must be a constant, variable, or array element of default integer
type. </dd>
</dl>
<p>
The target and source data objects must conform to typing constraints,
which are as follows:
<dl>

<dt><b>shmem_iget32, shmem_iget4</b>: Any noncharacter type
that has a storage size </dt>
<dd>equal to 32 bits. </dd>

<dt><b>shmem_iget64, shmem_iget8</b>: Any
noncharacter type that has a storage size </dt>
<dd>equal to 64 bits. </dd>

<dt><b>shmem_iget128</b>:
Any noncharacter type that has a storage size equal to </dt>
<dd>128 bits. </dd>

<dt><b>shmem_short_iget</b>:
Elements of type short. </dt>
<dd></dd>

<dt><b>shmem_int_iget</b>: Elements of type int. </dt>
<dd></dd>

<dt><b>shmem_long_iget</b>:
Elements of type long. </dt>
<dd></dd>

<dt><b>shmem_longlong_iget</b>: Elements of type long long. </dt>
<dd></dd>

<dt><b>shmem_float_iget</b>:
Elements of type float. </dt>
<dd></dd>

<dt><b>shmem_double_iget</b>: Elements of type double. </dt>
<dd></dd>

<dt><b>shmem_longdouble_iget</b>:
Elements of type long double. </dt>
<dd></dd>

<dt><b>SHMEM_COMPLEX_IGET</b>: Elements of type complex
of default size. </dt>
<dd></dd>

<dt><b>SHMEM_DOUBLE_IGET</b>: (Fortran) Elements of type double precision.
</dt>
<dd></dd>

<dt><b>SHMEM_INTEGER_IGET</b>: Elements of type integer. </dt>
<dd></dd>

<dt><b>SHMEM_LOGICAL_IGET</b>: Elements
of type logical. </dt>
<dd></dd>

<dt><b>SHMEM_REAL_IGET</b>: Elements of type real. </dt>
<dd></dd>

<dt><b>shmem_longdouble_iget</b>:
Elements of type long double. </dt>
<dd></dd>

<dt><b>SHMEM_COMPLEX_IGET</b>: Elements of type complex
of default size. </dt>
<dd></dd>

<dt><b>SHMEM_DOUBLE_IGET</b>: (Fortran) Elements of type double precision.
</dt>
<dd></dd>

<dt><b>SHMEM_INTEGER_IGET</b>: Elements of type integer. </dt>
<dd></dd>

<dt><b>SHMEM_LOGICAL_IGET</b>: Elements
of type logical. </dt>
<dd></dd>

<dt><b>SHMEM_REAL_IGET</b>: Elements of type real. </dt>
<dd></dd>
</dl>
<p>
If you are using
Fortran, data types must be of default size. For example, a real variable
must be declared as REAL, REAL*4, or REAL(KIND=4). <p>

<h2><a name='sect3' href='#toc3'>Notes</a></h2>

<p> See <i><i>intro_shmem</i>(3)</i>
for a definition of the term remotely accessible. <p>

<h2><a name='sect4' href='#toc4'>Examples</a></h2>

<p> The following
simple example uses shmem_logical_iget in a Fortran program. Compile this
example with the -lsma compiler option. <br>
<pre>PROGRAM STRIDELOGICAL
  LOGICAL SOURCE(10), TARGET(5)
  SAVE SOURCE ! SAVE MAKES IT REMOTELY ACCESSIBLE
  DATA SOURCE /.T.,.F.,.T.,.F.,.T.,.F.,.T.,.F.,.T.,.F./
  DATA TARGET / 5*.F. /
  CALL START_PES(2)
  IF (MY_PE() .EQ. 0) THEN
    CALL SHMEM_LOGICAL_IGET(TARGET, SOURCE, 1, 2, 5, 1)
    PRINT*,&rsquo;TARGET AFTER SHMEM_LOGICAL_IGET:&rsquo;,TARGET
  ENDIF
  CALL SHMEM_BARRIER_ALL
END
</pre>
<h2><a name='sect5' href='#toc5'>See Also</a></h2>

<p> <i><i>intro_shmem</i>(3)</i>, <i><i>shmem_get</i>(3)</i>, <i><i>shmem_quiet</i>(3)</i>  <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Notes</a></li>
<li><a name='toc4' href='#sect4'>Examples</a></li>
<li><a name='toc5' href='#sect5'>See Also</a></li>
</ul>


<p> <a href="../">&laquo; Return to documentation listing</a></p>
<?php
include_once("$topdir/includes/footer.inc");
