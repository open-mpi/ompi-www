<?php
$topdir = "../../..";
$title = "shmem_broadcast32(3) man page (version 3.0.2)";
$meta_desc = "Open MPI v3.0.2 man page: shmem_broadcast32(3)";

include_once("$topdir/doc/nav.inc");
include_once("$topdir/includes/header.inc");
?>
<p> <a href="../">&laquo; Return to documentation listing</a></p>
    <!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>

<p> <i><i>shmem_broadcast4</i>(3)</i>, <i><i>shmem_broadcast8</i>(3)</i>, <i><i>shmem_broadcast32</i>(3)</i>,
<i><i>shmem_broadcast64</i>(3)</i> - Copy a data object from a designated PE to a target
location on all other PEs of the active set.
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>

<p> C or C++: <br>
<pre>#include &lt;mpp/shmem.h&gt;
void shmem_broadcast32(void *target, const void *source,
  size_t nelems, int PE_root, int PE_start, int logPE_stride,
  int PE_size, long *pSync);
void shmem_broadcast64(void *target, const void *source,
  size_t nelems, int PE_root, int PE_start, int logPE_stride,
  int PE_size, long *pSync);
</pre> Fortran: <br>
<pre>INCLUDE "mpp/shmem.fh"
INTEGER nelems, PE_root, PE_start, logPE_stride, PE_size
INTEGER pSync(SHMEM_BCAST_SYNC_SIZE)
CALL SHMEM_BROADCAST4(target, source, nelems, PE_root,
&amp; PE_start, logPE_stride, PE_size, fIpSync)
CALL SHMEM_BROADCAST8(target, source, nelems, PE_root,
&amp; PE_start, logPE_stride, PE_size, pSync)
CALL SHMEM_BROADCAST32(target, source, nelems,
&amp; PE_root, PE_start, logPE_stride, PE_size, pSync)
CALL SHMEM_BROADCAST64(target, source, nelems,
&amp; PE_root, PE_start, logPE_stride, PE_size, pSync)
</pre>
<h2><a name='sect2' href='#toc2'>Description</a></h2>

<p> The broadcast routines write the data at address source of
the PE specified by <b>PE_root</b> to address <b>target</b> on all other PEs in the active
set. The active set of PEs is defined by the triplet <b>PE_start</b>, <b>logPE_stride</b>
and <b>PE_size</b>. The data is not copied to the target address on the PE specified
by <b>PE_root</b>. Before returning, the broadcast routines ensure that the elements
of the pSync array are restored to their initial values. <p>
As with all SHMEM
collective routines, each of these routines assumes that only PEs in the
active set call the routine. If a PE not in the active set calls a SHMEM
collective routine, undefined behavior results. <p>
The arguments are as follows:

<dl>

<dt>target </dt>
<dd>A symmetric data object with one of the following data types: <blockquote></dd>

<dt><b>shmem_broadcast8,
shmem_broadcast64</b>: Any noncharacter type that </dt>
<dd>has an element size of 64
bits. No Fortran derived types or C/C++ structures are allowed. </dd>

<dt><b>shmem_broadcast32</b>:
Any noncharacter type that has an element size </dt>
<dd>of 32 bits. No Fortran derived
types or C/C++ structures are allowed. </dd>

<dt><b>shmem_broadcast4</b>: Any noncharacter
type that has an element size </dt>
<dd>of 32 bits. </dd>
</dl>
</blockquote>
<blockquote><p>
</blockquote>

<dl>

<dt>source </dt>
<dd>A symmetric data object
that can be of any data type that is permissible for the target argument.
</dd>

<dt>nelems </dt>
<dd>The number of elements in source. For shmem_broadcast32 and shmem_broadcast4,
this is the number of 32-bit halfwords. nelems must be of type integer. If
you are using Fortran, it must be a default integer value. </dd>

<dt>PE_root </dt>
<dd>Zero-based
ordinal of the PE, with respect to the active set, from which the data
is copied. Must be greater than or equal to 0 and less than PE_size. PE_root
must be of type integer. If you are using Fortran, it must be a default
integer value. </dd>

<dt>PE_start </dt>
<dd>The lowest virtual PE number of the active set of
PEs. PE_start must be of type integer. If you are using Fortran, it must
be a default integer value. </dd>

<dt>logPE_stride </dt>
<dd>The log (base 2) of the stride
between consecutive virtual PE numbers in the active set. log_PE_stride
must be of type integer. If you are using Fortran, it must be a default
integer value. </dd>

<dt>PE_size </dt>
<dd>The number of PEs in the active set. PE_size must
be of type integer. If you are using Fortran, it must be a default integer
value. </dd>
</dl>
<p>

<dl>

<dt>pSync </dt>
<dd>A symmetric work array. In C/C++, pSync must be of type long
and size _SHMEM_BCAST_SYNC_SIZE. In Fortran, pSync must be of type integer
and size SHMEM_BCAST_SYNC_SIZE. Every element of this array must be initialized
with the value _SHMEM_SYNC_VALUE (in C/C++) or SHMEM_SYNC_VALUE (in Fortran)
before any of the PEs in the active set enter shmem_barrier(). </dd>
</dl>
<p>
The values
of arguments PE_root, PE_start, logPE_stride, and PE_size must be equal
on all PEs in the active set. The same target and source data objects and
the same pSync work array must be passed to all PEs in the active set. <p>
Before
any PE calls a broadcast routine, you must ensure that the following conditions
exist (synchronization via a barrier or some other method is often needed
to ensure this): The pSync array on all PEs in the active set is not still
in use from a prior call to a broadcast routine. The target array on all
PEs in the active set is ready to accept the broadcast data. <p>
Upon return
from a broadcast routine, the following are true for the local PE: If the
current PE is not the root PE, the target data object is updated. The values
in the pSync array are restored to the original values.
<h2><a name='sect3' href='#toc3'>Notes</a></h2>

<p> The terms
collective and symmetric are defined in <i><i>intro_shmem</i>(3)</i>. <p>
All SHMEM broadcast
routines restore pSync to its original contents. Multiple calls to SHMEM
routines that use the same pSync array do not require that pSync be reinitialized
after the first call. <p>
You must ensure the that the pSync array is not being
updated by any PE in the active set while any of the PEs participates in
processing of a SHMEM broadcast routine. Be careful to avoid these situations:
If the pSync array is initialized at run time, some type of synchronization
is needed to ensure that all PEs in the working set have initialized pSync
before any of them enter a SHMEM routine called with the pSync synchronization
array. A pSync array may be reused on a subsequent SHMEM broadcast routine
only if none of the PEs in the active set are still processing a prior
SHMEM broadcast routine call that used the same pSync array. In general,
this can be ensured only by doing some type of synchronization. However,
in the special case of SHMEM routines being called with the same active
set, you can allocate two pSync arrays and alternate between them on successive
calls. <p>

<h2><a name='sect4' href='#toc4'>Examples</a></h2>

<p> In the following examples, the call to shmem_broadcast64
copies source on PE 4 to target on PEs 5, 6, and 7. <p>
C/C++ example: <br>
<pre>for (i=0; i &lt; _SHMEM_BCAST_SYNC_SIZE; i++) {
  pSync[i] = _SHMEM_SYNC_VALUE;
}
shmem_barrier_all(); /* Wait for all PEs to initialize pSync */
shmem_broadcast64(target, source, nelems, 0, 4, 0, 4, pSync);
</pre> Fortran example: <br>
<pre>INTEGER PSYNC(SHMEM_BCAST_SYNC_SIZE)
INTEGER TARGET, SOURCE, NELEMS, PE_ROOT, PE_START,
&amp; LOGPE_STRIDE, PE_SIZE, PSYNC
COMMON /COM/ TARGET, SOURCE
DATA PSYNC /SHMEM_BCAST_SYNC_SIZE*SHMEM_SYNC_VALUE/
CALL SHMEM_BROADCAST64(TARGET, SOURCE, NELEMS, 0, 4, 0, 4,
&amp; PSYNC)
</pre> <p>

<h2><a name='sect5' href='#toc5'>See Also</a></h2>

<p> <i><i>intro_shmem</i>(3)</i> <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Notes</a></li>
<li><a name='toc4' href='#sect4'>Examples</a></li>
<li><a name='toc5' href='#sect5'>See Also</a></li>
</ul>


<p> <a href="../">&laquo; Return to documentation listing</a></p>
<?php
include_once("$topdir/includes/footer.inc");
