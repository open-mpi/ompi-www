<?php
$topdir = "../../..";
$title = "shmem_longlong_max_to_all(3) man page (version 3.0.3)";
$meta_desc = "Open MPI v3.0.3 man page: shmem_longlong_max_to_all(3)";

include_once("$topdir/doc/nav.inc");
include_once("$topdir/includes/header.inc");
?>
<p> <a href="../">&laquo; Return to documentation listing</a></p>
    <!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>

<p> <i><i>shmem_double_max_to_all</i>(3)</i>, <i><i>shmem_float_max_to_all</i>(3)</i>, <i><i>shmem_int_max_to_all</i>(3)</i>,
<i><i>shmem_int4_max_to_all</i>(3)</i>, <i><i>shmem_int8_max_to_all</i>(3)</i>, <i><i>shmem_long_max_to_all</i>(3)</i>,
<i><i>shmem_longdouble_max_to_all</i>(3)</i>, <i><i>shmem_longlong_max_to_all</i>(3)</i>, <i><i>shmem_real4_max_to_all</i>(3)</i>,
<i><i>shmem_real8_max_to_all</i>(3)</i>, <i><i>shmem_real16_max_to_all</i>(3)</i>, <i><i>shmem_short_max_to_all</i>(3)</i>
- Performs a maximum function reduction across a set of processing elements
(PEs).
<h2><a name='sect1' href='#toc1'>Synopsis</a></h2>

<p> C or C++: <br>
<pre>#include &lt;mpp/shmem.h&gt;
void shmem_double_max_to_all(double *target, const double *source,
  int nreduce, int PE_start, int logPE_stride, int PE_size,
  double *pWrk, long *pSync);
void shmem_float_max_to_all(float *target, const float *source,
  int nreduce, int PE_start, int logPE_stride, int PE_size,
  float *pWrk, long *pSync);
void shmem_int_max_to_all(int *target, const int *source,
  int nreduce, int PE_start, int logPE_stride, int PE_size,
  int *pWrk, long *pSync);
void shmem_long_max_to_all(long *target, const long *source,
  int nreduce, int PE_start, int logPE_stride, int PE_size,
  long *pWrk, long *pSync);
void shmem_longdouble_max_to_all(long double *target,
  const long double *source, int nreduce, int PE_start,
  int logPE_stride, int PE_size, long double *pWrk, long *pSync);
void shmem_longlong_max_to_all(long long *target,
  const long long *source, int nreduce,  int PE_start,
  int logPE_stride, int PE_size, long long *pWrk, long *pSync);
 void shmem_short_max_to_all(short *target, const short *source,
  int nreduce, int PE_start, int logPE_stride, int PE_size,
  short *pWrk, long *pSync);
</pre> Fortran: <br>
<pre>INCLUDE "mpp/shmem.fh"
INTEGER pSync(SHMEM_REDUCE_SYNC_SIZE)
INTEGER nreduce, PE_start, logPE_stride, PE_size
CALL SHMEM_INT4_MAX_TO_ALL(target, source, nreduce,
&amp; PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_INT8_MAX_TO_ALL(target, source, nreduce,
&amp; PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL4_MAX_TO_ALL(target, source, nreduce,
&amp; PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL8_MAX_TO_ALL(target, source, nreduce,
&amp; PE_start, logPE_stride, PE_size, pWrk, pSync)
CALL SHMEM_REAL16_MAX_TO_ALL(target, source, nreduce,
&amp; PE_start, logPE_stride, PE_size, pWrk, pSync)
</pre>
<h2><a name='sect2' href='#toc2'>Description</a></h2>

<p> The shared memory (SHMEM) reduction routines compute one or
more reductions across symmetric arrays on multiple virtual PEs. A reduction
performs an associative binary operation across a set of values. For a list
of other SHMEM reduction routines, see <i><i>intro_shmem</i>(3)</i>. <p>
As with all SHMEM
collective routines, each of these routines assumes that only PEs in the
active set call the routine. If a PE not in the active set calls a SHMEM
collective routine, undefined behavior results. <p>
The nreduce argument determines
the number of separate reductions to perform. The source array on all PEs
in the active set provides one element for each reduction. The results of
the reductions are placed in the target array on all PEs in the active
set. The active set is defined by the PE_start, logPE_stride, PE_size triplet.
<p>
The source and target arrays may be the same array, but they may not be
overlapping arrays. <p>
The arguments are as follows:
<dl>

<dt>target </dt>
<dd>A symmetric array
of length nreduce elements to receive the results of the reduction operations.
The data type of target varies with the version of the reduction routine
being called. When calling from C, refer to the SYNOPSIS section for data
type information. </dd>
</dl>
<p>
When calling from Fortran, the target data types are as
follows: <blockquote>
<dl>

<dt><b>shmem_comp8_max_to_all</b>: Complex, with an element size equal to
two </dt>
<dd>8-byte real values. </dd>

<dt><b>shmem_int4_max_to_all</b>: Integer, with an element size
of 4 bytes. </dt>
<dd></dd>

<dt><b>shmem_int8_max_to_all</b>: Integer, with an element size of 8 bytes.
</dt>
<dd></dd>

<dt><b>shmem_real4_max_to_all</b>: Real, with an element size of 4 bytes. </dt>
<dd></dd>

<dt><b>shmem_real16_max_to_all</b>:
Real, with an element size of 16 bytes. </dt>
<dd></dd>
</dl>
</blockquote>
<blockquote><p>
</blockquote>

<dl>

<dt>source </dt>
<dd>A symmetric array of length
nreduce elements that contains one element for each separate reduction
operation. The source argument must have the same data type as target. </dd>

<dt>nreduce
</dt>
<dd>The number of elements in the target and source arrays. nreduce must be
of type integer. If you are using Fortran, it must be a default integer
value. </dd>

<dt>PE_start </dt>
<dd>The lowest virtual PE number of the active set of PEs. PE_start
must be of type integer. If you are using Fortran, it must be a default
integer value. </dd>

<dt>logPE_stride </dt>
<dd>The log (base 2) of the stride between consecutive
virtual PE numbers in the active set. logPE_stride must be of type integer.
If you are using Fortran, it must be a default integer value. </dd>

<dt>PE_size </dt>
<dd>The
number of PEs in the active set. PE_size must be of type integer. If you
are using Fortran, it must be a default integer value. </dd>

<dt>pWrk </dt>
<dd>A symmetric
work array. The pWrk argument must have the same data type as target. In
C/C++, this contains max(nreduce/2 + 1, _SHMEM_REDUCE_MIN_WRKDATA_SIZE)
elements. In Fortran, this contains max(nreduce/2 + 1, SHMEM_REDUCE_MIN_WRKDATA_SIZE)
elements. </dd>

<dt>pSync </dt>
<dd>A symmetric work array. In C/C++, pSync is of type long and
size _SHMEM_REDUCE_SYNC_SIZE. In Fortran, pSync is of type integer and size
SHMEM_REDUCE_SYNC_SIZE. If you are using Fortran, it must be a default integer
value. Every element of this array must be initialized with the value _SHMEM_SYNC_VALUE
(in C/C++) or SHMEM_SYNC_VALUE (in Fortran) before any of the PEs in the
active set enter the reduction routine. </dd>
</dl>
<p>
The values of arguments nreduce,
PE_start, logPE_stride, and PE_size must be equal on all PEs in the active
set. The same target and source arrays, and the same pWrk and pSync work
arrays, must be passed to all PEs in the active set. <p>
Before any PE calls
a reduction routine, you must ensure that the following conditions exist
(synchronization via a barrier or some other method is often needed to
ensure this): The pWrk and pSync arrays on all PEs in the active set are
not still in use from a prior call to a collective SHMEM routine. The target
array on all PEs in the active set is ready to accept the results of the
reduction. <p>
Upon return from a reduction routine, the following are true
for the local PE: The target array is updated. The values in the pSync array
are restored to the original values. <p>

<h2><a name='sect3' href='#toc3'>Notes</a></h2>

<p> The terms collective, symmetric,
and cache aligned are defined in <i><i>intro_shmem</i>(3)</i>. All SHMEM reduction routines
reset the values in pSync before they return, so a particular pSync buffer
need only be initialized the first time it is used. <p>
You must ensure that
the pSync array is not being updated on any PE in the active set while
any of the PEs participate in processing of a SHMEM reduction routine. Be
careful of the following situations: If the pSync array is initialized
at run time, some type of synchronization is needed to ensure that all
PEs in the working set have initialized pSync before any of them enter
a SHMEM routine called with the pSync synchronization array. A pSync or
pWrk array can be reused in a subsequent reduction routine call only if
none of the PEs in the active set are still processing a prior reduction
routine call that used the same pSync or pWrk arrays. <p>
In general, this can
be assured only by doing some type of synchronization. However, in the special
case of reduction routines being called with the same active set, you can
allocate two pSync and pWrk arrays and alternate between them on successive
calls. <p>

<h2><a name='sect4' href='#toc4'>Examples</a></h2>

<p> <b>Example 1:</b> This Fortran example statically initializes the
pSync array and finds the maximum value of real variable FOO across all
even PEs. <br>
<pre>INCLUDE "mpp/shmem.fh"
INTEGER PSYNC(SHMEM_REDUCE_SYNC_SIZE)
DATA PSYNC /SHMEM_REDUCE_SYNC_SIZE*SHMEM_SYNC_VALUE/
PARAMETER (NR=1)
REAL FOO, FOOMAX, PWRK(MAX(NR/2+1,SHMEM_REDUCE_MIN_WRKDATA_SIZE))
COMMON /COM/ FOO, FOOMAX, PWRK
INTRINSIC MY_PE
IF ( MOD(MY_PE(),2) .EQ. 0) THEN
  CALL SHMEM_REAL8_MAX_TO_ALL(FOOMAX, FOO, NR, 0, 1, N$PES/2,
  &amp; PWRK, PSYNC)
  PRINT *, &rsquo;Result on PE &rsquo;, MY_PE(), &rsquo; is &rsquo;, FOOMAX
ENDIF
</pre> <b>Example 2:</b> Consider the following C/C++ call: <br>
<pre>shmem_int_max_to_all( target, source, 3, 0, 0, 8, pwrk, psync );
</pre> The preceding call is more efficient, but semantically equivalent to,
the combination of the following calls: <br>
<pre>shmem_int_max_to_all(&amp;(target[0]), &amp;(source[0]), 1, 0, 0, 8,
  pwrk1, psync1);
shmem_int_max_to_all(&amp;(target[1]), &amp;(source[1]), 1, 0, 0, 8,
  pwrk2, psync2);
shmem_int_max_to_all(&amp;(target[2]), &amp;(source[2]), 1, 0, 0, 8,
  pwrk1, psync1);
</pre> Note that two sets of pWrk and pSync arrays are used alternately because
no synchronization is done between calls.
<h2><a name='sect5' href='#toc5'>See Also</a></h2>

<p> <i><i>intro_shmem</i>(3)</i>  <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Synopsis</a></li>
<li><a name='toc2' href='#sect2'>Description</a></li>
<li><a name='toc3' href='#sect3'>Notes</a></li>
<li><a name='toc4' href='#sect4'>Examples</a></li>
<li><a name='toc5' href='#sect5'>See Also</a></li>
</ul>


<p> <a href="../">&laquo; Return to documentation listing</a></p>
<?php
include_once("$topdir/includes/footer.inc");
