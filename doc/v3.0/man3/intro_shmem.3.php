<?php
$topdir = "../../..";
$title = "intro_shmem(3) man page (version 3.0.2)";
$meta_desc = "Open MPI v3.0.2 man page: intro_shmem(3)";

include_once("$topdir/doc/nav.inc");
include_once("$topdir/includes/header.inc");
?>
<p> <a href="../">&laquo; Return to documentation listing</a></p>
    <!-- manual page source format generated by PolyglotMan v3.2, -->
<!-- available at http://polyglotman.sourceforge.net/ -->

<body bgcolor='white'>
<a href='#toc'>Table of Contents</a><p>

<h2><a name='sect0' href='#toc0'>Name</a></h2>

<p> intro_shmem - Introduction to the OpenSHMEM programming model <p>

<h2><a name='sect1' href='#toc1'>Description</a></h2>

<p>
The SHMEM programming model consists of library routines that provide low-latency,
high-bandwidth communication for use in highly parallelized scalable programs.
The routines in the OpenSHMEM application programming interface (API) provide
a programming model for exchanging data between cooperating parallel processes.
The resulting programs are similar in style to Message Passing Interface
(MPI) programs. The SHMEM API can be used either alone or in combination
with MPI routines in the same parallel program. <p>
An OpenSHMEM program is
SPMD (single program, multiple data) in style. The SHMEM processes, called
processing elements or PEs, all start at the same time and they all run
the same program. Usually the PEs perform computation on their own subdomains
of the larger problem and periodically communicate with other PEs to exchange
information on which the next computation phase depends. <p>
The OpenSHMEM routines
minimize the overhead associated with data transfer requests, maximize
bandwidth and minimize data latency. Data latency is the period of time
that starts when a PE initiates a transfer of data and ends when a PE can
use the data. OpenSHMEM routines support remote data transfer through put
operations, which transfer data to a different PE, get operations, which
transfer data from a different PE, and remote pointers, which allow direct
references to data objects owned by another PE. Other operations supported
are collective broadcast and reduction, barrier synchronization, and atomic
memory operations. An atomic memory operation is an atomic read-and-update
operation, such as a fetch-and-increment, on a remote or local data object.
<p>

<h2><a name='sect2' href='#toc2'>Openshmem Routines</a></h2>

<p> This section lists the significant OpenSHMEM message-passing
routines.
<dl>

<dt>PE queries </dt>
<dd></dd>
</dl>
<p>
<blockquote>
<dl>

<dt><b>*</b> </dt>
<dd>C/C++ only: <blockquote></dd>
</dl>
<p>
<blockquote></blockquote>

<dl>

<dt><b>*</b> </dt>
<dd><i>_num_pes</i>(3) </dd>

<dt><b>*</b> </dt>
<dd><i>_my_pe</i>(3) </dd>
</dl>
</blockquote>
<blockquote><p>
</blockquote>

<dl>

<dt><b>*</b> </dt>
<dd>Fortran only:
<blockquote></dd>
</dl>
<p>
<blockquote></blockquote>

<dl>

<dt><b>*</b> </dt>
<dd><i><i>NUM_PES</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>MY_PE</i>(3)</i> </dd>
</dl>
</blockquote>
<blockquote><p>
</blockquote>
</blockquote>
<p>
</blockquote>

<dl>

<dt>Elemental data put routines </dt>
<dd></dd>
</dl>
<p>
<blockquote>
<dl>

<dt><b>*</b> </dt>
<dd>C/C++ only: <blockquote></dd>
</dl>
<p>
<blockquote></blockquote>

<dl>

<dt><b>*</b> </dt>
<dd><i><i>shmem_double_p</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_float_p</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int_p</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_long_p</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_short_p.</i>(3)</i>
</dd>
</dl>
</blockquote>
<blockquote><p>
</blockquote>
</blockquote>
<p>
</blockquote>

<dl>

<dt>Block data put routines </dt>
<dd></dd>
</dl>
<p>
<blockquote>
<dl>

<dt><b>*</b> </dt>
<dd>C/C++ and Fortran: <blockquote></dd>
</dl>
<p>
<blockquote></blockquote>

<dl>

<dt><b>*</b> </dt>
<dd><i><i>shmem_put32</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_put64</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_put128</i>(3)</i> </dd>
</dl>
</blockquote>
<blockquote><p>
</blockquote>

<dl>

<dt><b>*</b> </dt>
<dd>C/C++ only: <blockquote></dd>
</dl>
<p>
<blockquote></blockquote>

<dl>

<dt><b>*</b> </dt>
<dd><i><i>shmem_double_put</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_float_put</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int_put</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_long_put</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_short_put.</i>(3)</i> </dd>
</dl>
</blockquote>
<blockquote><p>
</blockquote>

<dl>

<dt><b>*</b> </dt>
<dd>Fortran only:
<blockquote></dd>
</dl>
<p>
<blockquote></blockquote>

<dl>

<dt><b>*</b> </dt>
<dd><i><i>shmem_complex_put</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_integer_put</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_logical_put</i>(3)</i> </dd>

<dt><b>*</b>
</dt>
<dd><i><i>shmem_real_put</i>(3)</i> </dd>
</dl>
</blockquote>
<blockquote><p>
</blockquote>
</blockquote>
<p>
</blockquote>

<dl>

<dt>Elemental data get routines </dt>
<dd></dd>
</dl>
<p>
<blockquote>
<dl>

<dt><b>*</b> </dt>
<dd>C/C++ only: <blockquote></dd>
</dl>
<p>
<blockquote></blockquote>

<dl>

<dt><b>*</b> </dt>
<dd><i><i>shmem_double_g</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_float_g</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int_g</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_long_g</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_short_g</i>(3)</i>
</dd>
</dl>
</blockquote>
<blockquote><p>
</blockquote>
</blockquote>
<p>
</blockquote>

<dl>

<dt>Block data get routines </dt>
<dd><blockquote></dd>

<dt><b>*</b> </dt>
<dd>C/C++ and Fortran: <blockquote></dd>
</dl>
<p>
<blockquote></blockquote>

<dl>

<dt><b>*</b> </dt>
<dd><i><i>shmem_get32</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_get64</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_get128</i>(3)</i> </dd>
</dl>
</blockquote>
<blockquote><p>
</blockquote>

<dl>

<dt><b>*</b> </dt>
<dd>C/C++ only: <blockquote></dd>
</dl>
<p>
<blockquote></blockquote>

<dl>

<dt><b>*</b> </dt>
<dd><i><i>shmem_double_get</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_float_get</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int_get</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_long_get</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_short_get</i>(3)</i> </dd>
</dl>
</blockquote>
<blockquote><p>
</blockquote>

<dl>

<dt><b>*</b> </dt>
<dd>Fortran only:
<blockquote></dd>
</dl>
<p>
<blockquote></blockquote>

<dl>

<dt><b>*</b> </dt>
<dd><i><i>shmem_complex_get</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_integer_get</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_logical_get</i>(3)</i> </dd>

<dt><b>*</b>
</dt>
<dd><i><i>shmem_real_get</i>(3)</i> </dd>
</dl>
</blockquote>
<blockquote><p>
</blockquote>
</blockquote>
<p>
</blockquote>

<dl>

<dt>Strided put routines </dt>
<dd><blockquote></dd>

<dt><b>*</b> </dt>
<dd>C/C++ and Fortran: <blockquote></dd>
</dl>
<p>
<blockquote></blockquote>

<dl>

<dt><b>*</b> </dt>
<dd><i><i>shmem_iput32</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_iput64</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_iput128</i>(3)</i> </dd>
</dl>
</blockquote>
<blockquote><p>
</blockquote>

<dl>

<dt><b>*</b> </dt>
<dd>C/C++ only: <blockquote></dd>
</dl>
<p>
<blockquote></blockquote>

<dl>

<dt><b>*</b> </dt>
<dd><i><i>shmem_double_iput</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_float_iput</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int_iput</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_long_iput</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_short_iput</i>(3)</i>
</dd>
</dl>
</blockquote>
<blockquote><p>
</blockquote>

<dl>

<dt><b>*</b> </dt>
<dd>Fortran only: <blockquote></dd>
</dl>
<p>
<blockquote></blockquote>

<dl>

<dt><b>*</b> </dt>
<dd><i><i>shmem_complex_iput</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_integer_iput</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_logical_iput</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_real_iput</i>(3)</i> </dd>
</dl>
</blockquote>
<blockquote><p>
</blockquote>
</blockquote>
<p>
</blockquote>

<dl>

<dt>Strided get routines </dt>
<dd></dd>
</dl>
<p>
<blockquote>
<dl>

<dt><b>*</b> </dt>
<dd>C/C++ and Fortran: <blockquote></dd>
</dl>
<p>
<blockquote></blockquote>

<dl>

<dt><b>*</b> </dt>
<dd><i><i>shmem_iget32</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_iget64</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_iget128</i>(3)</i> </dd>
</dl>
</blockquote>
<blockquote><p>
</blockquote>

<dl>

<dt><b>*</b> </dt>
<dd>C/C++ only: <blockquote></dd>
</dl>
<p>
<blockquote></blockquote>

<dl>

<dt><b>*</b> </dt>
<dd><i><i>shmem_double_iget</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_float_iget</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int_iget</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_long_iget</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_short_iget</i>(3)</i>
</dd>
</dl>
</blockquote>
<blockquote><p>
</blockquote>

<dl>

<dt><b>*</b> </dt>
<dd>Fortran only: <blockquote></dd>
</dl>
<p>
<blockquote></blockquote>

<dl>

<dt><b>*</b> </dt>
<dd><i><i>shmem_complex_iget</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_integer_iget</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_logical_iget</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_real_iget</i>(3)</i> </dd>
</dl>
</blockquote>
<blockquote><p>
</blockquote>
</blockquote>
<p>
</blockquote>

<dl>

<dt>Point-to-point synchronization routines </dt>
<dd><blockquote></dd>

<dt><b>*</b> </dt>
<dd>C/C++ only:
<blockquote></dd>
</dl>
<p>
<blockquote></blockquote>

<dl>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int_wait</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int_wait_until</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_long_wait</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_long_wait_until</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_longlong_wait</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_longlong_wait_until</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_short_wait</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_short_wait_until</i>(3)</i> </dd>
</dl>
</blockquote>
<blockquote><p>
</blockquote>

<dl>

<dt><b>*</b> </dt>
<dd>Fortran: <blockquote></dd>
</dl>
<p>
<blockquote></blockquote>

<dl>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int4_wait</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int4_wait_until</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int8_wait</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int8_wait_until</i>(3)</i> </dd>
</dl>
</blockquote>
<blockquote><p>
</blockquote>
</blockquote>
<p>
</blockquote>

<dl>

<dt>Barrier synchronization
routines </dt>
<dd></dd>
</dl>
<p>
<blockquote>
<dl>

<dt><b>*</b> </dt>
<dd>C/C++ and Fortran: <blockquote></dd>
</dl>
<p>
<blockquote></blockquote>

<dl>

<dt><b>*</b> </dt>
<dd><i><i>shmem_barrier_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_barrier</i>(3)</i>
</dd>
</dl>
</blockquote>
<blockquote><p>
</blockquote>
</blockquote>
<p>
</blockquote>

<dl>

<dt>Atomic memory fetch-and-operate (fetch-op) routines </dt>
<dd><blockquote></dd>

<dt><b>*</b> </dt>
<dd>C/C++ and Fortran: <blockquote></dd>

<dt><b>*</b>
</dt>
<dd></dd>
</dl>
shmem_swap </blockquote>
<blockquote><p>
</blockquote>
</blockquote>
<p>
</blockquote>

<dl>

<dt>Reduction routines </dt>
<dd><blockquote></dd>

<dt><b>*</b> </dt>
<dd>C/C++ only: <blockquote></dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int_and_to_all</i>(3)</i> </dd>

<dt><b>*</b>
</dt>
<dd><i><i>shmem_long_and_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_longlong_and_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_short_and_to_all</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_double_max_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_float_max_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int_max_to_all</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_long_max_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_longlong_max_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_short_max_to_all</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_double_min_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_float_min_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int_min_to_all</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_long_min_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_longlong_min_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_short_min_to_all</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_double_sum_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_float_sum_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int_sum_to_all</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_long_sum_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_longlong_sum_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_short_sum_to_all</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_double_prod_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_float_prod_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int_prod_to_all</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_long_prod_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_longlong_prod_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_short_prod_to_all</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int_or_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_long_or_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_longlong_or_to_all</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_short_or_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int_xor_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_long_xor_to_all</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_longlong_xor_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_short_xor_to_all</i>(3)</i> </dd>
</dl>
</blockquote>
<blockquote><p>
</blockquote>

<dl>

<dt><b>*</b> </dt>
<dd>Fortran only:
<blockquote></dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int4_and_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int8_and_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_real4_max_to_all</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_real8_max_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int4_max_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int8_max_to_all</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_real4_min_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_real8_min_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int4_min_to_all</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int8_min_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_real4_sum_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_real8_sum_to_all</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int4_sum_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int8_sum_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_real4_prod_to_all</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_real8_prod_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int4_prod_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int8_prod_to_all</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int4_or_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int8_or_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int4_xor_to_all</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int8_xor_to_all</i>(3)</i> </dd>
</dl>
</blockquote>
<blockquote><p>
</blockquote>
</blockquote>
<p>
</blockquote>

<dl>

<dt>Broadcast routines </dt>
<dd></dd>
</dl>
<p>
<blockquote>
<dl>

<dt><b>*</b> </dt>
<dd>C/C++ and Fortran: <blockquote></dd>
</dl>
<p>
<blockquote></blockquote>

<dl>

<dt><b>*</b> </dt>
<dd><i><i>shmem_broadcast32</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_broadcast64</i>(3)</i> </dd>
</dl>
</blockquote>
<blockquote><p>
</blockquote>
</blockquote>
<p>
</blockquote>

<dl>

<dt>Cache management routines </dt>
<dd></dd>
</dl>
<p>
<blockquote>
<dl>

<dt><b>*</b> </dt>
<dd>C/C++ and Fortran: <blockquote></dd>
</dl>
<p>
<blockquote></blockquote>

<dl>

<dt><b>*</b>
</dt>
<dd><i><i>shmem_udcflush</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_udcflush_line</i>(3)</i> </dd>
</dl>
</blockquote>
<blockquote><p>
</blockquote>
</blockquote>
<p>
</blockquote>

<dl>

<dt>Byte-granularity block put routines
</dt>
<dd></dd>
</dl>
<p>
<blockquote>
<dl>

<dt><b>*</b> </dt>
<dd>C/C++ and Fortran <blockquote></dd>
</dl>
<p>
<blockquote></blockquote>

<dl>

<dt><b>*</b> </dt>
<dd><i><i>shmem_putmem</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_getmem</i>(3)</i> </dd>
</dl>
</blockquote>
<blockquote><p>
</blockquote>

<dl>

<dt><b>*</b> </dt>
<dd>Fortran only:
<blockquote></dd>
</dl>
<p>
<blockquote></blockquote>

<dl>

<dt><b>*</b> </dt>
<dd><i><i>shmem_character_put</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_character_get</i>(3)</i> </dd>
</dl>
</blockquote>
<blockquote><p>
</blockquote>
</blockquote>
<p>
</blockquote>

<dl>

<dt>Collect routines </dt>
<dd><blockquote></dd>

<dt><b>*</b> </dt>
<dd>C/C++
and Fortran: <blockquote></dd>
</dl>
<p>
<blockquote></blockquote>

<dl>

<dt><b>*</b> </dt>
<dd><i><i>shmem_collect32</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_collect64</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_fcollect32</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_fcollect64</i>(3)</i> </dd>
</dl>
</blockquote>
<blockquote><p>
</blockquote>
</blockquote>
<p>
</blockquote>

<dl>

<dt>Atomic memory fetch-and-operate (fetch-op) routines
</dt>
<dd><blockquote></dd>

<dt><b>*</b> </dt>
<dd>C/C++ only: <blockquote></dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_double_swap</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_float_swap</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int_cswap</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int_fadd</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int_finc</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int_swap</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_long_cswap</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_long_fadd</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_long_finc</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_long_swap</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_longlong_cswap</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_longlong_fadd</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_longlong_finc</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_longlong_swap</i>(3)</i>
</dd>
</dl>
</blockquote>
<blockquote><p>
</blockquote>

<dl>

<dt><b>*</b> </dt>
<dd>Fortran only: <blockquote></dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int4_cswap</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int4_fadd</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int4_finc</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int4_swap</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int8_swap</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_real4_swap</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_real8_swap</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int8_cswap</i>(3)</i> </dd>
</dl>
</blockquote>
<blockquote><p>
</blockquote>
</blockquote>
<p>
</blockquote>

<dl>

<dt>Atomic memory operation routines </dt>
<dd><blockquote></dd>

<dt><b>*</b> </dt>
<dd>Fortran only:
<blockquote></dd>
</dl>
<p>
<blockquote></blockquote>

<dl>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int4_add</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_int4_inc</i>(3)</i> </dd>
</dl>
</blockquote>
<blockquote><p>
</blockquote>
</blockquote>
<p>
</blockquote>

<dl>

<dt>Remote memory pointer function
</dt>
<dd><blockquote></dd>

<dt><b>*</b> </dt>
<dd>C/C++ and Fortran: <blockquote></dd>
</dl>
<p>
<blockquote></blockquote>

<dl>

<dt><b>*</b> </dt>
<dd><i><i>shmem_ptr</i>(3)</i> </dd>
</dl>
</blockquote>
<blockquote><p>
</blockquote>
</blockquote>
<p>
</blockquote>

<dl>

<dt>Reduction routines </dt>
<dd><blockquote></dd>

<dt><b>*</b> </dt>
<dd>C/C++ only: <blockquote></dd>

<dt><b>*</b>
</dt>
<dd><i><i>shmem_longdouble_max_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_longdouble_min_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_longdouble_prod_to_all</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_longdouble_sum_to_all</i>(3)</i> </dd>
</dl>
</blockquote>
<blockquote><p>
</blockquote>

<dl>

<dt><b>*</b> </dt>
<dd>Fortran only: <blockquote></dd>
</dl>
<p>
<blockquote></blockquote>

<dl>

<dt><b>*</b> </dt>
<dd><i><i>shmem_real16_max_to_all</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_real16_min_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_real16_prod_to_all</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_real16_sum_to_all</i>(3)</i>
</dd>
</dl>
</blockquote>
<blockquote><p>
</blockquote>
</blockquote>
<p>
</blockquote>

<dl>

<dt>Accessibility query routines </dt>
<dd><blockquote></dd>

<dt><b>*</b> </dt>
<dd>C/C++ and Fortran: <blockquote></dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_pe_accessible</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_addr_accessible</i>(3)</i> </dd>
</dl>
</blockquote>
<blockquote><p>
</blockquote>
</blockquote>
<p>
</blockquote>

<dl>

<dt>Symmetric Data Objects </dt>
<dd></dd>
</dl>
<p>
Consistent with the SPMD
nature of the OpenSHMEM programming model is the concept of symmetric data
objects. These are arrays or variables that exist with the same size, type,
and relative address on all PEs. Another term for symmetric data objects
is "remotely accessible data objects". In the interface definitions for
OpenSHMEM data transfer routines, one or more of the parameters are typically
required to be symmetric or remotely accessible. <p>
The following kinds of
data objects are symmetric: <blockquote>
<dl>

<dt><b>*</b> </dt>
<dd>Fortran data objects in common blocks or
with the SAVE attribute. These data objects must not be defined in a dynamic
shared object (DSO). </dd>

<dt><b>*</b> </dt>
<dd>Non-stack C and C++ variables. These data objects must
not be defined in a DSO. </dd>

<dt><b>*</b> </dt>
<dd>Fortran arrays allocated with <i><i>shpalloc</i>(3F)</i> </dd>

<dt><b>*</b>
</dt>
<dd>C and C++ data allocated by <i><i>shmalloc</i>(3C)</i> </dd>
</dl>
</blockquote>
<blockquote><p>
</blockquote>

<dl>

<dt>Collective Routines </dt>
<dd>Some SHMEM
routines, for example, <i><i>shmem_broadcast</i>(3)</i> and <i><i>shmem_float_sum_to_all</i>(3)</i>,
are classified as collective routines because they distribute work across
a set of PEs. They must be called concurrently by all PEs in the active
set defined by the PE_start, logPE_stride, PE_size argument triplet. The
following man pages describe the OpenSHMEM collective routines: <blockquote></dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_and</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_barrier</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_broadcast</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_collect</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_max</i>(3)</i>
</dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_min</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_or</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_prod</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_sum</i>(3)</i> </dd>

<dt><b>*</b> </dt>
<dd><i><i>shmem_xor</i>(3)</i>
</dd>
</dl>
</blockquote>
<blockquote><p>
</blockquote>
<p>

<h2><a name='sect3' href='#toc3'>Using the Symmetric Work Array, Psync</a></h2>

<p> Multiple pSync arrays are often needed
if a particular PE calls as OpenSHMEM collective routine twice without
intervening barrier synchronization. Problems would occur if some PEs in
the active set for call 2 arrive at call 2 before processing of call 1
is complete by all PEs in the call 1 active set. You can use <i><i>shmem_barrier</i>(3)</i>
or <i><i>shmem_barrier_all</i>(3)</i> to perform a barrier synchronization between consecutive
calls to OpenSHMEM collective routines. <p>
There are two special cases: </blockquote>

<dl>

<dt><b>*</b> </dt>
<dd>The
<i><i>shmem_barrier</i>(3)</i> routine allows the same pSync array to be used on consecutive
calls as long as the active PE set does not change. </dd>

<dt><b>*</b> </dt>
<dd>If the same collective
routine is called multiple times with the same active set, the calls may
alternate between two pSync arrays. The SHMEM routines guarantee that a
first call is completely finished by all PEs by the time processing of
a third call begins on any PE. </dd>
</dl>
<p>
Because the SHMEM routines restore pSync
to its original contents, multiple calls that use the same pSync array
do not require that pSync be reinitialized after the first call. <p>

<h2><a name='sect4' href='#toc4'>Shmem Environment
Variables</a></h2>

<p> This section lists the significant SHMEM environment variables.

<dl>

<dt><b>*</b> </dt>
<dd><b>SMA_VERSION</b> print the library version at start-up. </dd>

<dt><b>*</b> </dt>
<dd><b>SMA_INFO</b> print helpful
text about all these environment variables. </dd>

<dt><b>*</b> </dt>
<dd><b>SMA_SYMMETRIC_SIZE</b> number
of bytes to allocate for the symmetric heap. </dd>

<dt><b>*</b> </dt>
<dd><b>SMA_DEBUG</b> enable debugging
messages. </dd>
</dl>
<p>
The first call to SHMEM must be <i><i>start_pes</i>(3)</i>. This routines initialize
the SHMEM runtime. <p>
Calling any other SHMEM routines beforehand has undefined
behavior. Multiple calls to this routine is not allowed. <p>

<h2><a name='sect5' href='#toc5'>Compiling and Running
Openshmem Programs</a></h2>

<p> The OpenSHMEM specification is silent regarding how
OpenSHMEM programs are compiled, linked and run. This section shows some
examples of how wrapper programs could be utilized to compile and launch
applications. The commands are styled after wrapper programs found in many
MPI implementations. <p>
The following sample command line demonstrates running
an OpenSHMEM Program using a wrapper script (<b>oshrun</b> in this case): <p>

<dl>

<dt><b>*</b> </dt>
<dd>C/C++:
<br>
<pre>oshcc c_program.c
</pre> </dd>

<dt><b>*</b> </dt>
<dd>FORTRAN: <br>
<pre>oshfort fortran_program.f
</pre> </dd>
</dl>
<p>
The following sample command line demonstrates running an OpenSHMEM Program
assuming that the library provides a wrapper script for such purpose (named
<b>oshrun</b> for this example): <p>
<br>
<pre>oshrun -np 32 ./a.out
</pre> <p>

<h2><a name='sect6' href='#toc6'>Examples</a></h2>

<p> <b>Example 1</b>: The following Fortran OpenSHMEM program directs all
PEs to sum simultaneously the numbers in the VALUES variable across all
PEs: <br>
<pre>PROGRAM REDUCTION
  REAL VALUES, SUM
  COMMON /C/ VALUES
  REAL WORK
  CALL START_PES(0)
  VALUES = MY_PE()
  CALL SHMEM_BARRIER_ALL ! Synchronize all PEs
  SUM = 0.0
  DO I = 0, NUM_PES()-1
    CALL SHMEM_REAL_GET(WORK, VALUES, 1, I) ! Get next value
    SUM = SUM + WORK                ! Sum it
  ENDDO
  PRINT *, &rsquo;PE &rsquo;, MY_PE(), &rsquo; COMPUTED SUM=&rsquo;, SUM
  CALL SHMEM_BARRIER_ALL
END
</pre> <b>Example 2</b>: The following C OpenSHMEM program transfers an array of 10
longs from PE 0 to PE 1: <br>
<pre>#include &lt;mpp/shmem.h&gt;
main() {
  long source[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
  static long target[10];
  shmem_init();
  if (shmem_my_pe() == 0) {
    /* put 10 elements into target on PE 1 */
    shmem_long_put(target, source, 10, 1);
  }
  shmem_barrier_all(); /* sync sender and receiver */
  if (shmem_my_pe() == 1)
    printf("target[0] on PE %d is %d\n", shmem_my_pe(), target[0]);
}
</pre>
<h2><a name='sect7' href='#toc7'>See Also</a></h2>

<p> The following man pages also contain information on OpenSHMEM
routines. See the specific man pages for implementation information. <p>
<i><i>shmem_add</i>(3)</i>,
<i><i>shmem_and</i>(3)</i>, <i><i>shmem_barrier</i>(3)</i>, <i><i>shmem_barrier_all</i>(3)</i>, <i><i>shmem_broadcast</i>(3)</i>,
<i><i>shmem_cache</i>(3)</i>, <i><i>shmem_collect</i>(3)</i>, <i><i>shmem_cswap</i>(3)</i>, <i><i>shmem_fadd</i>(3)</i>, <i><i>shmem_fence</i>(3)</i>,
<i><i>shmem_finc</i>(3)</i>, <i><i>shmem_get</i>(3)</i>, <i><i>shmem_iget</i>(3)</i>, <i><i>shmem_inc</i>(3)</i>, <i><i>shmem_iput</i>(3)</i>,
<i><i>shmem_lock</i>(3)</i>, <i><i>shmem_max</i>(3)</i>, <i><i>shmem_min</i>(3)</i>, <i><i>shmem_my_pe</i>(3)</i>, <i><i>shmem_or</i>(3)</i>,
<i><i>shmem_prod</i>(3)</i>, <i><i>shmem_put</i>(3)</i>, <i><i>shmem_quiet</i>(3)</i>, <i><i>shmem_short_g</i>(3)</i>, <i><i>shmem_short_p</i>(3)</i>,
<i><i>shmem_sum</i>(3)</i>, <i><i>shmem_swap</i>(3)</i>, <i><i>shmem_wait</i>(3)</i>, <i><i>shmem_xor</i>(3)</i>, <i><i>shmem_pe_accessible</i>(3)</i>,
<i><i>shmem_addr_accessible</i>(3)</i>, <i><i>shmem_init</i>(3)</i>, <i><i>shmem_malloc</i>(3C)</i>, <i><i>shmem_my_pe</i>(3I)</i>,
<i><i>shmem_n_pes</i>(3I)</i> <p>

<hr><p>
<a name='toc'><b>Table of Contents</b></a><p>
<ul>
<li><a name='toc0' href='#sect0'>Name</a></li>
<li><a name='toc1' href='#sect1'>Description</a></li>
<li><a name='toc2' href='#sect2'>Openshmem Routines</a></li>
<li><a name='toc3' href='#sect3'>Using the Symmetric Work Array, Psync</a></li>
<li><a name='toc4' href='#sect4'>Shmem Environment Variables</a></li>
<li><a name='toc5' href='#sect5'>Compiling and Running Openshmem Programs</a></li>
<li><a name='toc6' href='#sect6'>Examples</a></li>
<li><a name='toc7' href='#sect7'>See Also</a></li>
</ul>


<p> <a href="../">&laquo; Return to documentation listing</a></p>
<?php
include_once("$topdir/includes/footer.inc");
